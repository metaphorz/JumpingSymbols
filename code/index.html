<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<!-- style for a last page -->
<style type="text/css">

@font-face {
	font-family: 'HandWrittingFont';
	src: url('./font/alisonsh-webfont.eot#');
	src: url('./font/alisonsh-webfont.woff') format('woff'),
		url('./font/alisonsh-webfont.ttf') format('truetype'),
		url('./font/alisonsh-webfont.svg') format('svg');
	font-weight: normal;
	font-style: normal;
}

.table {
	border-spacing: 1px;
	padding: 0px;
	margin: 0px;
}

.canvas {
	border-spacing: 0px;
	padding: 0px;
	margin: 0px;
}
</style>

<script src="Parser.js" type="text/javascript" charset="utf-8"></script>
<script src="QuestionGenerator.js" type="text/javascript" charset="utf-8"></script>
<script src="dragdealer.js" type="text/javascript" charset="utf-8"></script>

<script>

/*======================== Variable Part ========================*/
/*Constant for Box*/

var mainFont = "HandWrittingFont";											//Web Font use. I used font-face in line 9. Check see line 9
var fontFamily = "font-family: " + mainFont + ", Calibri, sans-serif;";		//Web Font
var boldForStyle = "font-weight: bold;";									//bold for Web font
var boldForCanvasContext = "bold ";											//bold for canvas

var BOX_WIDTH=55;						//width of box
var BOX_HEIGHT=55;						//height of box
var TREE_BOX_WIDTH=30;					//width of tree box
var TREE_BOX_HEIGHT=30;					//height of tree box

var MARGIN_X=80;						//left margin of first box
var MARGIN_Y=50;						//top margin of first box
var GAP = 5;							//gap beween boxes
var CENTER_ALIGN_HEIGHT=11;				//for center align of number in box
var TEXT_SIZE="25";						//text size in canvas
var TREE_TEXT_SIZE="12";				//text size in tree canvas

/*Constant for Canvas*/
var CANVAS_WIDTH=1000;					//width of canvas
var CANVAS_HEIGHT=800;					//height of canvas
var INTERVAL = 20; 						//how often, in milliseconds, we check to see if a redraw is needed

/*variables for box*/
var boxes = [];							//for drag&drop in last page
var answers = [];						//for answer about each question in last page
var rightDropRules = [];				//for rules in last page
var wrongDropRules = [];				//for rules in last page

var myDragSource;						//pointer which indicates a draged box
var myDropTarget;						//pointer which indicates a droped box

/*variables for tree box*/
var treeBoxForDrag;						//is used when box in tree is dragged

/*flags for states*/
var isDragging = false;					//when set to true, the box is dragging
var isMoved = false;					//when set to true, the box is moved. this is for in case a user click the box without dragging.
var isCanvasValid = false;				//when set to true, the canvas will redraw everything in canvas INTERVAL milliseconds
var isTreeBoxReturning = false;			//when set to true, the box is returning
var isTreeCanvasValid = false;			//when set to true, the canvas in tree will redraw everything in canvas INTERVAL milliseconds

/*variables for canvas*/
var canvas;								//canvas
var ctx;								//canvas context
var ghostcanvas;						//we use a fake canvas to draw individual shapes for selection testing
var gctx; 								//fake canvas context

var mx, my; 							//mouse coordinates

var offsetX;							//since we can drag from anywhere in a node instead of just its x/y corner,
var offsetY;							//we need to save the offset of the mouse when we start dragging.

/*variables for canvas in tree*/
var treeCanvas;							//canvas in tree
var treeCtx;							//canvas context in tree
var treeGhostCanvas;					//we use a fake canvas in tree to draw individual shapes for selection testing
var treeGctx;							//fake canvas context in tree

/*variable for questions*/
var questions = [];						//for each question in last page
var tree;								//is used when tree is set
var treeQuestion;						//question that is composed of boxes in tree

var questionNumber;						//How many problems would you like?	for first page
var questionTime;						//How long will it take you? for first page

var myQuestionIndex;					//question number which user selects
var treeQuestionIndex;					//question number which user selects. that is used in tree
var treeSourceIndex;					//dragged box in tree
var treeTargetIndex;					//target box in tree. source box is dragged on target box.

var fractionsEnabled = true;            //if set, fractions are enabled in program

/*variables for window message*/
var rightDropMessage = "";				//message and tip when drop is right.
var wrongDropMessages = [];				//message and tip when drop is wrong.

/*variables for parse*/
var parser = new TapDigit.Parser();		//parser object

/*variables for time*/
var timer;								//timer pointer
var timeText=0;							//time text : increase 1 per 1sec
var timeTextForLastPage="00:00:00"; 	//time text for last page

/*variables for STATES in up-side menu*/
var interactionState = "WINDOW";		//WINDOW, RULE, DEBUG     default - WINDWOW
										//WINDOW - show message and tip when box is droped
										//RULE - show what rule is applied when box is droped
										//OFF - no message and tip

var parseState = "OFF";					//ON, OFF	default - OFF
										//ON - show parse tree of a slected question
										//OFF - no parse tree

var fontState = "HAND-BOLD";			//HAND-BOLD, HAND, NORMAL

var treeState = "TOP-DOWN";				//TOP-DOWN, BOTTOM-UP,	DETAIL	default - TOP-DOWN

var animationSpeed = 50;				//it is showd as a slide bar

var lastposx = 0;							//ramin added

var pageState = "1";					//Flag for each page
										//askQuestionNumberAndTime()	- first page
										//showQuestions()				- second page
										//showSingleQuestion()			- third page. they are showed as many as questions
										//showAllQuestionsAndAnswer()	- forth page. it is showed. user want to resolve the questions
										//canvasInit()					- last page

/*variables for animation*/
var tempQuestion;						//this is used when animation occurs
var isAnimationFinished = false;		//when set to true, the animation is finished
var isTreePaneUsing = false;			//when set to true, users are using tree pane

/*Box obejct*/
function Box() {

	this.x = 0.0;						//coordinates x
	this.y = 0.0;						//coordinates y
	this.destinationX;					//coordinates x used when animation occurs
	this.destinationY;					//coordinates y used when animation occurs
	this.w = BOX_WIDTH; 				//width
	this.h = BOX_HEIGHT;				//heigh
	this.key;							//number or operator or parenthesis
	this.animationType;					//linearMotion, [1~9]ArcForward, [1~9]ArcBackward

	this.rules=[];						//name of rule

	this.isAnimating = false;			//when set to true, the box is being animated
	this.isVisible = true;				//when set to true, the box is not showed
	this.isSelected = false;			//when set to true, the box is selected
	this.isSelectedCandidate = false;	//when set to true, the box is being dragged on candidate box
	this.isCandidate = false;			//when set to true, the box is dropable : right drop
	this.isRightRule = true;			//when set to true, the candiate box is drawed in black color, otherwise, in gray color
	this.isDistributive = false;		//when set to true, the box is distributive

	this.animationAccelerationX=0.0;	//acceleration X when animation occurs
	this.animationAccelerationY=0.0;	//acceleration Y when animation occurs

	this.fill = '#FFFFFF';				//box color : white
}

/*function of Box object*/
Box.prototype = {
	checkDragOver : function(context) {
		context.fillStyle = 'black'; 	//always want black for the ghost canvas

		if (myDragSource !== this) {
			context.fillRect(this.x, this.y, this.w, this.h);
		}
	},
	//Each box have own ability to draw itself
	draw : function(context) {

		if (context === gctx || context === treeGctx) {
			context.fillStyle = 'black'; // always want black for the ghost canvas
		} else {
			context.fillStyle = this.fill;
		}

		if(this.isAnimating == true){

			var type = this.animationType.slice(1, this.animationType.length);

			if(this.animationType == 'linearMotion'){
				//for animation of box
				if(this.animationAccelerationX != 0){
					if( Math.abs((this.destinationX - this.x)) < Math.abs(this.animationAccelerationX) ){
						this.x = this.destinationX;
						this.y = this.destinationY;

						this.animationAccelerationX = 0.0;
						this.animationAccelerationY = 0.0;

						this.isAnimating = false;
						isAnimationFinished = true;

						isTreeBoxReturning = false;

						if(treeBoxForDrag != null){
							myDragSource.isVisible = true;
							treeBoxForDrag = null;
						}
						myDragSource = null;
					}else{
						this.x = this.x - this.animationAccelerationX;
						this.y = this.y - this.animationAccelerationY;
					}
				}else if(this.animationAccelerationY != 0){	//When x isnt moved and only y is moved
					if( Math.abs((this.destinationY - this.y)) < Math.abs(this.animationAccelerationY) ){
						this.x = this.destinationX;
						this.y = this.destinationY;

						this.animationAccelerationX = 0.0;
						this.animationAccelerationY = 0.0;

						this.isAnimating = false;
						isAnimationFinished = true;

						isTreeBoxReturning = false;

						if(treeBoxForDrag != null){
							myDragSource.isVisible = true;
							treeBoxForDrag = null;
						}
						myDragSource = null;

					}else{
						this.x = this.x - this.animationAccelerationX;
						this.y = this.y - this.animationAccelerationY;
					}
				}else{
					this.x = this.destinationX;
					this.y = this.destinationY;

					this.animationAccelerationX = 0.0;
					this.animationAccelerationY = 0.0;

					this.isAnimating = false;
					isAnimationFinished = true;

					isTreeBoxReturning = false;

					if(treeBoxForDrag != null){
						myDragSource.isVisible = true;
						treeBoxForDrag = null;
					}
					myDragSource = null;


				}

			}else if(type == 'ArcBackward'){

				var a = 0;
				if(this.animationType == '1ArcBackward'){
					a = -0.066;
				}else if(this.animationType == '2ArcBackward'){
					a = -0.01666;
				}else if(this.animationType == '3ArcBackward'){
					a = -0.0074;
				}else if(this.animationType == '4ArcBackward'){
					a = -0.0041;
				}else if(this.animationType == '5ArcBackward'){
					a = -0.00265;
				}else if(this.animationType == '6ArcBackward'){
					a = -0.00184;
				}else if(this.animationType == '7ArcBackward'){
					a = -0.00135;
				}else if(this.animationType == '8ArcBackward'){
					a = -0.00103;
				}else if(this.animationType == '9ArcBackward'){
					a = -0.00081;
				}

				var angularPointX = 30 * parseFloat(this.animationType.charAt(0));
				var angularPointY = 60;

				var offsetX = (angularPointX*2.0)/animationSpeed;
				lastposx = this.x;
				this.x = this.x - offsetX;

				var offsetY = a * ((this.destinationX - this.x) - angularPointX)*((this.destinationX - this.x) - angularPointX) + angularPointY;
				this.y = this.destinationY - offsetY;

				if(this.y >= this.destinationY){
					this.x = this.destinationX-(angularPointX*2);
					this.y = this.destinationY;
					this.isAnimating = false;
					isAnimationFinished = true;

				}
			}else if(type == 'ArcForward'){
				var a = 0;
				if(this.animationType == '1ArcForward'){
					a = -0.066;
				}else if(this.animationType == '2ArcForward'){
					a = -0.01666;
				}else if(this.animationType == '3ArcForward'){
					a = -0.0074;
				}else if(this.animationType == '4ArcForward'){
					a = -0.0041;
				}else if(this.animationType == '5ArcForward'){
					a = -0.00265;
				}else if(this.animationType == '6ArcForward'){
					a = -0.00184;
				}else if(this.animationType == '7ArcForward'){
					a = -0.00135;
				}else if(this.animationType == '8ArcForward'){
					a = -0.00103;
				}else if(this.animationType == '9ArcForward'){
					a = -0.00081;
				}

				var angularPointX = 30 * parseFloat(this.animationType.charAt(0));
				var angularPointY = 60;

				var offsetX = (angularPointX*2)/animationSpeed;
				lastposx = this.x;
				this.x = this.x + offsetX;

				var offsetY = a * ((this.x - this.destinationX) - angularPointX)*((this.x - this.destinationX) - angularPointX) + angularPointY;
				this.y = this.destinationY - offsetY;

				if(this.y >= this.destinationY){
					this.x = this.destinationX+(angularPointX*2);
					this.y = this.destinationY;
					this.isAnimating = false;
					isAnimationFinished = true;

				}
			}
		}

		//when isVisible is true, box is drawn : that isVisible is false means the box is being dragged
		if(this.isVisible == true){
			if(context === ctx){
				context.fillStyle = "rgba(255,255,255,0.5)";				//White having transparency 50%
			}else{
				context.fillStyle = "rgb(255,255,255)";						//White
			}

			context.fillRect(this.x, this.y, this.w, this.h);	//draw rect in white color

			context.font = boldForCanvasContext  + TEXT_SIZE+"pt " + mainFont;

			context.fillStyle = "#4c4c4c";						//Gray
			context.textAlign = "center";						//text align type

			if(isFraction(this.key)){
				var numerator = "";
				var denominator = "";
				var divisionIndex = 0;

				for (var i=0; i < this.key.length; i++) {
					if(this.key.charAt(i) == '/'){
						divisionIndex = i;
						break;
					}
				}

				for (var i=0; i < divisionIndex; i++) {
					numerator += this.key.charAt(i);
				}

				for (var i=divisionIndex+1; i < this.key.length; i++) {
					denominator += this.key.charAt(i);
				}

				if(context === ctx){
					context.font = boldForCanvasContext  + "18pt " + mainFont;
					context.fillText(numerator, this.x + this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT - 14);	//draw text

					context.font = boldForCanvasContext  + "30pt " + mainFont;
					context.fillText('-', this.x+ this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT);				//draw text

					context.font = boldForCanvasContext  + "18pt " + mainFont;
					context.fillText(denominator, this.x + this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT + 8);	//draw text

				}else if(context === treeCtx){
					context.font = boldForCanvasContext  + "12pt " + mainFont;
					context.fillText(numerator, this.x + this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT - 12);	//draw text

					context.font = boldForCanvasContext  + + TEXT_SIZE+"pt " + mainFont;
					context.fillText('ㅡ', this.x+ this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT);				//draw text

					context.font = boldForCanvasContext  + "12pt " + mainFont;
					context.fillText(denominator, this.x + this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT + 4);	//draw text
				}
			}else{
				if(context === ctx){
					context.font = boldForCanvasContext  + TEXT_SIZE+"pt " + mainFont;
					context.fillText(this.key, this.x+ this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT);			//draw text
				}else if(context === treeCtx){
					if(isOperator(this.key) || isParenthesis(this.key)){
						context.font = boldForCanvasContext  + TEXT_SIZE+"pt " + mainFont;
					}else{
						context.font = boldForCanvasContext  + "20pt " + mainFont;
					}
					context.fillText(this.key, this.x+ this.w/2, this.y+this.h/2+CENTER_ALIGN_HEIGHT);			//draw text
				}
			}

		    //if interaction mode is RULE, rule is showed
		    if(interactionState == "RULE"){

			    if(this.isCandidate == true){
			    	if(this.isRightRule == true){
			    		context.fillStyle = "#3a4bf0"	//soft red
			    	}else{
			    		context.fillStyle = "#f76c6c"	//soft Blue
			    	}

			    	if(context === treeCtx){
			    		context.font = "5pt " + mainFont;
			    	}else {
			    		context.font = "8pt " + mainFont;
			    	}

			    	var length = this.rules.length
			    	for(var i=0; i<length; i++){
			    		context.fillText(this.rules[i], this.x+ this.w/2, this.y+10+(i*10));
			    	}
			    }
		    }

			//draw border of box
		    if(context === treeCtx){
		    	context.font = TEXT_SIZE+"pt " + mainFont;				//font style
		    }else {
		    	context.font = TEXT_SIZE+"pt " + mainFont;				//font style
		    }
			var strokeStyle="#FFFFFF";									//White
			if(this.isSelected == true){
				strokeStyle = "#FF0000";								//Red
			}else if(this.isSelectedCandidate == true){
				if(this.isRightRule == true){
					strokeStyle = "#0000FF";							//Blue
				}
			}else if(this.isDistributive == true){
				strokeStyle = "#FF0000";								//Red
			}else if(this.isCandidate == true){
				if(this.isRightRule == true){
					strokeStyle = "#000000";							//Black
				}else{
					strokeStyle = "#e9e9e9";							//Gray
				}
			}else{
				if(context === ctx){
					strokeStyle = "rgba(255,255,255,0.5)";				//White having transparency 50%
				}else{
					strokeStyle = "rgb(255,255,255)";					//White
				}
			}

			context.strokeStyle = strokeStyle;							//line color
			context.lineWidth = 2;										//line thickness
			context.strokeRect(this.x, this.y, this.w, this.h);			//strock rect
		}

	}
}

/*Answer obejct*/
function Answer() {
	this.answer;				//anser
	this.state = "notDecided";	//corrent, incorrent, notDecided
}


/*======================== Function Part ========================*/

//whenever window is resized, layout is resized. This is for center align
//this is for 1~4 page. It didnt apply to last page.
function resizeWindow() {
	var winW, winH;

	if (self.innerHeight) {
		//for common browsers
		winW = self.innerWidth;
		winH = self.innerHeight;
	} else if (document.documentElement
			&& document.documentElement.clientHeight) {
		//for ie6
		winW = document.documentElement.clientWidth;
		winH = document.documentElement.clientHeight;
	} else if (document.body) {
		//for rest of browsers
		winW = document.body.clientWidth;
		winH = document.body.clientHeight;
	}

	var containerW = document.getElementById('mainBody').scrollWidth;
	var containerH = document.getElementById('mainBody').scrollHeight;

	//horizontal center align
	document.getElementById('mainBody').style.left = String(winW / 2
			- containerW / 2)
			+ 'px';

	//vertical center align
	if (winH < containerH) {
		document.getElementById('mainBody').style.top = 0;
	} else {
		document.getElementById('mainBody').style.top = String(winH
				/ 2 - containerH / 2)
				+ 'px';
	}
}

//initialize
function init(){
	self.onresize = resizeWindow;	//whenever window is resized, layout is resized

	//If you want to just test the last page with specific boxes. remove comment mark below
	/*
	questionNumber = 10;			//set a question number

	for(var i=0; i<questionNumber; i++){
		//questions.push(createQuestion());
		var answer = new Answer;
		answer.answer = "5";
		answers.push(answer);
	}

	var q1 = [];
	q1.push("2");
	q1.push("+");
	q1.push("5");
	q1.push("+");
	q1.push("6");
	q1.push("+");
	q1.push("15");
	q1.push("+");
	q1.push("3");

	var q2 = [];
	q2.push("4");
	q2.push("*");
	q2.push("2");
	q2.push("*");
	q2.push("6");
	q2.push("/");
	q2.push("2");
	q2.push("*");
	q2.push("9");
	q2.push("/");
	q2.push("8");

	var q3 = [];
	q3.push("2");
	q3.push("+");
	q3.push("3");
	q3.push("*");
	q3.push("(");
	q3.push("6");
	q3.push("*");
	q3.push("3");
	q3.push("+");
	q3.push("12");
	q3.push(")");
	q3.push("+");
	q3.push("9");

	var q4 = [];
	q4.push("2");
	q4.push("*");
	q4.push("(");
	q4.push("3");
	q4.push("+");
	q4.push("6");
	q4.push(")");

	var q5 = [];
	q5.push("(");
	q5.push("4");
	q5.push("+");
	q5.push("6");
	q5.push(")");
	q5.push("*");
	q5.push("7");

	var q6 = [];
	q6.push("6");
	q6.push("+");
	q6.push("(");
	q6.push("4");
	q6.push("*");
	q6.push("5");
	q6.push("-");
	q6.push("4");
	q6.push("*");
	q6.push("5");
	q6.push(")");
	q6.push("+");
	q6.push("7");

	var q7 = [];
	q7.push("3");
	q7.push("*");
	q7.push("(");
	q7.push("30");
	q7.push("*");
	q7.push("6");
	q7.push("+");
	q7.push("12");
	q7.push(")");

	var q8 = [];
	q8.push("7");
	q8.push("*");
	q8.push("(");
	q8.push("30");
	q8.push("*");
	q8.push("6");
	q8.push("*");
	q8.push("3");
	q8.push("+");
	q8.push("15");
	q8.push("*");
	q8.push("6");
	q8.push(")");

	var q9 = [];
	q9.push("(");
	q9.push("6");
	q9.push("*");
	q9.push("30");
	q9.push("*");
	q9.push("3");
	q9.push("+");
	q9.push("15");
	q9.push("*");
	q9.push("6");
	q9.push(")");
	q9.push("*");
	q9.push("3");


	var q10 = [];
	q10.push("(");
	q10.push("6");
	q10.push("*");
	q10.push("30");
	q10.push("+");
	q10.push("6");
	q10.push("*");
	q10.push("15");
	q10.push(")");
	q10.push("*");
	q10.push("3");

	questions.push(q1);
	questions.push(q2);
	questions.push(q3);
	questions.push(q4);
	questions.push(q5);
	questions.push(q6);
	questions.push(q7);
	questions.push(q8);
	questions.push(q9);
	questions.push(q10);
	*/


	/*set menu atrributes */
	var interactionFont = document.getElementById("interactionFont");
	var parseFont = document.getElementById("parseFont");
	var fontFont = document.getElementById("fontFont");
	var treeFont = document.getElementById("treeFont");
	var speedFont = document.getElementById("speedFont");

	interactionFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	parseFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	fontFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	treeFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	speedFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");

	var interactionSelect = document.getElementById("interactionSelect");
	var parseSelect = document.getElementById("parseSelect");
	var fontSelect = document.getElementById("fontSelect");
	var treeSelect = document.getElementById("treeSelect");

	interactionSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	parseSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	fontSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	treeSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");

	askQuestionNumberAndTime();

	//If you want to just test the last page. remove comment mark of canvasInit();
	//canvasInit();
}

//first page------------------------------------------------------------------------------------------------------------------------
function askQuestionNumberAndTime(){

	pageState = "1";

	var mainBody = document.getElementById("mainBody");
	mainBody.innerHTML = "<table style='border-spacing:20px;  padding: 10px; border: solid 1px #000000; background-color: #5c7590;'>"
							+"<tr>"
								+"<td>"
									+"<font id='questionNumberFont' color='#f5dfdf'>How many problems would you like?</font>"
								+"</td>"
								+"<td>"
									+"<select id='questionNumberSelect'>"
										+"<option value='1' selected='selected'>1</option>"
										+"<option value='2'>2</option>"
										+"<option value='3'>3</option>"
										+"<option value='4'>4</option>"
										+"<option value='5'>5</option>"
										+"<option value='6'>6</option>"
										+"<option value='7'>7</option>"
										+"<option value='8'>8</option>"
										+"<option value='9'>9</option>"
										+"<option value='10'>10</option>"
									+"</select>"
								+"</td>"
							+"</tr>"
							+"<tr>"
								+"<td>"
									+"<font id='questionTimeFont' color='#f5dfdf'>How long will it take you?</font>"
								+"</td>"
								+"<td>"
									+"<select id='questionTimeSelect'>"
										+"<option value='2' selected='selected'>2 min</option>"
										+"<option value='5'>5 min</option>"
										+"<option value='10'>10 min</option>"
										+"<option value='20'>20 min</option>"
									+"</select>"
								+"</td>"
							+"</tr>"
							+"<tr>"
								+"<td colspan='2' align='center'>"
									+"<input id='okButton' type='button' value='OK' onclick='goShowQuestions()'>"
								+"</td>"
							+"</tr>"
						+"</table>";

	var questionNumberFont = document.getElementById("questionNumberFont");
	var questionTimeFont = document.getElementById("questionTimeFont");
	var questionNumberSelect = document.getElementById("questionNumberSelect");
	var questionTimeSelect = document.getElementById("questionTimeSelect");
	var okButton = document.getElementById("okButton");


	questionNumberFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 30px;");
	questionTimeFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 30px;");
	questionNumberSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 20px; " + boldForStyle + "");
	questionTimeSelect.setAttribute("style", fontFamily + " width: 100px; font-size: 20px; " + boldForStyle + "");
	okButton.setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	resizeWindow();
}
function goShowQuestions(){
	questionNumber = document.getElementById("questionNumberSelect").value;
	questionTime = document.getElementById("questionTimeSelect").value;
	showQuestions();
}
//first page------------------------------------------------------------------------------------------------------------------------





//second page------------------------------------------------------------------------------------------------------------------------
function showQuestions(){

    if(confirm("Would you like to enable fractions?"))
	    fractionsEnabled = true;
	else
	    fractionsEnabled = false;

	pageState = "2";

	var mainBody = document.getElementById("mainBody");
	mainBody.innerHTML = "<font id='problemFont' color='#000000'>Problem</font><br>"
						+"<font id='explanation1Font' color='#000000'></font><br>"
						+"<font id='explanation2Font' color='#000000'></font>"
						+"<table id='questionTable' style='width:1000px; border-spacing:10pt; padding: 5pt; background-color: #FFFFFF;'>"
							+"<tr>"
								+"<td align='center'>"
									+"<input id='goButton' type='button' value='GO' onclick='showSingleQuestion()'>"
								+"</td>"
							+"<tr>"
						+"</table>"

	//generate questions
	for(var i=0; i<questionNumber; i++){
		questions.push(createQuestion(fractionsEnabled));
	}


	var problemFont = document.getElementById("problemFont");
	var explanation1Font = document.getElementById("explanation1Font");
	var explanation2Font = document.getElementById("explanation2Font");

	problemFont.setAttribute("style", fontFamily + " padding-left:10pt; vertical-align: middle; " + boldForStyle + " ; font-size:30pt;");
	explanation1Font.setAttribute("style", fontFamily + " padding-left:50pt; vertical-align: middle; " + boldForStyle + " font-size: 15pt;");
	explanation2Font.setAttribute("style", fontFamily + " padding-left:50pt; vertical-align: middle; " + boldForStyle + " font-size: 15pt;");

	if(questionNumber == 1){
		var explanation1 = document.createTextNode("Here is " + questionNumber + " problem. When you are ready to solve them, press \"Go\".");
	}else{
		var explanation1 = document.createTextNode("Here are " + questionNumber + " problems. When you are ready to solve them, press \"Go\".");
	}
	var explanation2 = document.createTextNode("You have estimated that it will take you "+ questionTime +" minutes to solve these problems.");

	explanation1Font.appendChild(explanation1);
	explanation2Font.appendChild(explanation2);

	var table = document.getElementById("questionTable");
	for(var i=0; i<questionNumber; i++){

		var row = table.insertRow(i);

		var boxLength = questions[i].length;
		var question="";
		for(var j=0; j<boxLength; j++){
			question += questions[i][j] + "  ";
		}
		question+="="
		var cell = row.insertCell(0);

		var pre = document.createElement("pre");
		pre.setAttribute("style", fontFamily + " padding:0pt; margin:0pt;");

		var questionNumberText = document.createTextNode((i+1).toString()+")  ");
		var questionText = document.createTextNode(question);

		var questionNumberFont = document.createElement("font");
		questionNumberFont.setAttribute("id", "questionNumberFont"+i);
		var questionFont = document.createElement("font");
		questionFont.setAttribute("id", "questionFont"+i);

		questionNumberFont.color = "#000080";
		questionNumberFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");

		questionFont.color = "#4c4c4c";
		questionFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");

		questionNumberFont.appendChild(questionNumberText);
		questionFont.appendChild(questionText);

		pre.appendChild(questionNumberFont);
		pre.appendChild(questionFont);

		cell.appendChild(pre);
	}

	var goButton = document.getElementById("goButton");
	goButton.setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	resizeWindow();
}
//second page------------------------------------------------------------------------------------------------------------------------


//single question page------------------------------------------------------------------------------------------------------------------------
function showSingleQuestion(){

	pageState = "3";

	var mainBody = document.getElementById("mainBody");
	mainBody.innerHTML = "<font id='problemFont' color='#000000'>Problem</font><br>"
						+"<table id='singleQuestionTable' style='width:1000px; border-spacing:10pt; padding: 5pt; background-color: #FFFFFF;'>"
						+"<tr>"
							+"<td align='left'>"
								+"<pre style='padding:0pt; margin:0pt;'>"
									+"<font id='singleQuestionNumberFont' color='#000080'></font>"
									+"<font id='singleQuestionFont' color='#4c4c4c'></font>"
									+"<input id='answerText' type='text'>"
									+"<input id='confirmButton' type='button' value='Confirm' onclick='confirmAnswer()'>"
								+"</pre>"
							+"</td>"
						+"</tr>"
						+"<tr>"
							+"<td align='center'>"
								+"<input id='timeText' type='text' value='00:00:00'>"
							+"</td>"
						+"</tr>"
						+"<tr>"
							+"<td align='right'>"
								+"<input id='nextButton' type='button' value='Next' onclick='goNext()' disabled='disabled'>"
							+"</td>"
						+"</tr>"
					+"</table>";

	var problemFont = document.getElementById("problemFont");
	var singleQuestionNumberFont = document.getElementById("singleQuestionNumberFont");
	var singleQuestionFont = document.getElementById("singleQuestionFont");
	var answerText = document.getElementById("answerText");
	var confirmButton = document.getElementById("confirmButton");
	var timeText = document.getElementById("timeText");
	var nextButton = document.getElementById("nextButton");

	problemFont.setAttribute("style", fontFamily + " padding-left:10pt; vertical-align: middle; " + boldForStyle + "; font-size:30pt;");
	singleQuestionNumberFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
	singleQuestionFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
	answerText.setAttribute("style", fontFamily + " text-align:center; font-size:30px; " + boldForStyle + " width:75px; height:50px;");
	confirmButton.setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");
	timeText.setAttribute("style", fontFamily + " text-align:center; font-size:30px; " + boldForStyle + " width:150px; height:50px; background-color:#d3d3d3; border: solid 1px #808080;");
	nextButton.setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	goNext();
	startTimer();
}
//single question page------------------------------------------------------------------------------------------------------------------------

//re-answering page------------------------------------------------------------------------------------------------------------------------
function showAllQuestionsAndAnswer(){

	pageState = "4";

	var mainBody = document.getElementById("mainBody");
	mainBody.innerHTML = "<font id='problemFont' color='#000000'>Problem</font><br>"
						+"<table id='questionTable' style='width:1000px; border-spacing:10pt; padding: 5pt; background-color: #FFFFFF;'>"
							+"<tr>"
							+"<td align='center'>"
								+"<input id='timeText' type='text' value='00:00:00' \>"
							+"</td>"
						+"</tr>"
						+"</table>";

	var problemFont = document.getElementById("problemFont");
	var timeText = document.getElementById("timeText");

	problemFont.setAttribute("style", fontFamily + " padding-left:10pt; vertical-align: middle; " + boldForStyle + "; font-size:30pt;");
	timeText.setAttribute("style", fontFamily + " text-align:center; font-size:30px; " + boldForStyle + " width:150px; height:50px; background-color:#d3d3d3; border: solid 1px #808080;");

	setTime();

	var table = document.getElementById("questionTable");

	for(var i=0; i<questionNumber; i++){

		var row = table.insertRow(i);

		var boxLength = questions[i].length;
		var question="";
		for(var j=0; j<boxLength; j++){
			question += questions[i][j] + "  ";
		}
		question+="=  "
		var cell = row.insertCell(0);

		var pre = document.createElement("pre");
		pre.setAttribute("style", fontFamily + " padding:0pt; margin:0pt;");

		var questionNumberText = document.createTextNode((i+1).toString()+")  ");
		var questionText = document.createTextNode(question);

		var questionNumberFont = document.createElement("font");
		var questionFont = document.createElement("font");

		var questionNumberFont = document.createElement("font");
		questionNumberFont.setAttribute("id", "questionNumberFont"+i);
		var questionFont = document.createElement("font");
		questionFont.setAttribute("id", "questionFont"+i);

		var answerText = document.createElement("input");
		answerText.setAttribute("style", fontFamily + " vertical-align: middle; text-align:center; font-size:30px; " + boldForStyle + " width:75px; height:50px;");
		answerText.id = "answerText"+i;
		answerText.type = "text";
		answerText.value = answers[i].answer;
		answerText.setAttribute("onclick", "enableConfirm("+i+")");

		var button = document.createElement("input");
		button.setAttribute("id", "button"+i);
		button.setAttribute("style", fontFamily + " vertical-align: middle; font-size:30px; " + boldForStyle + " width:150px; height:50px;");
		button.id = "confirmButton"+i;
		button.type = "button";
		button.value = "Confirm";
		button.setAttribute("onclick", "editAnswer("+i+")");
		button.disabled = true;

		questionNumberFont.color = "#000080";
		questionNumberFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");

		questionFont.color = "#4c4c4c";
		questionFont.setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");

		questionNumberFont.appendChild(questionNumberText);
		questionFont.appendChild(questionText);

		pre.appendChild(questionNumberFont);
		pre.appendChild(questionFont);
		pre.appendChild(answerText);
		pre.appendChild(button);

		cell.appendChild(pre);
	}
	resizeWindow();
}
function enableConfirm(questionIndex){
	var confirmButton = document.getElementById("confirmButton"+questionIndex);
	confirmButton.disabled = false;
}
function editAnswer(questionIndex){
	var answerTest = document.getElementById("answerText"+questionIndex);

	if( confirm("Are you sure that "+ answerTest.value +" is the right answer?") ){
		answers[questionIndex].answer = answerTest.value;
		var confirmButton = document.getElementById("confirmButton"+questionIndex);
		confirmButton.disabled = true;

		var isAllButtonDisabled = true;

		for(var i=0; i<questionNumber; i++){
			var confirmButton = document.getElementById("confirmButton"+i);

			if(confirmButton.disabled == false){
				//if any button is activated, still work on
				isAllButtonDisabled = false;
			}
		}

		if(isAllButtonDisabled == true){
			//if all buttion are dis-activated, step to next level
			if(confirm("Are you ready to check your answers?")){
				canvasInit();
			}
		}
	}
}

var questionCount = 0;
function goNext(){
	//change button's name to 'Solve'
	if(questionNumber <= questionCount+1){
		var nextButton = document.getElementById("nextButton");
		nextButton.value = "Solve";
	}

	if(questionNumber <= questionCount){

		//go to next page
		if(confirm("Are you ready to check your answers?")){
			//last page
			canvasInit();
		}else{
			//re-answering page
			showAllQuestionsAndAnswer();
		}
		return;
	}

	var boxLength = questions[questionCount].length;
	var question="";
	for(var j=0; j<boxLength; j++){
		question += questions[questionCount][j] + "  ";
	}
	question+="=  ";

	var singleQuestionNumberText = document.createTextNode((questionCount+1).toString()+") ");
	var singleQuestionText = document.createTextNode(question);

	var singleQuestionNumberFont = document.getElementById("singleQuestionNumberFont");
	var singleQuestionFont = document.getElementById("singleQuestionFont");

	//if node has child, remove before child
	if(singleQuestionFont.childNodes.length !=0 ){
		singleQuestionNumberFont.removeChild(singleQuestionNumberFont.lastChild);
		singleQuestionFont.removeChild(singleQuestionFont.lastChild);
	}
	singleQuestionNumberFont.appendChild(singleQuestionNumberText);
	singleQuestionFont.appendChild(singleQuestionText);


	var confirmButton = document.getElementById("confirmButton");
	var nextButton = document.getElementById("nextButton");
	var answerText = document.getElementById("answerText");
	nextButton.disabled = true;
	confirmButton.disabled = false;
	answerText.value="";
}

function confirmAnswer(){
	var confirmButton = document.getElementById("confirmButton");
	var nextButton = document.getElementById("nextButton");
	var answerText = document.getElementById("answerText");

	//generate confirm window
	if(confirm("Are you sure that "+answerText.value+" is the right answer?")){

		if(questionNumber <= questionCount+1){
			alert("Press \"Solve\" to check your answers");
		}else{
			alert("Press \"Next\" to solve the next question");
		}

		nextButton.disabled = false;	//next is activated
		confirmButton.disabled = true;
		var answer = new Answer;
		answer.answer = answerText.value;
		answers.push(answer);

		//increase for next question
		questionCount++;
	}
}
//re-answering page------------------------------------------------------------------------------------------------------------------------


//initialize last page(canvas page)----------------------------------------------------------------------------------------------------------------------
function canvasInit() {

	pageState = "5";

	self.onresize = null; 	//stop center align

	var interactionSelect = document.getElementById("interactionSelect");
	var parseSelect = document.getElementById("parseSelect");
	var treeSelect = document.getElementById("treeSelect");
	var speedSlideBar = document.getElementById("speedSlideBar");

	interactionSelect.disabled = false;
	parseSelect.disabled = false;
	treeSelect.disabled = false;
	speedSlideBar.disabled = false;

	//set a layout
	document.getElementById("mainBody").setAttribute("style", "margin: 0px; padding: 0px;");
	document.getElementById("mainBody").innerHTML = "<table class='table' style='margin: auto; table-layout:fixed;'>"
														+"<tr class='canvas'>"
															+"<td class='canvas' style='border: solid 2px #000000;' rowspan='2'>"
																+"<div class='canvas' id='questionBody' style='width: 1000px; height: 800px;'></div>"
															+"</td>"
															+"<td class='canvas' style='border: solid 2px #000000;'>"
																+"<div class='canvas' id='treeBody' style='width: 600px; height:400px; overflow:auto;'></div>"
															+"</td>"
														+"</tr>"
														+"<tr>"
															+"<td class='canvas' style='border: solid 2px #000000;'>"
																+"<pre class='canvas' id='ruleBody'></pre>"
															+"</td>"
														+"</tr>"
													+"</table>";

	var ruleBody = document.getElementById("ruleBody");
	ruleBody.setAttribute("style", fontFamily + " width:600px; height:400px; overflow:auto;");

	var questionBody = document.getElementById("questionBody");
	questionBody.innerHTML="";

	//set a canvas
	canvas = document.createElement("canvas");
	canvas.width = CANVAS_WIDTH;
	canvas.height = CANVAS_HEIGHT;
	canvas.setAttribute("style", "background-color:#ffffff;");
	canvas.setAttribute("class", "canvas");

	questionBody.appendChild(canvas);

	ctx = canvas.getContext('2d');

	//set a fake canvas
	ghostcanvas = document.createElement('canvas');
	ghostcanvas.width = CANVAS_WIDTH;
	ghostcanvas.height = CANVAS_HEIGHT;
	ghostcanvas.setAttribute("class", "canvas");

	gctx = ghostcanvas.getContext('2d');


	setInterval(mainDraw, INTERVAL); 	//make mainDraw() fire every INTERVAL milliseconds

	//set our events.
	canvas.onmousedown = onMouseDown;
	canvas.onmouseup = onMouseUp;
	canvas.onmousemove = onMouseMove;

	canvas.ontouchstart = onTouchStart;
	canvas.ontouchend = onTouchEnd;
	canvas.ontouchmove = onTouchMove;

	canvas.onmouseout = onMouseUp;

	//fixes a problem where double clicking causes text to get selected on the canvas
	canvas.onselectstart = function() {
		return false;
	}

	//stop timer and set a time
	stopTimer();
	var hours = Math.floor(timeText / 360);			//hours
	var minutes = Math.floor(timeText / 60);		//minutes
	var seconds = timeText % 60;					//seconds
	timeTextForLastPage = getTwoDigitTime(hours)+":"+getTwoDigitTime(minutes)+":"+getTwoDigitTime(seconds);	//set a time

	//relate questions with key of boxes
	for(var i=0; i<questionNumber; i++){
		boxes[i] = new Array();

		var boxLength = questions[i].length;
		for(var j=0; j<boxLength; j++){
			var rect = new Box;
			rect.x = MARGIN_X+j*(BOX_WIDTH+GAP);
			rect.y = MARGIN_Y+i*(BOX_HEIGHT+GAP);
			rect.key = questions[i][j];

			boxes[i][j] = rect;
		}
	}

	//for Rules
	for(var i=0; i<=5; i++){
		rightDropRules[i] = new Array();
		wrongDropRules[i] = new Array();
		for(var j=0; j<=10; j++){
			wrongDropRules[i][j] = new Array();
		}
	}

	rightDropRules[1][1] = "Rule ID ('Rule_R1-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N2), HasChild(RChild(B1), N3),<br>"+
	"        Equal(O1, B1.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [B1.L.n.k] and [B1.R.n.k].)<br>"+

	"<br>Example<br>"+
	"3/*+-4 or +-3+-4 or /*+-3/*4 or /*+-3/*4+-<br>"+
	"drag '3' or '4' and drop on 'operator' between '3' and '4'<br>";

	wrongDropRules[1][1][1] = "Rule ID ('Rule_W1-1-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N2), HasChild(RChild(B1), N3),<br>"+
	"        !Equal(O1, B1.o) )<br>"+
	"THEN Write(You must first simplify [B1.L.n.k][B1.o.k][B1.R.n.k] before continuing.)<br>"+

	"<br>Example<br>"+
	"3/*+-4 or +-3+-4 or /*+-3/*4 or /*+-3/*4+-<br>"+
	"drag '3' or '4' and drop on 'operator' which is not between '3' and '4'<br>";


	rightDropRules[1][2] = "Rule ID ('Rule_R1-2')<br>"+

	"<br>Rule<br>"+
	"F And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {*, /}),<br>"+
	"        Equal(O1, B1.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [N2.k].)<br>"+

	"<br>Example<br>"+
	"3/*4/* or /*+-3/*4/*<br>"+
	"drag '3' and drop on 'operator' between '3'<br>";



	wrongDropRules[1][2][1] = "Rule ID ('Rule_W1-2-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {*, /}),<br>"+
	"        !Equal(O1, B1.o) )<br>"+
	"THEN Write(You must first simplify [N1.k][B1.o.k][B2.L.n.k] before continuing.)<br>"+
	"<br>Example<br>"+
	"3/*4/* or /*+-3/*4/*<br>"+
	"drag '3' and drop on 'operator' which is not between '3' and '4'<br>";



	rightDropRules[1][3] = "Rule ID ('Rule_R1-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {+, -}),<br>"+
	"        Equal(O1, B1.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [N2.k].)<br>"+

	"<br>Example<br>"+
	"3+-4+- or +-3+-4+-<br>"+
	"drag '3' and drop on 'operator' between '3' and '4'<br>";



	wrongDropRules[1][3][1] = "Rule ID ('Rule_W1-3-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {+, -}),<br>"+
	"        !Equal(O1, B1.o) )<br>"+
	"THEN Write(You must first simplify [N1.k][B1.o.k][B2.L.n.k] before continuing.)<br>"+

	"<br>Example<br>"+
	"3+-4+- or +-3+-4+-<br>"+
	"drag '3' and drop on 'operator' between '3' and '4'<br>";


	rightDropRules[1][4] = "Rule ID ('Rule_R1-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B2.L, N2), Equal(B2.o.k, {*, /}),<br>"+
	"        Equal(O1, B2.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [N2.k] and [N1.k].)<br>"+

	"<br>Example<br>"+
	"3/*4/* or /*+-3/*4/*<br>"+
	"drag '4' and drop on 'operator' between '3' and '4'<br>";


	wrongDropRules[1][4][1] = "Rule ID ('Rule_W1-4-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B2.L, N2), Equal(B2.o.k, {*, /}),<br>"+
	"        !Equal(O1, B2.o) )<br>"+
	"THEN Write(You must first simplify [N2.k][O1.k][N1.k] before continuing.)<br>"+

	"<br>Example<br>"+
	"3/*4/* or /*+-3/*4/*<br>"+
	"drag '4' and drop on 'operator' which is not between '3' and '4'<br>";



	rightDropRules[1][5] = "Rule ID ('Rule_R1-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B2.L, N2), !Equal(B2.o.k, {*, /}),<br>"+
	"        Equal(O1, B2.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [N2.k] and [N1.k].)<br>"+

	"<br>Example<br>"+
	"3+-4+- or +-3+-4+-<br>"+
	"drag '4' and drop on 'operator' between '3' and '4'<br>";



	wrongDropRules[1][5][1] = "Rule ID ('Rule_W1-5-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B2.L, N2), !Equal(B2.o.k, {*, /}),<br>"+
	"        !Equal(O1, B2.o) )<br>"+
	"THEN Write(You must first simplify [N2.k][O1.k][N1.k] before continuing.)<br>"+

	"<br>Example<br>"+
	"3+-4+- or +-3+-4+-<br>"+
	"drag '4' and drop on 'operator' which is not between '3' and '4'<br>";

rightDropRules[2][1] = "Rule ID ('Rule_R2-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.R, N3)<br>"+
	"        Or( And(Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, -)),<br>"+
	"            And(Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),<br>"+
	"            Equal(B1.o.k, *) ),<br>"+
	"        HasChild(B1.L.has(N4)),<br>"+
	"        Equal(GParent(N1), GParent(N2)) )<br>"+
	"THEN Write(Right! [B2.o.k][B1.L.n.k][B1.o.k][B1.R.n.k] is commutative.)<br>"+

	"<br>Example<br>"+
	"3*+4 or +3+4 or -3-4 or /*+-3*4<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";



	wrongDropRules[2][1][1] = "Rule ID ('Rule_W2-1-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.R, N3)<br>"+
	"        Or( And(Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, -)),<br>"+
	"            And(Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),<br>"+
	"            Equal(B1.o.k, *) ),<br>"+
	"        HasChild(B1.L.has(N4)),<br>"+
	"        !Equal(GParent(N1), GParent(N2)) )<br>"+
	"THEN Write(You can switch [B1.L.n.k] to [B1.R.n.k] in [B1.L.n.k][B1.o.k][B1.R.n.k] for commutation.)<br>"+

	"<br>Example<br>"+
	"3*+4 or +3+4 or -3-4 or /*+-3*4<br>"+
	"drag '3' and drop on 'number' which is not '4' OR drag '4' and drop on 'number' which is not '3'<br>";



	wrongDropRules[2][1][2] = "Rule ID ('Rule_W2-1-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),<br>"+
	"        Equal(B1.o.k, {/, -}), Equal(Parent(B1), {P, E}),<br>"+
	"        Equal(GParent(N1), GParent(N2)) )<br>"+
	"THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)<br>"+

	"<br>Example<br>"+
	"3/-4<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";



	wrongDropRules[2][1][3] = "Rule ID ('Rule_W2-1-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),<br>"+
	"        Equal(B1.o.k, /), Equal(GParent(B1), B2), Equal(B2.o.k, {*, /}),<br>"+
	"        Equal(GParent(N1), GParent(N2))<br>"+
	"THEN Write([B1.o.k] in [B1-subtree] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"/*3/4 or /*3/4+-<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";



	wrongDropRules[2][1][4] = "Rule ID ('Rule_W2-1-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -}), !Equal(B1.o.k, B2.o.k)),<br>"+
	"        Equal(GParent(N1), GParent(N2)) )<br>"+
	"THEN Write([B1.o.k] in [B1-subtree] must be [B2.o.k] or * for commutation.)<br>"+

	"<br>Example<br>"+
	"+3-4 or -3+4<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";



	wrongDropRules[2][1][5] = "Rule ID ('Rule_W2-1-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, /), Equal(GParent(B1), B2), !Equal(B2.L.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})) ),<br>"+
	"        Equal(GParent(N1), GParent(N2)) )<br>"+
	"THEN <br>"+
	"    IF !Equal(B2.L.B, B1)<br>"+
	"        Write([B1.o.k] in [B1-subtree] must be [B2.o.k] or * for commutation.)<br>"+
	"    ELSE IF Equal(B2.L.B, B1)<br>"+
	"        Write([B1.o.k] in [B1-subtree] must be [B3.o.k] or * for commutation.)<br>"+

	"<br>Example<br>"+
	"+-3/4 or +-3/4+-<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";



	wrongDropRules[2][1][6] = "Rule ID ('Rule_W2-1-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), HasChild(B1.R, N3),<br>"+
	"        Or( And(Equal(B2.o.k, {+, -}), HasAncestor(N1, B2), Equal(B1.R, N4), Equal(B1.o.k, {*, /}), Equal(B2.o.k, {+, -}),<br>"+
	"            And(HasChild(B2.R, N4), Include(B1.L, B2), Equal(B2.o.k, {*, /}), Equal(B1.o.k, {+, -})) ),<br>"+
	"        Equal(N1, B1.R.n), Equal(N2, B2.R.n)) )<br>"+
	"THEN <br>"+
	"    IF Equal(B1.o.k, {*, /})<br>"+
	"        Write([B1.o.k] before [B1.R.n.k] must be [B2.o.k] for commutation.)<br>"+
	"        Write([B2.o.k] in [B1.R.n.k][B2.o.k][B2.R.n.k] must be * for commutation.)<br>"+
	"    ELSE IF Equal(B1.o.k, {+, -})<br>"+
	"        Write([B2.o.k] before [B2.o.k][B2.R.n.k] must be [B1.o.k] for commutation.)<br>"+
	"        Write([B1.o.k] in [B2.R.n.k][B1.o.k][B1.R.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"/*3+-4<br>"+
	"drag '3' and drop on '4' OR drag '4' and drop on '3'<br>";

	rightDropRules[2][2] = "Rule ID ('Rule_R2-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Euqal(GParent(B1), B2)<br>"+
	"        Or( And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, -)), <br>"+
	"            And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {P, E}), <br>"+
	"            !Equal(B2.o.k, *) ),<br>"+
	"        HasChild(B2.L, N3),<br>"+
	"        Equal(N2, B2.L.n) )<br>"+
	"THEN Write(Right! [B4.o.k][B2.L.n.k][B2.o.k][B1.L.n.k] is commutative.)<br>"+

	"<br>Example<br>"+
	"3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][1] = "Rule ID ('Rule_W2-2-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Euqal(GParent(B1), B2)<br>"+
	"        Or( And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, -)), <br>"+
	"            And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {P, E}), <br>"+
	"            !Equal(B2.o.k, *) ),<br>"+
	"        HasChild(B2.L, N3),<br>"+
	"        !Equal(N2, B2.L.n) )<br>"+
	"THEN Write(You can switch [B2.L.n.k] to [N1.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] for commutation.)<br>"+

	"<br>Example<br>"+
	"3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-<br>"+
	"drag '3' and drop on 'number' which is not '4'<br>";



	wrongDropRules[2][2][2] = "Rule ID ('Rule_W2-2-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        HasChild(B1.R, B2), Equal(Parent(B1), {P, E}),<br>"+
	"        Or( And(Equal(B1.o.k, /), Equal(B2.o.k, {*, /})),<br>"+
	"            And(Equal(B1.o.k, -), Equal(B2.o.k, {+, -})) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN <br>"+
	"    IF Equal(B1.o.k, /)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF Equal(B1.o.k, -)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be + or * for commutation.)<br>"+

	"<br>Example<br>"+
	"3/4/*  or 3-4+-<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][3] = "Rule ID ('Rule_W2-2-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {P, E}),<br>"+
	"        Equal(B1.o.k, /), Equal(B2.o.k, {+, -}),<br>"+
	"        Equal(N2, B1.L.n) )<br>"+
	"THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)<br>"+

	"<br>Example<br>"+
	"3/4+-<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][4] = "Rule ID ('Rule_W2-2-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        HasChild(B1.R, B2), Equal(Parent(B1), {P, E}),<br>"+
	"        Or( And(HasChild(B2.L, N3), Equal(B1.o.k, {+, -}), Equal(B2.o.k, {*, /})),<br>"+
	"            And(HasChild(B2.L, B3), Equal(B1.o.k, {+, -}), Equal(B3.o.k, {*, /})) ),<br>"+
	"        Or( Equal(N2, B2.L.n), And(HasChild(B2.L, B3), Equal(N2, B3.L.n)) ) )<br>"+
	"THEN <br>"+
	"    IF And(Equal(B1.o.k, +), Equal(N2, B2.L.n))<br>"+
	"        Write([B2.o.k] after [B2.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, +), Equal(N2, B3.L.n))<br>"+
	"        Write([B3.o.k] after [B3.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(N2, B2.L.n))<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(N2, B3.L.n))<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"/*3+-4/*+-<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][5] = "Rule ID ('Rule_W2-2-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(B2.o.key, {+, -}), HasAncestor(N1, B2), Equal(B1.o.k, {*, /}), HasChild(B2.R, B3)<br>"+
	"        Or( Equal(N2, B3.L.n), And(HasChild(B3.L, B4), Equal(N2, B4.L.n)) ) )<br>"+
	"THEN Write()<br>"+
	"    IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {+, -}))<br>"+
	"        Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] for commutation.)<br>"+
	"        Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B3.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}))<br>"+
	"        Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] AND [B3.o.k] after [B3.L.n.k] must be + or - for commutation.)<br>"+
	"        Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B3.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}))<br>"+
	"        Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] AND [B4.o.k] after [B4.L.n.k] must be + or - for commutation.)<br>"+
	"        Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B4.L.n.k] must be * for commutation.)<br>"+
	"<br>Example<br>"+
	"/*3+-4/*+-<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][6] = "Rule ID ('Rule_W2-2-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B1.R, B3),<br>"+
	"        Or( And(Equal(B2.o.k, -), Equal(B1.o.k, +)),<br>"+
	"            And(Equal(B2.o.k, +), Equal(B1.o.k, -)),<br>"+
	"            And(Equal(B2.o.k, +), Equal(B1.o.k, +)),<br>"+
	"            And(Equal(B2.o.k, -), Equal(B1.o.k, -)),<br>"+
	"            And(Equal(B2.o.k, {*, /}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})) ),<br>"+
	"        Or( Equal(N2, B3.L.n), And(HasChild(B3.L, B4), Equal(N2, B4.L.n)) ) )<br>"+
	"THEN <br>"+
	"    IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {+, -}))<br>"+
	"        Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be [B2.o.k] or * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}), !Equal(B1.o.k, B2.o.k))<br>"+
	"        Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] AND [B3.o.k] after [B3.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}), !Equal(B1.o.k, B2.o.k))<br>"+
	"        Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] AND [B4.o.k] after [B4.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B4.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}), Equal(B1.o.k, B2.o.k))<br>"+
	"        Write([B3.o.k] after [B3.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}), Equal(B1.o.k, B2.o.k))<br>"+
	"        Write([B4.o.k] after [B4.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B4.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, /))<br>"+
	"        Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"-3+-4+- or +-3+-4/* or /*3/4/*<br>"+
	"drag '3' and drop on '4'<br>";



	wrongDropRules[2][2][7] = "Rule ID ('Rule_W2-2-7')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), HasChild(B1.R, B3),<br>"+
	"        Or( And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})),<br>"+
	"            And(Equal(B2.L.B, B1), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})) ),<br>"+
	"        Equal(N2, B3.L.n) )<br>"+
	"THEN Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"+-3/4/*<br>"+
	"drag '3' and drop on '4'<br>";

	rightDropRules[2][3] = "Rule ID ('Rule_R2-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(HasChild(B1.R, B2), HasChild(B2.L, N3),<br>"+
	"        Or( And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B3) , Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, -), Equal(GParent(B1), B3) , Equal(B3.o.k, -)),<br>"+
	"            And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),<br>"+
	"            Equal(B1.o.k, *) ),<br>"+
	"        Equal(N2, B2.L.n) )<br>"+
	"THEN Write(Right! [B4.o.k][B1.L.n.k][B1.o.k][B2.L.n.k] is commutative.)<br>"+

	"<br>Example<br>"+
	"3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-<br>"+
	"drag '4' and drop on '3'<br>";

	wrongDropRules[2][3][1] = "Rule ID ('Rule_W2-3-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(HasChild(B1.R, B2), HasChild(B2.L, N3),<br>"+
	"        Or( And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B3) , Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, -), Equal(GParent(B1), B3) , Equal(B3.o.k, -)),<br>"+
	"            And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),<br>"+
	"            Equal(B1.o.k, *) ),<br>"+
	"        !Equal(N2, B2.L.n) )<br>"+
	"THEN Write(You can switch [B1.L.n.k] to [B2.L.n.k] in [B1.L.n.k][B1.o.k][N2.k] for commutation.)<br>"+

	"<br>Example<br>"+
	"3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-<br>"+
	"drag '4' and drop on 'number' which is not '3'<br>";



	wrongDropRules[2][3][2] = "Rule ID ('Rule_W2-3-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), Equal(Parent(B2), {P, E}),<br>"+
	"        Or( And(Equal(B2.o.k, /), Equal(B1.o.k, {*, /})),<br>"+
	"            And(Equal(B2.o.k, -), Equal(B1.o.k, {+, -})) ),<br>"+
	"        Equal(N2, B2.L.n) )<br>"+
	"THEN <br>"+
	"    IF (Equal(B2.o.k, /))<br>"+
	"        Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF (Equal(B2.o.k, -))<br>"+
	"        Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be + or * for commutation.)<br>"+

	"<br>Example<br>"+
	"3/4/*  or 3-4+-<br>"+
	"drag '4' and drop on '3'<br>";



	wrongDropRules[2][3][3] = "Rule ID ('Rule_W2-3-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.R.n, N1),<br>"+
	"        Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {P, E}),<br>"+
	"        Equal(B1.o.k, /), Equal(B2.o.k, {+, -})<br>"+
	"        Equal(N2, B1.L.n) )<br>"+
	"THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)<br>"+

	"<br>Example<br>"+
	"3/4+-<br>"+
	"drag '4' and drop on '3'<br>";



	wrongDropRules[2][3][4] = "Rule ID ('Rule_W2-3-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2)<br>"+
	"        Or( And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(Parent(B2), {P, E})),<br>"+
	"            And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(Parent(B3), {P, E})),<br>"+
	"            And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})) ),<br>"+
	"        Or( Equal(N2, B2.L.n), And(HasChild(B2.L, B1), Equal(N2, B3.L.n)) ) )<br>"+
	"THEN <br>"+
	"    IF Equal(N2, B2.L.n))<br>"+
	"        IF AND(Equal(B2.o.k, +), Equal(Parent(B2), {P, E}))<br>"+
	"            Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF AND(Equal(B2.o.k, -), Equal(Parent(B2), {P, E}))<br>"+
	"            Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF AND(Equal(GParent(B2), B3), !Equal(B2.o.k, B3.o.k))<br>"+
	"            Write([B3.o.k] before [B2.L.n.k] must be [B2.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B2.o.k] in [B3.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF AND(Equal(GParent(B2), B3), Equal(B2.o.k, B3.o.k))<br>"+
	"            Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B2.o.k] in [B3.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+

	"    ELSE IF Equal(N2, B3.L.n)<br>"+
	"        IF Equal(B3.o.k, +)<br>"+
	"            Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B3.o.k] in [B3.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF Equal(B3.o.k, -)<br>"+
	"            Write([B3.o.k] in [B3.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF And(Equal(GParent(B3), B4), !Equal(B3.o.k, B4.o.k))<br>"+
	"            Write([B4.o.k] before [B3.L.n.k] must be [B3.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B3.o.k] in [B4.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"        ELSE IF And(Equal(GParent(B3), B4), Equal(B3.o.k, B4.o.k))<br>"+
	"            Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"            Write([B3.o.k] in [B4.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"3+-4/* or +-3+-4/*<br>"+
	"drag '4' and drop on '3'<br>";



	wrongDropRules[2][3][5] = "Rule ID ('Rule_W2-3-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), Equal(B3.R, N3), Include(B2.L, B3)<br>"+
	"        Equal(B3.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {+, -})<br>"+
	"        Equal(N2, B3.R.n) )<br>"+
	"THEN Write([B3.o.k] before [B3.R.n.k] must be [B2.o.k] for commutation.)<br>"+
	"     Write([B2.o.k] in [B3.R.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"/*3+-4+-<br>"+
	"drag '4' and drop on '3'<br>";



	wrongDropRules[2][3][6] = "Rule ID ('Rule_W2-3-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2),<br>"+
	"        Or( And(Equal(B2.R.B, B1), Equal(B3.R, N3), Include(B2.L, B3), Equal(B3.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /})),<br>"+
	"            And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B4.R, N3), Include(B3.L, B4), Equal(B4.o.k, {*, /}), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /})) ),<br>"+
	"        Or( Equal(N2, B3.R.n), And(HasChild(B2.L, B1), Equal(N2, B4.R.n)) ) )<br>"+
	"THEN<br>"+
	"    IF Equal(B2.R.B, B1)<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be [B2.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B2.o.k] in [B3.R.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+
	"    ELSE IF Equal(B2.L.B, B1)<br>"+
	"        Write([B4.o.k] before [B4.R.n.k] must be [B3.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)<br>"+
	"        Write([B3.o.k] in [B4.R.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"/*3+-4/*<br>"+
	"drag '4' and drop on '3'<br>";



	wrongDropRules[2][3][7] = "Rule ID ('Rule_W2-3-7')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,N2),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1),<br>"+
	"        Equal(GParent(B1), B2), Equal(GParent(B2), B3),<br>"+
	"        Or( And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(B1.o.k, {+, -})),<br>"+
	"            And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(B1.o.k, {+, -})),<br>"+
	"            And(Equal(B3.R.B, B2), Equal(B3.o.k, {+, -}), Equal(B2.o.k, /), Equal(B1.o.k, {*, /})),<br>"+
	"            And(Equal(B3.L.B, B2), Equal(GParent(B3), B4) ,Equal(B4.o.k, {+, -}), Equal(B2.o.k, /), Equal(B1.o.k, {*, /})) ),<br>"+
	"        Equal(N2, B2,L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(B2.o.k, {+, -})<br>"+
	"        Write([B3.o.k] before [B2.L.n.k] must be [B2.o.k] for commutation.)<br>"+
	"        Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be [B3.o.k] or * for commutation.)<br>"+
	"    ELSE IF Equal(B2.o.k, /)<br>"+
	"        Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)<br>"+

	"<br>Example<br>"+
	"-3+4+- or +3-4+- or /*3/4/* or +-3/4/*<br>"+
	"drag '4' and drop on '3'<br>";

	rightDropRules[3][1] = "Rule ID ('Rule_R3-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN Write(Right! [P1-subtree][B1.o.k][B1.R.n.k] is associative.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5<br>"+
	"drag '(' and drop on '4'<br>";



	wrongDropRules[3][1][1] = "Rule ID ('Rule_W3-1-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        !Equal(N1, P1.B.R.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B1.R.n.k] for association.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5<br>"+
	"drag '(' and drop on 'number' which is not '4'<br>";



	wrongDropRules[3][1][2] = "Rule ID ('Rule_W3-1-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), HasChild(B2.R, N4),<br>"+
	"        Equal(B1.o.k, {*, /}),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN <br>"+
	"    IF Equal(P1.B.o.k, +)<br>"+
	"        ex) /*(3+4)+-5<br>"+
	"        Write([B1.o.k] before [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *) ,Equal(P1.B.o.k, *))<br>"+
	"        ex) *(3*4)+-5<br>"+
	"        Write([B2.o.k] between [P1-subtree] and [B2.R.n.k] must be * for association.)<br>"+
	"    ELSE<br>"+
	"        ex) /*(3/-4)+-5 or /(3*4)+-5<br>"+
	"        Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"<br>Example<br>"+
	"/*(3/*+-4)+-5<br>"+
	"drag '(' and drop on '4'<br>";



	wrongDropRules[3][1][3] = "Rule ID ('Rule_W3-1-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, -)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN<br>"+
	"    IF AND(Equal(Parent(B1), {E, P}), Equal(P1.B.o.k, *))<br>"+
	"        ex) (3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(Parent(B1), {E, P}), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/-4)-+5<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"        ex) -(3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([B2.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, {/, -}))<br>"+
	"        ex) -(3/-4)-+5<br>"+
	"        Write()<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"        ex) +(3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, {/, -}))<br>"+
	"        ex) +(3/-4)-+5<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"<br>Example<br>"+
	"-(3/*+-4)+-5 or +(3/*-4)-+5 or (3/*-4)-+5<br>"+
	"drag '(' and drop on '4'<br>";



	wrongDropRules[3][1][4] = "Rule ID ('Rule_W3-1-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(Parent(B1), {P, E})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.R.n) )    <br>"+
	"THEN<br>"+
	"    IF AND(Or(Equal(Parent(B1), {E, P}), And(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P}))))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) (3*4)/5 or (3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +))<br>"+
	"            ex) (3+4)/5 or (3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) (3/-4)/5 or (3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +))<br>"+
	"            ex) (3+4)*5 or (3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) (3/-4)*5 or (3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)/5 or +-(3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, +))<br>"+
	"            ex) +(3+4)/5 or +(3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, -))<br>"+
	"            ex) -(3+4)/5 or -(3+4)/5+-<br>"+
	"            Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, +))<br>"+
	"            ex) +(3/-4)/5 or +(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, -))<br>"+
	"            ex) -(3/-4)/5 or -(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, +))<br>"+
	"            ex) +(3+4)*5 or +(3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, -))<br>"+
	"            ex) -(3+4)*5 or -(3+4)*5+-<br>"+
	"            Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +-(3/-4)*5 or +-(3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)/5 or +-(3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, +))<br>"+
	"            ex) +(3+4)/5 or +(3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, -))<br>"+
	"            ex) -(3+4)/5 or -(3+4)/5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, +))<br>"+
	"            ex) +(3/-4)/5 or +(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, -))<br>"+
	"            ex) -(3/-4)/5 or -(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, +))<br>"+
	"            ex) +(3+4)*5 or +(3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, -))<br>"+
	"            ex) -(3+4)*5 or -(3+4)*5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +-(3/-4)*5 or +-(3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)/5 or +-(3/+-4)*5 or (3/*+-4)/5 or (3/+-4)*5 or<br>"+
	"+-(3/*+-4)/5+- or +-(3/+-4)*5+- or (3/*+-4)/5+- or (3/+-4)*5+-<br>"+
	"drag '(' and drop on '4'<br>";


	rightDropRules[3][2] = "Rule ID ('Rule_R3-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN Write(Right! [P1-subtree][B1.o.k][B2.L.n.k] is associative.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-<br>"+
	"drag '(' and drop on '4'<br>";



	wrongDropRules[3][2][1] = "Rule ID ('Rule_W3-2-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *)) ),<br>"+
	"        !Equal(N1, P1.B.R.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B2.L.n.k] for association.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-<br>"+
	"drag '(' and drop on 'number' which is not '4'<br>";



	wrongDropRules[3][2][2] = "Rule ID ('Rule_W3-2-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.R, B2), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), Include(B2.L, P1), HasChild(B2.R, B3),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), HasChild(B3.L, N4)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), HasChild(B3.L, B4)), HasChild(B4.L, N4)) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN<br>"+
	"    IF AND(Equal(B3.L, N4), Equal(B3.o.k, {+, -}))<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5+-<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"    ELSE IF AND(Equal(B3.L, N4), Equal(B3.o.k, {*, /}))<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5/*6<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [B3.o.k] after [B3.L.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5/*6<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5/*6<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+

	"    ELSE HasChild(B3.L, B4)<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5/*6+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [B4.o.k] after [B4.L.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5/*6+-<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5/*6+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*(3/*+-4)+-5/*+-<br>"+
	" drag '(' and drop on '4'<br>";



	wrongDropRules[3][2][3] = "Rule ID ('Rule_W3-2-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, -)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF Equal(P1.B.o.k, *)<br>"+
	"            ex)    (3*4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) (3/-4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"    ELSE IF  Equal(GParent(B1), B3)<br>"+
	"        IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, +))<br>"+
	"            ex)    -(3+4)+-5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, *))<br>"+
	"            ex)    -(3*4)+-5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex)    -(3/-4)+-5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, *))<br>"+
	"            ex)    +(3*4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association)<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex)    +(3/-4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association)<br>"+

	"<br>Example<br>"+
	" -(3/*+-4)+-5+- or +(3/*-4)+-5+- or (3/*-4)+-5+-<br>"+
	" drag '(' and drop on '4'<br>";



	wrongDropRules[3][2][4] = "Rule ID ('Rule_W3-2-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(GParent(B1), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) (3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) (3*4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) (3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"    ELSE IF Equal(GParent(B1), B3)<br>"+
	"        IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, +))<br>"+
	"            ex) +(3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +(3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, +))<br>"+
	"            ex) -(3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B3.o.k] before [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B3.o.k] before [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) -(3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)+-5/* or (3/*+-4)+-5/*<br>"+
	"drag '(' and drop on '4'<br>";



	wrongDropRules[3][2][5] = "Rule ID ('Rule_W3-2-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.R, P1), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.L, P1), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.L.B, B1), Equal(Parent(B3), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.R.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"        ex) (3*4)/5/* or +-(3*4)/5/*<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/+-4)/5/* or +-(3/+-4)/5/*<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/+-4)*5/* or +-(3/+-4)*5/*<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)/5/* or +-(3/+-4)*5/* or (3/*+-4)/5/* or (3/+-4)*5/*<br>"+
	"drag '(' and drop on '4'<br>";

	rightDropRules[3][3] = "Rule ID ('Rule_R3-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, B1.L.n) )<br>"+
	"THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][3][1] = "Rule ID ('Rule_W3-3-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        !Equal(N1, B1.L.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag '(' and drop on 'number' which is not '2'<br>";



	wrongDropRules[3][3][2] = "Rule ID ('Rule_W3-3-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, B1.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) 2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) 2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) 2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) 2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B1), B2)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) +2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) -2+(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) +2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) -2+(3/4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) +2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) -2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][3][3] = "Rule ID ('Rule_W3-3-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),<br>"+
	"        Equal(N1, B2.R.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][3][4] = "Rule ID ('Rule_W3-3-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, B1.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )<br>"+
	"        IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2/(3+-4) or 2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2/(3*4) or 2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2/(3/4) or 2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2*(3+-4) or 2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2*(3/4) or 2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or<br>"+
	"2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-<br>"+
	"drag '(' and drop on '2'<br>";



	rightDropRules[3][4] = "Rule ID ('Rule_R3-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN<br>"+
	"    Write(Right! [B2.L.n.k][B2.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][4][1] = "Rule ID ('Rule_W3-4-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),<br>"+
	"        !Equal(N1, B2.L.n) )<br>"+
	"THEN<br>"+
	"    Write(You can drag [OP1.k] over [B2.L.n.k] in [B2.L.n.k][B2.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-<br>"+
	"drag '(' and drop 'number' which is not '2'<br>";



	wrongDropRules[3][4][2] = "Rule ID ('Rule_W3-4-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(Parent(B3), {E, P})) ),<br>"+
	"        Equal(Or( Equal(N1, B2.L.n), And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(N1, B3.L.n))))<br>"+
	"THEN<br>"+
	"    IF And(Equal(B2.R.B, B1), Equal(Parent(B2), {E, P}))<br>"+
	"        IF(And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) 2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B2), B4))<br>"+
	"        IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) +-2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) -2+(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +-2-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B2.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(Parent(B3), {E, P}))<br>"+
	"        IF(And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) 2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B3), B4))<br>"+
	"        IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) +-2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) -2+(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +-2-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B3.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*+-4)/* or +-2+-(3/*+-4)/*<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][4][3] = "Rule ID ('Rule_W3-4-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4)<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, -)) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B2), {E, P})<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2+(3*4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2+(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2-(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B2), B3)<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) +2+(3*4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) -2+(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2+(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2+(3/4)+-<br>"+
	"            Write([B3.o.k] before [B2.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B2.L.n.k] must be + AND [B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4)+- or +-2+-(3/*4)+- or 2-(3+-4)+- or +-2-(3+-4)+- or -2+(3+-4)+-<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][4][4] = "Rule ID ('Rule_W3-4-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B4.R, N4), Include(B2.L, B4)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B4.R, N4), Include(B3.L, B4)) ),<br>"+
	"        Equal(N1, B4.R.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(B2.R.B, B1)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) /*2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, /))<br>"+
	"            ex) /*2+-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(B2.L.B, B1)<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) /*2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, /))<br>"+
	"            ex) /*2+-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)/*<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][4][5] = "Rule ID ('Rule_W3-4-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(B3.R, N4), Include(B2.L, B3)<br>"+
	"        Equal(N1, B3.R.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B2.o.k, +), Equal(P.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + AND [B2.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)+-<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, +), Equal(P.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)+-<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-2)+-<br>"+
	"drag '(' and drop on '2'<br>";



	wrongDropRules[3][4][6] = "Rule ID ('Rule_W3-4-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(OP1,N1),<br>"+
	"        Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or(Equal(B1.o.k, /), And(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}))<br>"+
	"        Equal(N1, B1.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2/(3*4) or /*2/(3*4)+-<br>"+
	"        Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2/(3/+-4) or /*2/(3/+-4)+-<br>"+
	"        Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2*(3/+-4) or /*2*(3/+-4)+-<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2/(3/*+-4) or /*2/(3/*+-4)+- or /*2*(3/+-4) or /*2*(3/+-4)+-<br>"+
	"drag '(' and drop on '2'<br>";

	rightDropRules[3][5] = "Rule ID ('Rule_R3-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][1] = "Rule ID ('Rule_W3-5-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        !Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on 'number' which is not '3'<br>";



	wrongDropRules[3][5][2] = "Rule ID ('Rule_W3-5-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) 2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) 2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) 2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) 2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B1), B2)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) +2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) -2+(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) +2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) -2+(3/4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) +2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) -2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][3] = "Rule ID ('Rule_W3-5-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][4] = "Rule ID ('Rule_W3-5-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )<br>"+
	"        IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2/(3+-4) or 2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2/(3*4) or 2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2/(3/4) or 2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2*(3+-4) or 2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2*(3/4) or 2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or<br>"+
	"2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-<br>"+
	"drag ')' and drop on '3'<br>";

	rightDropRules[3][5] = "Rule ID ('Rule_R3-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][1] = "Rule ID ('Rule_W3-5-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        !Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on 'number' which is not '3'<br>";



	wrongDropRules[3][5][2] = "Rule ID ('Rule_W3-5-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) 2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) 2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) 2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) 2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B1), B2)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) +2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) -2+(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) +2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) -2+(3/4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) +2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) -2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][3] = "Rule ID ('Rule_W3-5-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][4] = "Rule ID ('Rule_W3-5-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )<br>"+
	"        IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2/(3+-4) or 2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2/(3*4) or 2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2/(3/4) or 2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2*(3+-4) or 2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2*(3/4) or 2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or<br>"+
	"2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-<br>"+
	"drag ')' and drop on '3'<br>";

	rightDropRules[3][5] = "Rule ID ('Rule_R3-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][1] = "Rule ID ('Rule_W3-5-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),<br>"+
	"        !Equal(N1, P1.B.L.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)<br>"+
	"drag ')' and drop on 'number' which is not '3'<br>";



	wrongDropRules[3][5][2] = "Rule ID ('Rule_W3-5-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) 2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) 2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) 2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) 2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B1), B2)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) +2+(3*4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))<br>"+
	"            ex) -2+(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) +2+(3/4)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))<br>"+
	"            ex) -2+(3/4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) +2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))<br>"+
	"            ex) -2-(3/4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)<br>"+
	"            Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)<br>"+
	"drag ')' and drop on '3'<br>";

	wrongDropRules[3][5][3] = "Rule ID ('Rule_W3-5-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)<br>"+
	"        Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][5][4] = "Rule ID ('Rule_W3-5-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )<br>"+
	"        IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2/(3+-4) or 2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2/(3*4) or 2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2/(3/4) or 2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2*(3+-4) or 2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2*(3/4) or 2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2/(3+-4) or +2/(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2/(3+-4) or -2/(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2/(3*4) or +-2/(3*4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2/(3/4) or +2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2/(3/4) or -2/(3/4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2*(3+-4) or +2*(3+-4)+-<br>"+
	"            Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2*(3+-4) or -2*(3+-4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))<br>"+
	"            ex) +-2*(3/4) or +-2*(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or<br>"+
	"2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-<br>"+
	"drag ')' and drop on '3'<br>";

	rightDropRules[3][6] = "Rule ID ('Rule_R3-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    Write(Right! [B2.L.n.k][B2.o.k][P1-subtree] is associative.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-<br>"+
	"drag ')' and drop on '3'<br>";

	wrongDropRules[3][6][1] = "Rule ID ('Rule_W3-6-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),<br>"+
	"        !Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    Write(You can drag [OP1.k] over [B2.L.n.k] in [B2.L.n.k][B2.o.k][P1-subtree] for association.)<br>"+

	"<br>Example<br>"+
	"2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-<br>"+
	"drag ')' and drop on 'number' which is not '3'<br>";

	wrongDropRules[3][6][2] = "Rule ID ('Rule_W3-6-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(Parent(B3), {E, P})) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B2.R.B, B1), Equal(Parent(B2), {E, P}))<br>"+
	"        IF(And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) 2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B2), B4))<br>"+
	"        IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) +-2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) -2+(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +-2-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B2.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(Parent(B3), {E, P}))<br>"+
	"        IF(And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) 2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) 2-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) 2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B3), B4))<br>"+
	"        IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))<br>"+
	"            ex) +-2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +2+(3/4)/*<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))<br>"+
	"            ex) -2+(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))<br>"+
	"            ex) +-2-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2+(3+-4)/*<br>"+
	"            Write([B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B3.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) +2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))<br>"+
	"            ex) -2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*+-4)/* or +-2+-(3/*+-4)/*<br>"+
	"drag ')' and drop on '3'<br>";

	wrongDropRules[3][6][3] = "Rule ID ('Rule_W3-6-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4)<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(Parent(B2), {E, P})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, -)) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B2), {E, P})<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2+(3*4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2+(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"            ex) 2-(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) 2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) 2-(3+-4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF Equal(GParent(B2), B3)<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) +2+(3*4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"            ex) -2+(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2+(3/4)+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2+(3/4)+-<br>"+
	"            Write([B3.o.k] before [B2.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-2-(3*4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) +2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, /))<br>"+
	"            ex) -2-(3/4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) +2-(3+-4)+-<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) -2-(3+-4)+-<br>"+
	"            Write([B3.o.k] before [B2.L.n.k] must be + AND [B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)<br>"+
	"            Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"2+-(3/*4)+- or +-2+-(3/*4)+- or 2-(3+-4)+- or +-2-(3+-4)+- or -2+(3+-4)+-<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][6][4] = "Rule ID ('Rule_W3-6-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B4.R, N4), Include(B2.L, B4)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B4.R, N4), Include(B3.L, B4)) ),<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(B2.R.B, B1)<br>"+
	"        IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2-(3+-4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) /*2+-(3*4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, /))<br>"+
	"            ex) /*2+-(3/4)/*<br>"+
	"            Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(B2.L.B, B1)<br>"+
	"        IF And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2+(3+-4)/*<br>"+
	"            Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -}))<br>"+
	"            ex) /*2-(3+-4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) /*2+-(3*4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, /))<br>"+
	"            ex) /*2+-(3/4)/*<br>"+
	"            Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-4)/*<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][6][5] = "Rule ID ('Rule_W3-6-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Equal(B1.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(B3.R, N4), Include(B2.L, B3)<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B2.o.k, +), Equal(P.B.o.k, {+, -}))<br>"+
	"        ex)/*2+(3+-4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, {+, -}))<br>"+
	"        ex)/*2-(3+-4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + AND [B2.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF Equal(P.B.o.k, *)<br>"+
	"        ex)/*2+-(3*4)+-<br>"+
	"        Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, +), Equal(P.B.o.k, /))<br>"+
	"        ex)/*2+(3/4)+-<br>"+
	"        Write([B3.o.k] before [B3.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, /))<br>"+
	"        ex)/*2-(3/4)+-<br>"+
	"        Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2+-(3/*+-2)+-<br>"+
	"drag ')' and drop on '3'<br>";



	wrongDropRules[3][6][6] = "Rule ID ('Rule_W3-6-6')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),<br>"+
	"        Or(Equal(B1.o.k, /), And(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}))<br>"+
	"        Equal(N1, P1.B.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2/(3*4) or /*2/(3*4)+-<br>"+
	"        Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2/(3/+-4) or /*2/(3/+-4)+-<br>"+
	"        Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))<br>"+
	"        ex) /*2*(3/+-4) or /*2*(3/+-4)+-<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*2/(3/*+-4) or /*2/(3/*+-4)+- or /*2*(3/+-4) or /*2*(3/+-4)+-<br>"+
	"drag ')' and drop on '3'<br>";



	rightDropRules[3][7] = "Rule ID ('Rule_R3-7')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        Equal(N1, B1.R.n) )<br>"+
	"THEN Write(Right! [P1-subtree][B1.o.k][B1.R.n.k] is associative.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5<br>"+
	"drag ')' and drop on '5' <br>";



	wrongDropRules[3][7][1] = "Rule ID ('Rule_W3-7-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        !Equal(N1, B1.R.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B1.R.n.k] for association.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5<br>"+
	"drag ')' and drop on 'number' which is not '5'<br>";



	wrongDropRules[3][7][2] = "Rule ID ('Rule_W3-7-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), HasChild(B2.R, N4),<br>"+
	"        Equal(B1.o.k, {*, /}),<br>"+
	"        Equal(N1, B2.R.n) )<br>"+
	"THEN <br>"+
	"    IF Equal(P1.B.o.k, +)<br>"+
	"        ex) /*(3+4)+-5<br>"+
	"        Write([B1.o.k] before [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *) ,Equal(P1.B.o.k, *))<br>"+
	"        ex) *(3*4)+-5<br>"+
	"        Write([B2.o.k] between [P1-subtree] and [B2.R.n.k] must be * for association.)<br>"+
	"    ELSE<br>"+
	"        ex) /*(3/-4)+-5 or /(3*4)+-5<br>"+
	"        Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"<br>Example<br>"+
	"/*(3/*+-4)+-5<br>"+
	"drag ')' and drop on '5' <br>";



	wrongDropRules[3][7][3] = "Rule ID ('Rule_W3-7-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, -)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}) ),<br>"+
	"        Equal(N1, B1.R.n) )<br>"+
	"THEN<br>"+
	"    IF AND(Equal(Parent(B1), {E, P}), Equal(P1.B.o.k, *))<br>"+
	"        ex) (3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(Parent(B1), {E, P}), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/-4)-+5<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, *))<br>"+
	"        ex) -(3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([B2.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, {/, -}))<br>"+
	"        ex) -(3/-4)-+5<br>"+
	"        Write()<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, *))<br>"+
	"        ex) +(3*4)-+5<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, {/, -}))<br>"+
	"        ex) +(3/-4)-+5<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"<br>Example<br>"+
	"-(3/*+-4)+-5 or +(3/*-4)-+5 or (3/*-4)-+5<br>"+
	"drag ')' and drop on '5' <br>";



	wrongDropRules[3][7][4] = "Rule ID ('Rule_W3-7-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),<br>"+
	"        Or( And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.R.B, B1), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3), Equal(B2.o.k, {+, -})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(Parent(B1), {P, E})),<br>"+
	"            And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P})) ),<br>"+
	"        Equal(N1, B1.R.n) )    <br>"+
	"THEN<br>"+
	"    IF AND(Or(Equal(Parent(B1), {E, P}), And(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P}))))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) (3*4)/5 or (3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +))<br>"+
	"            ex) (3+4)/5 or (3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) (3/-4)/5 or (3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +))<br>"+
	"            ex) (3+4)*5 or (3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) (3/-4)*5 or (3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.R.B, B1))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)/5 or +-(3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, +))<br>"+
	"            ex) +(3+4)/5 or +(3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, -))<br>"+
	"            ex) -(3+4)/5 or -(3+4)/5+-<br>"+
	"            Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, +))<br>"+
	"            ex) +(3/-4)/5 or +(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, -))<br>"+
	"            ex) -(3/-4)/5 or -(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, +))<br>"+
	"            ex) +(3+4)*5 or +(3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, -))<br>"+
	"            ex) -(3+4)*5 or -(3+4)*5+-<br>"+
	"            Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +-(3/-4)*5 or +-(3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"    ELSE IF AND(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3))<br>"+
	"        IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)/5 or +-(3*4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, +))<br>"+
	"            ex) +(3+4)/5 or +(3+4)/5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, -))<br>"+
	"            ex) -(3+4)/5 or -(3+4)/5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, +))<br>"+
	"            ex) +(3/-4)/5 or +(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, -))<br>"+
	"            ex) -(3/-4)/5 or -(3/-4)/5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, +))<br>"+
	"            ex) +(3+4)*5 or +(3+4)*5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, -))<br>"+
	"            ex) -(3+4)*5 or -(3+4)*5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+
	"        ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +-(3/-4)*5 or +-(3/-4)*5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)/5 or +-(3/+-4)*5 or (3/*+-4)/5 or (3/+-4)*5 or<br>"+
	"+-(3/*+-4)/5+- or +-(3/+-4)*5+- or (3/*+-4)/5+- or (3/+-4)*5+-<br>"+
	"drag ')' and drop on '5' <br>";



	rightDropRules[3][8] = "Rule ID ('Rule_R3-8')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN Write(Right! [P1-subtree][B1.o.k][B2.L.n.k] is associative.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-<br>"+
	"drag ')' and drop on '5'<br>";



	wrongDropRules[3][8][1] = "Rule ID ('Rule_W3-8-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(P1.B.o.k, *), Equal(B1.o.k, *)) ),<br>"+
	"        !Equal(N1, B2.L.n) )<br>"+
	"THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B2.L.n.k] for association.)<br>"+

	"<br>Example<br>"+
	"(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-<br>"+
	"drag ')' and drop on 'number' which is not '5'<br>";



	wrongDropRules[3][8][2] = "Rule ID ('Rule_W3-8-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.R, B2), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), Include(B2.L, P1), HasChild(B2.R, B3),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), HasChild(B3.L, N4)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), HasChild(B3.L, B4)), HasChild(B4.L, N4)) ),<br>"+
	"        Or( Equal(N1, B3.L.n), And(HasChild(B3.L, B4), Equal(N1, B4.L.n)) ) )<br>"+
	"THEN<br>"+
	"    IF AND(Equal(B3.L, N4), Equal(B3.o.k, {+, -}))<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5+-<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"    ELSE IF AND(Equal(B3.L, N4), Equal(B3.o.k, {*, /}))<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5/*6<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [B3.o.k] after [B3.L.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5/*6<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5/*6<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)<br>"+

	"    ELSE HasChild(B3.L, B4)<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) /*(3+4)+-5/*6+-<br>"+
	"            Write([B1.o.k] before [P1-subtree] must be + AND [B4.o.k] after [B4.L.n.k] must be + or - for association.)<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) /*(3*4)+-5/*6+-<br>"+
	"            Write([B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) /*(3/-4)+-5/*6+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)<br>"+

	"<br>Example<br>"+
	"/*(3/*+-4)+-5/*+-<br>"+
	"drag ')' and drop on '5'<br>";



	wrongDropRules[3][8][3] = "Rule ID ('Rule_W3-8-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, -)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),<br>"+
	"            And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF Equal(P1.B.o.k, *)<br>"+
	"            ex)    (3*4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) (3/-4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association.)<br>"+

	"    ELSE IF  Equal(GParent(B1), B3)<br>"+
	"        IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, +))<br>"+
	"            ex)    -(3+4)+-5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, *))<br>"+
	"            ex)    -(3*4)+-5+-<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex)    -(3/-4)+-5+-<br>"+
	"            Write([B3.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, *))<br>"+
	"            ex)    +(3*4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association)<br>"+
	"            Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"        ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex)    +(3/-4)+-5+-<br>"+
	"            Write([P1.B.o.k] in [P1-subtree] must be + for association)<br>"+

	"<br>Example<br>"+
	" -(3/*+-4)+-5+- or +(3/*-4)+-5+- or (3/*-4)+-5+-<br>"+
	"drag ')' and drop on '5'<br>";



	wrongDropRules[3][8][4] = "Rule ID ('Rule_W3-8-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(GParent(B1), B3), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(Parent(B1), {E, P})) ),<br>"+
	"        Or( Equal(N1, B2.L.n), And(HasChild(B2.L, B4), Equal(N1, B4.L.n)) ) )<br>"+
	"THEN<br>"+
	"    IF Equal(Parent(B1), {E, P})<br>"+
	"        IF Equal(P1.B.o.k, +)<br>"+
	"            ex) (3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"        ELSE IF Equal(P1.B.o.k, *)<br>"+
	"            ex) (3*4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF Equal(P1.B.o.k, {/, -})<br>"+
	"            ex) (3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"    ELSE IF Equal(GParent(B1), B3)<br>"+
	"        IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, +))<br>"+
	"            ex) +(3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))<br>"+
	"            ex) +-(3*4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) +(3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, +))<br>"+
	"            ex) -(3+4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([B3.o.k] before [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([B3.o.k] before [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"        ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, {/, -}))<br>"+
	"            ex) -(3/-4)+-5/*<br>"+
	"            IF Equal(B2.o.k, {*, /})<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"            ELSE IF Equal(HasChild(B2.L, B4))<br>"+
	"                Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)+-5/* or (3/*+-4)+-5/*<br>"+
	"drag ')' and drop on '5' <br>";



	wrongDropRules[3][8][5] = "Rule ID ('Rule_W3-8-5')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(CP1,N1),<br>"+
	"        Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3), <br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),<br>"+
	"        Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.R, P1), Equal(B3.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.L, P1), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),<br>"+
	"            And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.L.B, B1), Equal(Parent(B3), {E, P})) ),<br>"+
	"        Equal(N1, B2.L.n) )<br>"+
	"THEN<br>"+
	"    IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))<br>"+
	"        ex) (3*4)/5/* or +-(3*4)/5/*<br>"+
	"        Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/+-4)/5/* or +-(3/+-4)/5/*<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)<br>"+
	"    ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))<br>"+
	"        ex) (3/+-4)*5/* or +-(3/+-4)*5/*<br>"+
	"        Write([P1.B.o.k] in [P1-subtree] must be * for association.)<br>"+

	"<br>Example<br>"+
	"+-(3/*+-4)/5/* or +-(3/+-4)*5/* or (3/*+-4)/5/* or (3/+-4)*5/*<br>"+
	"drag ')' and drop on '5' <br>";


	rightDropRules[4][1] = "Rule ID ('Rule_R4-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        Equal(B1.o.k, {*, /}), Include(B1.R, P1),<br>"+
	"        Equal(O1, B1.o) )<br>"+
	"THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [P1-subtree].)<br>"+

	"<br>Example<br>"+
	"/*+-2*(3+-4)/*+-<br>"+
	"drag '2' and drop on 'operator' between '2' and '(3+-4)'<br>";




	wrongDropRules[4][1][1] = "Rule ID ('Rule_W4-1-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        Equal(B1.o.k, *), Include(B1.R, P1),<br>"+
	"        !Equal(O1, B1.o) )<br>"+
	"THEN Write(You must first simplify [N1.k][B1.o.k][P1-subtree] before continuing.)<br>"+

	"<br>Example<br>"+
	"/*+-2*(3+-4)/*+-<br>"+
	"drag '2' and drop on 'operator' which is not between '2' and '(3+-4)'<br>";



	wrongDropRules[4][1][2] = "Rule ID ('Rule_W4-1-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),<br>"+
	"        Or( And(HasChild(B1.R, P1), And( !Equal(B1.o, *), !Equal(B1.o, /))),<br>"+
	"            And(HasChild(B1.R, B2), HasChild(B2.L, P1), And( !Equal(B1.o, *), !Equal(B1.o, /)) ),<br>"+
	"        Equal(O1, B1.o) )<br>"+
	"THEN Write([O1.k] between [N1] and [P1-subtree] must be * for distribution.)<br>"+

	"<br>Example<br>"+
	"2/+-(3+-4) or 2/+-(3+-4)+- or +-2/+-(3+-4) or +-2/+-(3+-4)+- or /*2/(3+-4)/*+-<br>"+
	"drag '2' and drop on 'operator' between '2' and '(3+-4)'<br>";



	wrongDropRules[4][1][3] = "Rule ID ('Rule_W4-1-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Or( And(Equal(B1.o.k, {*, /}), HasChild(B2.R, P1)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), HasChild(B2.R, B3), HasChild(B3.L, P1)),<br>"+
	"            And(Equal(B1.o.k, {*, /}), HasChild(B2.R, B3), HasChild(B3.L, B4), HasChild(B3.L, P1)) ),<br>"+
	"        Equal(O1, B2.o) )<br>"+
	"THEN Write([O1.k] between [N1] and [P1-subtree] must be * for distribution.)    <br>"+

	"<br>Example<br>"+
	"/*2+-(3+-4) or /*2+-(3+-4)/*+- <br>"+
	"drag '2' and drop on 'operator' between '2' and '(3+-4)'<br>";



	rightDropRules[4][2] = "Rule ID ('Rule_R4-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1),<br>"+
	"        Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), Equal(B2.o.k, *)),<br>"+
	"            And(Equal(B1.R.n, N1), HasChild(B1.L, P1), Equal(B1.o.k, *)) ),<br>"+
	"        And(Equal(GParent(P1), B3), Equal(B3.o, O1)) )<br>"+
	"THEN Write(You simplified the expression by [O1]ing [P1-subtree] and [N1.k].)            <br>"+

	"<br>Example<br>"+
	"/*+-(3+-4)*5/*+-<br>"+
	"drag '5' and drop on 'operator' between '(3+-4)' and '5'<br>";



	wrongDropRules[4][2][1] = "Rule ID ('Rule_W4-2-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1),<br>"+
	"        Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), Equal(B2.o.k, *)),<br>"+
	"            And(Equal(B1.R.n, N1), HasChild(B1.L, P1), Equal(B1.o.k, *)) ),<br>"+
	"        And(Equal(GParent(P1), B3), !Equal(B3.o, O1)) )<br>"+
	"THEN Write(You must first simplify [P1-subtree][B1.o.k][N1.k] before continuing.)            <br>"+

	"<br>Example<br>"+
	"/*+-(3+-4)*5/*+-<br>"+
	"drag '5' and drop on 'operator' which is not between '(3+-4)' and '5'<br>";



	wrongDropRules[4][2][2] = "Rule ID ('Rule_W4-2-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,O1),<br>"+
	"        Equal(GParent(N1), B1),<br>"+
	"        Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), And( !Equal(B2.o.k, *), !Equal(B2.o.k, /)), Equal(B2.o, O1)),<br>"+
	"            And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), Include(B2.L, P1), Equal(Parent(P1), R), And( !Equal(B2.o.k, *), !Equal(B2.o.k, /)), Equal(B2.o, O1)),<br>"+
	"            And(Equal(B1.R.n, N1), HasChild(B1.L, P1), And( !Equal(B1.o.k, *), !Equal(B1.o.k, /)), Equal(B1.o, O1)),<br>"+
	"            And(Equal(B1.R.n, N1), Include(B1.L, P1), Equal(Parent(P1), R), And( !Equal(B1.o.k, *), !Equal(B1.o.k, /)), Equal(B1.o, O1)) ),<br>"+
	"        And(Equal(GParent(P1), B3), Equal(B3.o, O1)) )<br>"+
	"THEN Write([O1.k] between [P1-subtree] and [N1.k] must be * for distribution.)<br>"+

	"<br>Example<br>"+
	"(3+-4)/+-5 or /*+-(3+-4)/+-5 or (3+-4)/+-5/*+- or +-(3+-4)/+-5/*+-<br>"+
	"drag '5' and drop on 'operator' between '(3+-4)' and '5'<br>";



	rightDropRules[4][3] = "Rule ID ('Rule_R4-3')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,OP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),<br>"+
	"            And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        Equal(OP1, P1.open) );<br>"+
	"THEN Write(Right! [P1-subtree] is distributive.)<br>"+

	"<br>Example<br>"+
	"(3*4+-4*5)<br>"+
	"drag '4' and drop on '('<br>";



	wrongDropRules[4][3][1] = "Rule ID ('Rule_W4-3-1')<br>"

	"<br>Rule<br>"+
	"IF And( Drag(N1,OP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),<br>"+
	"            And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        !Equal(OP1, P1.open) );<br>"+
	"THEN Write(Right! [P1-subtree] is distributive.)<br>"+

	"<br>Example<br>"+
	"(3*4+-4*5)<br>"+
	"drag '4' and drop on '(' which is not in (3*4+-4*5)<br>";



	wrongDropRules[4][3][2] = "Rule ID ('Rule_W4-3-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,OP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        !Or( And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"             And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        Equal(OP1, P1.open) );<br>"+
	"THEN<br>"+
	"    IF Equal(Include(P1.B.L, N1))<br>"+
	"        Write(A multiple of N1 must be in [P1.B.R-subtree] for distribution.)<br>"+
	"    ELSE<br>"+
	"        Write(A multiple of N1 must be in [P1.B.L-subtree] for distribution.)<br>"+

	"<br>Example<br>"+
	"(3*4+-5*6)<br>"+
	"drag '4' and drop on '('<br>";



	rightDropRules[4][4] = "Rule ID ('Rule_R4-4')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,CP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),<br>"+
	"            And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        Equal(CP1, P1.close) );<br>"+
	"THEN Write(Right! <P1-subtree> is distributive.)<br>"+

	"<br>Example<br>"+
	"(3*4+-4*5)<br>"+
	"drag '4' and drop on ')'<br>";



	wrongDropRules[4][4][1] = "Rule ID ('Rule_W4-4-1')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,CP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),<br>"+
	"            And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),<br>"+
	"            And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        !Equal(CP1, P1.close) );<br>"+
	"THEN Write(You can drag [N1.k] over [CP1.k] in [P1-subtree] for distribution.)<br>"+

	"<br>Example<br>"+
	"(3*4+-4*5)<br>"+
	"drag '4' and drop on ')'<br>";



	wrongDropRules[4][4][2] = "Rule ID ('Rule_W4-3-2')<br>"+

	"<br>Rule<br>"+
	"IF And( Drag(N1,CP1),<br>"+
	"        HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})<br>"+
	"        !Or( And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),<br>"+
	"             And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )<br>"+
	"        Equal(CP1, P1.close) );<br>"+
	"THEN<br>"+
	"    IF Equal(Include(P1.B.L, N1))<br>"+
	"        Write(A multiple of N1 must be in [P1.B.R-subtree] for distribution.)<br>"+
	"    ELSE<br>"+
	"        Write(A multiple of N1 must be in [P1.B.L-subtree] for distribution.)<br>"+

	"<br>Example<br>"+
	"(3*4+-5*6)<br>"+
	"drag '4' and drop on '('<br>";


	isCanvasValid = true;		//for staring drawing canvas
}

//draw everything on canvas
function mainDraw() {
	if (isCanvasValid == true) {
		//show message and tip about wrong drop
		if(wrongDropMessages.length >= 1){
			if(rightDropMessage == ""){
				//if interation mode is OFF, message is showed
				if(interactionState != "OFF"){

					var	message = "Please try again.\n";

					var length = wrongDropMessages.length;
					for(var i=0; i<length; i++){
						message += (i+1)+". ";
						message += wrongDropMessages[i];
						if(i != length-1){
							message += "\n";
						}
					}

					alert(message);
				}
			}
			wrongDropMessages = [];
		}

		//show message and tip about right drop
		if(rightDropMessage != ""){
			//if interation mode is OFF, message is showed
			if(interactionState != "OFF"){
				alert(rightDropMessage);
			}
			rightDropMessage = "";
		}

		clearContext(ctx);							//wipes the canvas context

		//Problem
		ctx.textAlign = "start";
		ctx.font = boldForCanvasContext + "30pt " + mainFont;
		ctx.fillStyle = "#000000"
		ctx.fillText( "Problems", 20, 40);

		var correctAnswerCount = 0;
		var incorrectAnswerCount = 0;
		var isAnswerCalculated = false;	//when set to true, show Correct Answers number and Incorrect Answers number at the bottom of page.


		//questions (boxex)
		var questionLength = boxes.length;
		var i = 0;

		for (; i < questionLength; i++) {
			var boxLength = boxes[i].length;

			//question number ex 1) 2) 3)
			ctx.font = boldForCanvasContext  + TEXT_SIZE+"pt " + mainFont;
			ctx.fillStyle = "#000080"
			ctx.textAlign = "start";
			ctx.fillText( (i+1)+")", 20, i*(BOX_HEIGHT+GAP)+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT+MARGIN_Y);

			var j=0;
			for(; j<boxLength; j++){
				if(myDragSource != boxes[i][j]){
					boxes[i][j].draw(ctx);
				}
			}

			//equal sign =
			ctx.font = boldForCanvasContext  + TEXT_SIZE+"pt " + mainFont;
			ctx.textAlign = "center";
			ctx.lineWidth= "";
			ctx.fillStyle = "#4c4c4c"

			var x = j*(BOX_WIDTH+GAP)+MARGIN_X;
			var y = i*(BOX_HEIGHT+GAP)+MARGIN_Y;

			ctx.fillText( "=", x+BOX_WIDTH/2, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT);
			if(answers[i].state == "incorrect"){
				//to make a not equal sign (≠)
				ctx.strokeStyle = "#000000";
				ctx.lineWidth = 2;
				ctx.moveTo(x+BOX_WIDTH/2+3, y+BOX_HEIGHT/2-6);
				ctx.lineTo(x+BOX_WIDTH/2-3, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT+2);
				ctx.stroke();
			}

			//answer
			ctx.textAlign = "center";

			x = MARGIN_X+(j+1)*(BOX_WIDTH+GAP);
			ctx.fillStyle = "#ebebeb";
			ctx.fillRect(x, y, BOX_WIDTH, BOX_HEIGHT);

			ctx.strokeStyle = "#d4d9dc";
			ctx.strokeRect(x, y, BOX_WIDTH, BOX_HEIGHT);

			if(answers[i].state == "notDecided"){
				ctx.fillStyle = "#000000";	//black
			}else if(answers[i].state == "correct"){
				isAnswerCalculated = true;
				ctx.fillStyle = "#00FF00";	//green
				correctAnswerCount++;
			}else if(answers[i].state == "incorrect"){
				isAnswerCalculated = true;
				ctx.fillStyle = "#FF0000";	//red
				incorrectAnswerCount++;
			}
			ctx.fillText( answers[i].answer, x+ BOX_WIDTH/2, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT);
		}

		if(isAnimationFinished == true && getIsAnimating() == false){
			if(tempQuestion != null){
				boxes[myQuestionIndex] = tempQuestion;
				tempQuestion = null;
				alignBox(myQuestionIndex);
				mainDraw();
			}
			isAnimationFinished = false;

			return;
		}

		//You estimated 'questionTime' mitues
		var y = i*(BOX_HEIGHT+GAP)+MARGIN_Y-30;
		ctx.fillStyle = "#000000";
		ctx.textAlign = "start";
		ctx.font = boldForCanvasContext + "15pt " + mainFont;
		ctx.fillText("You estimated " + questionTime + " Minutes", 20, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT);

		//when set to true, show Correct Answers number and Incorrect Answers number at the bottom of page.
		if(isAnswerCalculated == true){
			y += 25;
			ctx.fillText("Correct Answers : " + correctAnswerCount, 20, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT);
			y += 25;
			ctx.fillText("Incorrect Answers " + incorrectAnswerCount, 20, y+BOX_HEIGHT/2+CENTER_ALIGN_HEIGHT);
		}

		//a use time for answers
		var x = 420;
		y += 60;
		ctx.fillStyle = "#d3d3d3";
		ctx.fillRect(x, y, 160, BOX_HEIGHT);

		ctx.strokeStyle = "#808080";
		ctx.strokeRect(x, y, 160, BOX_HEIGHT);

		x = 500;
		y += 40;
		ctx.fillStyle = "#000000";
		ctx.font = boldForCanvasContext + "30pt " + mainFont;
		ctx.textAlign = "center";
		ctx.fillText(timeTextForLastPage, x, y);

		//draw the box being dragged or returned
		if(myDragSource != null && (isDragging || getIsAnimating())){
			myDragSource.draw(ctx);
		}
		//in case the box is returning

		if(getIsAnimating() == false){
			isCanvasValid = false;
		}
	}
}

function getIsAnimating(){
	var firstLength = boxes.length
	for(var i=0; i<firstLength; i++){
		var secondLength = boxes[i].length;
		for(var j=0; j<secondLength; j++){
			if(boxes[i][j].isAnimating == true){
				return true;
			}
		}
	}
	return false;
}

//Happens when the mouse is clicked in the canvas
function onMouseDown(e){
	myDown(e, false);
}
function onMouseMove(e){
	myMove(e, false);
}
function onMouseUp(e){
	myUp(e);
}
function onTouchStart(e){
	myDown(e, true);
}
function onTouchMove(e){
	myMove(e, true);
}
function onTouchEnd(e){
	myUp(e);
}


//wipes the canvas context
function clearContext(context) {
	context.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
}

//I use isTouch argument to distinguish whether it is clicked with mouse or touch
//because in the case of mouse, we can get coordiates with parmener 'e'. On the other hand, in the case of touch, with 'e.touches[0]'
//Happens when the mouse is pressed
function myDown(e, isTouch) {
	//if the box is returning, it donsen't work
	if(getIsAnimating() == false){
		getMouse(canvas, e, isTouch);	//Sets mx,my to the mouse position relative to the canvas
		clearContext(gctx);			//wipes the ghost canvas context

		var questionLength = boxes.length;
		for (var i = 0; i < questionLength; i++) {
			var boxLength = boxes[i].length;

			//if calculation is done, it isn't selected
			if(boxLength != 1){
				for(var j=0; j<boxLength; j++){

					var check = boxes[i][j].key;

					boxes[i][j].draw(gctx);		// draw shape onto ghost context
					var imageData = gctx.getImageData(mx, my, 1, 1);	// get image data at the mouse x,y pixel

					// if the mouse pixel exists, select
					if (imageData.data[3] > 0) {
						e.preventDefault();	//it blocks basic touch event. I use it to prevent canvas from being clicked.
						myQuestionIndex = i;
						myDragSource = boxes[i][j];

						//only when parse mode is 'ON', tree is showed
						if(parseState == "ON"){
							if(treeState == "TOP-DOWN" || treeState == "BOTTOM-UP"){
								treeCanvasInit();
								treeQuestionIndex = i;
								treeQuestion = boxes[i];
								generateTree();

							}else if(treeState == "DETAIL"){
								detailTreeInit()
								treeQuestionIndex = i;
								treeQuestion = boxes[i];
								var syntax = parser.parse(treeQuestion);	//generator tree
								showDetailTree(syntax);					//show parse tree
							}
						}

						//when one clicked is operator
						if(isOperator(check)){
							dragDropBox("drop", boxes[myQuestionIndex], myQuestionIndex, myDragSource, myDragSource);	//calculate
							if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
								if (tempQuestion == null){
									treeQuestion = boxes[treeQuestionIndex];
								}else{
									treeQuestion = tempQuestion;
								}
								generateTree();
							}

							if(rightDropMessage != ""){
								//if interation mode is RULE, rule is showed
								if(interactionState == "RULE"){
									var length = myDropTarget.rules.length;
									var ruleBodyString = "";
									for(var i=0; i<length; i++){
										var firstRuleIndex = myDropTarget.rules[i].charAt(3);
										var secondRuleIndex = myDropTarget.rules[i].charAt(5);

										ruleBodyString += rules[firstRuleIndex][secondRuleIndex];
									}

									document.getElementById("ruleBody").innerHTML = ruleBodyString;
								}
							}else if(wrongDropMessages.length != 0){
								//if interation mode is RULE, rule is showed
								if(interactionState == "RULE"){
									var length = myDropTarget.rules.length;
									var ruleBodyString = "";
									for(var i=0; i<length; i++){
										var firstRuleIndex = myDropTarget.rules[i].charAt(3);
										var secondRuleIndex = myDropTarget.rules[i].charAt(5);
										var thirdRuleIndex = myDropTarget.rules[i].charAt(7);

										ruleBodyString += rules[firstRuleIndex][secondRuleIndex][thirdRuleIndex];
									}

									document.getElementById("ruleBody").innerHTML = ruleBodyString;
								}
							}

							//reset
							boxLength = boxes[myQuestionIndex].length;
							for(var i=0; i < boxLength; i++){
								boxes[myQuestionIndex][i].rules = [];
							}

							myDragSource = null;
							//myQuestionIndex = null;
							isDragging = false;			//so that myMove and myUp doesn't work

						}
						//when one clicked is number or parenthesis
						else{
							myDragSource.destinationX = myDragSource.x;
							myDragSource.destinationY = myDragSource.y;

							myDragSource.isSelected = true;

							offsetX = mx - myDragSource.x;
							offsetY = my - myDragSource.y;

							var length = boxes[i].length;
							//check candidates
							for(var k=0; k<length; k++){
								if(boxes[i][k] != myDragSource){
									dragDropBox("drag", boxes[myQuestionIndex], myQuestionIndex, myDragSource, boxes[i][k]); //used 'drag' mode to check candidates
									if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
										copyBoxAtrributes(boxes[myQuestionIndex][k], tree[k]);
									}
								}else{
									if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
										var newBox = new Box;
										newBox.isSelected = true;
										copyBoxAtrributes(newBox, tree[k]);
									}
								}
							}

							isDragging = true;	//for box's returning
						}

						clearContext(gctx);			//wipes the fake canvas context
						isCanvasValid = true;	//for redrawing canvas
						if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
							isTreeCanvasValid = true;	//for redrawing canvas
						}

						return;
					}
				}
			}
		}

		myDragSource = null;
		myQuestionIndex = null;
		clearContext(gctx);			//clear the ghost canvas for next time
		isCanvasValid = false;	//for stop redrawing
	}
}


//Happens when the mouse is moving inside the canvas

function myMove(e, isTouch) {

	//only when the is dragging, it works
	if (isDragging == true) {
		getMouse(canvas, e, isTouch);	//Sets mx,my to the mouse position relative to the canvas

		myDragSource.x = mx - offsetX;
		myDragSource.y = my - offsetY;

		clearContext(gctx);	//wipes the ghost canvas context

		var centerX = myDragSource.x + myDragSource.w / 2;
		var cetnerY = myDragSource.y + myDragSource.h / 2;

		var boxLength = boxes[myQuestionIndex].length-1;
		for(var i = boxLength; i >= 0; i--){

			boxes[myQuestionIndex][i].checkDragOver(gctx);				// draw shape onto ghost context
			var imageData = gctx.getImageData(centerX, cetnerY, 1, 1);	// get image data at the mouse x,y pixel

			// if the mouse pixel exists, select
			if (imageData.data[3] > 0) {
				var box = boxes[myQuestionIndex][i];
				if(box.isCandidate == true){			//only of candidates, it is changed into blue-color border
					box.isSelectedCandidate = true;		//for blue-color border when the box is over on candidates while the box is moving
				}

				if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
					if(boxes[myQuestionIndex][i] != myDragSource){
						copyBoxAtrributes(boxes[myQuestionIndex][i], tree[i]);
					}
				}

				clearContext(gctx);			// draw shape onto ghost context
				isCanvasValid = true;	//for redrawing canvas
				if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
					isTreeCanvasValid = true;	//for redrawing canvas
				}

				return;
			}else{
				boxes[myQuestionIndex][i].isSelectedCandidate = false;
				if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
					if(boxes[myQuestionIndex][i] != myDragSource){
						copyBoxAtrributes(boxes[myQuestionIndex][i], tree[i]);
					}
				}
			}
		}

		clearContext(gctx);			//clear the ghost canvas for next time
		isCanvasValid = true;	//for redrawing canvas
		if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
			isTreeCanvasValid = true;	//for redrawing canvas
		}
		isMoved = true;			//this is for in case a user click the box without dragging.
	}
}

//Happens when the mouse is up
function myUp(e) {
	if(isDragging == true){

		//for box's returning
		setAnimationAceleration(myDragSource);

		myDragSource.animationType = 'linearMotion';
		myDragSource.isAnimating = true;

		var centerX = myDragSource.x + myDragSource.w / 2;
		var cetnerY = myDragSource.y + myDragSource.h / 2;

		clearContext(gctx);	//wipes the ghost canvas context
		var boxLength = boxes[myQuestionIndex].length-1;
		for(var i = boxLength; i >= 0; i--){
			boxes[myQuestionIndex][i].checkDragOver(gctx);				// draw shape onto ghost context
			var imageData = gctx.getImageData(centerX, cetnerY, 1, 1);	// get image data at the mouse x,y pixel

			// if the mouse pixel exists, select
			if (imageData.data[3] > 0) {
				myDropTarget = boxes[myQuestionIndex][i];
				break;
			}
		}
		clearContext(gctx);	//clear the ghost canvas for next time

		//if box is dropped over other box
		if(myDropTarget != null){
			//if the droped target is a candidate
			if(myDropTarget.isCandidate == true){

				dragDropBox("drop", boxes[myQuestionIndex], myQuestionIndex, myDragSource, myDropTarget);	//calculate

				if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){

					if (tempQuestion == null){
						treeQuestion = boxes[treeQuestionIndex];
					}else{
						treeQuestion = tempQuestion;
						boxLength = tempQuestion.length;
					}

					generateTree();
				}
				myDragSource = null;

				//if interation mode is RULE, rule is showed
				if(interactionState == "RULE"){
					var length = myDropTarget.rules.length;

					var ruleBodyString = "";
					for(var i=0; i<length; i++){
						if(myDropTarget.rules[i].charAt(2) == "R"){
							ruleBodyString += rightDropRules[myDropTarget.rules[i].charAt(3)][myDropTarget.rules[i].charAt(5)]+
							"--------------------------------------------------------------------------------<br><br>"

						}else if(myDropTarget.rules[i].charAt(2) == "W"){
							ruleBodyString += wrongDropRules[myDropTarget.rules[i].charAt(3)][myDropTarget.rules[i].charAt(5)][myDropTarget.rules[i].charAt(7)]+
							"--------------------------------------------------------------------------------<br><br>"
						}
					}
					document.getElementById("ruleBody").innerHTML = ruleBodyString;
				}
			}
		}

		if(tempQuestion == null){
			boxLength = boxes[myQuestionIndex].length;

			//reset
			for(var i=0; i < boxLength; i++){
				boxes[myQuestionIndex][i].isSelected = false;
				boxes[myQuestionIndex][i].isSelectedCandidate = false;
				boxes[myQuestionIndex][i].isCandidate = false;
				boxes[myQuestionIndex][i].isDistributive = false;
				boxes[myQuestionIndex][i].rules = [];

				if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
					if(boxes[myQuestionIndex][i] != myDragSource){
						copyBoxAtrributes(boxes[myQuestionIndex][i], tree[i]);
					}else{
						var newBox = new Box;
						copyBoxAtrributes(newBox, tree[i]);
					}
				}
			}
		}else{
			boxLength = boxes[myQuestionIndex].length;

			for(var i=0; i < boxLength; i++){
				boxes[myQuestionIndex][i].isSelected = false;
				boxes[myQuestionIndex][i].isSelectedCandidate = false;
				boxes[myQuestionIndex][i].isCandidate = false;
				boxes[myQuestionIndex][i].isDistributive = false;
				boxes[myQuestionIndex][i].rules = [];
			}
		}

		isMoved = false;			//reset
		isDragging = false;			//reset

		//myQuestionIndex = null;
		myDropTarget = null;
		isCanvasValid = true;	//for redrawing canvas
		if(parseState == "ON" &&  (treeState == "TOP-DOWN" || treeState == "BOTTOM-UP")){
			isTreeCanvasValid = true;	//for redrawing canvas
		}
	}
}
//initialize last page(canvas page)----------------------------------------------------------------------------------------------------------------------



//initialize tree pane(tree canvas)----------------------------------------------------------------------------------------------------------------------
function treeCanvasInit() {
	var treeBody = document.getElementById("treeBody");
	treeBody.innerHTML="";

	//set a canvas
	treeCanvas = document.createElement("canvas");
	treeCanvas.width = 595;
	treeCanvas.height = 395;
	treeCanvas.setAttribute("style", "background-color:#ffffff;");
	treeCanvas.setAttribute("class", "canvas");
	treeBody.appendChild(treeCanvas);

	treeCtx = treeCanvas.getContext('2d');

	//set a fake canvas
	treeGhostCanvas = document.createElement('canvas');
	treeGhostCanvas.width = treeCanvas.width;
	treeGhostCanvas.height = treeCanvas.height;
	treeGhostCanvas.setAttribute("class", "canvas");
	treeGctx = treeGhostCanvas.getContext('2d');

	setInterval(treeDraw, INTERVAL); 	//make mainDraw() fire every INTERVAL milliseconds

	//set our events.
	treeCanvas.onmousedown = onTreeMouseDown;
	treeCanvas.onmouseup = onTreeMouseUp;
	treeCanvas.onmousemove = onTreeMouseMove;

	treeCanvas.ontouchstart = onType1TouchStart;
	treeCanvas.ontouchend = onType1TouchEnd;
	treeCanvas.ontouchmove = onType1TouchMove;

	treeCanvas.onmouseout = onTreeMouseUp;


	//fixes a problem where double clicking causes text to get selected on the canvas
	treeCanvas.onselectstart = function() {
		return false;
	}
	isTreeCanvasValid = false;
}

function treeDraw() {
	if (isTreeCanvasValid == true) {
		clearTreeContext(treeCtx);

		var syntax = parser.parse(tree);
		showTree(syntax, treeCtx);

		//draw the box being dragged or returned
		if(treeBoxForDrag !=null && (isDragging || isTreeBoxReturning)){
			treeBoxForDrag.draw(treeCtx);
			if(treeBoxForDrag == null){
				treeDraw();
			}
		}

		//in case the box is returning
		if(isTreeBoxReturning == false){
			isTreeCanvasValid = false;
		}
	}
}

//Happens when the mouse is clicked in the tree canvas
function onTreeMouseDown(e){
	myTreeDown(e, false);
}
function onTreeMouseMove(e){
	myTreeMove(e, false);
}
function onTreeMouseUp(e){
	myTreeUp(e);
}
function onType1TouchStart(e){
	myTreeDown(e, true);
}
function onType1TouchMove(e){
	myTreeMove(e, true);
}
function onType1TouchEnd(e){
	myTreeUp(e);
}

//wipes the tree canvas context
function clearTreeContext(context) {
	context.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
}

function myTreeDown(e, isTouch) {
	//if the box is returning, it donsen't work
	if(isTreeBoxReturning == false && getIsAnimating() == false){

		getMouse(treeCanvas, e, isTouch);	//Sets mx,my to the mouse position relative to the canvas
		clearTreeContext(treeGctx);			//wipes the ghost canvas context

		//if calculation is done, it isn't selected
		var boxLength = tree.length;
		if(boxLength != 1){
			for(var j=0; j<boxLength; j++){

				var check = tree[j].key;
				tree[j].draw(treeGctx);		// draw shape onto ghost context
				var imageData = treeGctx.getImageData(mx, my, 1, 1);	// get image data at the mouse x,y pixel
				// if the mouse pixel exists, select
				if (imageData.data[3] > 0) {
					e.preventDefault();	//it blocks basic touch event. I use it to prevent canvas from being clicked.
					treeSourceIndex = j;
					myDragSource = tree[j];

					//when one clicked is operator
					if(isOperator(check)){
						dragDropBox("drop", boxes[treeQuestionIndex], treeQuestionIndex, boxes[treeQuestionIndex][treeSourceIndex], boxes[treeQuestionIndex][treeSourceIndex]);	//calculate

						if (tempQuestion == null){
							treeQuestion = boxes[treeQuestionIndex];
						}else{
							treeQuestion = tempQuestion;
						}
						generateTree();

						myDragSource = null;
						isDragging = false;			//so that myMove and myUp doesn't work
					}
					//when one clicked is number or parenthesis
					else{
						myDragSource.isVisible = false;

						//clone myDrageSource
						treeBoxForDrag = new Box;
						treeBoxForDrag.x = myDragSource.x;
						treeBoxForDrag.y = myDragSource.y;
						treeBoxForDrag.w = myDragSource.w;
						treeBoxForDrag.h = myDragSource.h;
						treeBoxForDrag.key = myDragSource.key;
						treeBoxForDrag.fill = '#FFFFFF';
						treeBoxForDrag.isSelected = true;

						offsetX = mx - treeBoxForDrag.x;
						offsetY = my - treeBoxForDrag.y;
						treeBoxForDrag.x = mx - offsetX;
						treeBoxForDrag.y = my - offsetY;

						treeBoxForDrag.destinationX = treeBoxForDrag.x;
						treeBoxForDrag.destinationY = treeBoxForDrag.y;

						var length = tree.length;
						//check candidates
						for(var k=0; k<length; k++){
							if(tree[k] != myDragSource){
								dragDropBox("drag", tree, treeQuestionIndex, myDragSource, tree[k]); //used 'drag' mode to check candidates
								copyBoxAtrributes(tree[k], boxes[treeQuestionIndex][k]);
							}else{
								var newBox = new Box;
								newBox.isSelected = true;
								copyBoxAtrributes(newBox, boxes[treeQuestionIndex][k]);
							}
						}
						isDragging = true;	//for box's returning
					}

					clearTreeContext(treeGctx);			//wipes the fake canvas context
					isTreeCanvasValid = true;	//for redrawing canvas
					isCanvasValid = true;	//for redrawing canvas
					return;
				}
			}
		}

		myDragSource = null;
		clearTreeContext(treeGctx);			//clear the ghost canvas for next time
		isTreeCanvasValid = false;	//for stop redrawing
	}

}

//Happens when the mouse is moving inside the canvas
function myTreeMove(e, isTouch) {

	//only when the is dragging, it works
	if (isDragging == true) {
		getMouse(treeCanvas, e, isTouch);	//Sets mx,my to the mouse position relative to the canvas

		treeBoxForDrag.x = mx - offsetX;
		treeBoxForDrag.y = my - offsetY;

		clearTreeContext(treeGctx);	//wipes the ghost canvas context

		var centerX = treeBoxForDrag.x + treeBoxForDrag.w / 2;
		var cetnerY = treeBoxForDrag.y + treeBoxForDrag.h / 2;

		var boxLength = tree.length-1;
		for(var i = boxLength; i >= 0; i--){

			tree[i].checkDragOver(treeGctx);				// draw shape onto ghost context
			var imageData = treeGctx.getImageData(centerX, cetnerY, 1, 1);	// get image data at the mouse x,y pixel

			// if the mouse pixel exists, select
			if (imageData.data[3] > 0) {
				var box = tree[i];
				if(box.isCandidate == true){			//only of candidates, it is changed into blue-color border
					box.isSelectedCandidate = true;		//for blue-color border when the box is over on candidates while the box is moving
				}
				if(tree[i] != myDragSource){
					copyBoxAtrributes(tree[i], boxes[treeQuestionIndex][i]);
				}
				clearTreeContext(treeGctx);			// draw shape onto ghost context
				isTreeCanvasValid = true;	//for redrawing canvas
				isCanvasValid = true;

				return;
			}else{
				tree[i].isSelectedCandidate = false;
				if(tree[i] != myDragSource){
					copyBoxAtrributes(tree[i], boxes[treeQuestionIndex][i]);
				}
			}
		}

		clearTreeContext(treeGctx);			//clear the ghost canvas for next time
		isTreeCanvasValid = true;	//for redrawing canvas
		isCanvasValid = true;
		isMoved = true;			//this is for in case a user click the box without dragging.

	}
}

function setAnimationAceleration(box){
	if(animationSpeed>1000)
		animationSpeed = 1000;
	else if(animationSpeed < 0)
		animationSpeed = -animationSpeed;
	box.animationAccelerationX = (box.x - box.destinationX) * (0.0002 * animationSpeed);
	if(box.animationAccelerationX == 0){
		box.animationAccelerationY = (box.y - box.destinationY) * (0.0002 * animationSpeed);
	}else{
		box.animationAccelerationY = Math.abs(box.animationAccelerationX) * (box.y - box.destinationY) / Math.abs( (box.x - box.destinationX) );
	}
}

//Happens when the mouse is up
function myTreeUp(e) {
	if(isDragging == true){

		//for box's returning
		setAnimationAceleration(treeBoxForDrag);

		treeBoxForDrag.animationType = 'linearMotion';
		treeBoxForDrag.isAnimating = true;
		isTreeBoxReturning = true;

		var centerX = treeBoxForDrag.x + treeBoxForDrag.w / 2;
		var cetnerY = treeBoxForDrag.y + treeBoxForDrag.h / 2;

		clearTreeContext(treeGctx);		//wipes the ghost canvas context
		var boxLength = tree.length-1;
		for(var i = boxLength; i >= 0; i--){
			tree[i].checkDragOver(treeGctx);				// draw shape onto ghost context
			var imageData = treeGctx.getImageData(centerX, cetnerY, 1, 1);	// get image data at the mouse x,y pixel

			// if the mouse pixel exists, select
			if (imageData.data[3] > 0) {
				treeTargetIndex = i;
				myDropTarget = tree[i];
				break;
			}
		}
		clearTreeContext(treeGctx);		//clear the ghost canvas for next time

		//if box is dropped over other box
		if(myDropTarget != null){
			//if the droped target is a candidate
			if(myDropTarget.isCandidate == true){
				dragDropBox("drop", boxes[treeQuestionIndex], treeQuestionIndex, boxes[treeQuestionIndex][treeSourceIndex], boxes[treeQuestionIndex][treeTargetIndex]);	//calculate
				if (tempQuestion == null){
					treeQuestion = boxes[treeQuestionIndex];
				}else{
					treeQuestion = tempQuestion;
				}
				generateTree();
				myDragSource = null
				treeBoxForDrag = null;
				isTreeBoxReturning = false;
			}
		}

		isMoved = false;			//reset
		isDragging = false;			//reset

		//reset
		boxLength = tree.length;
		for(var i=0; i < boxLength; i++){
			tree[i].isSelected = false;
			tree[i].isSelectedCandidate = false;
			tree[i].isCandidate = false;
			tree[i].isDistributive = false;
			tree[i].rules = [];
			copyBoxAtrributes(tree[i], boxes[treeQuestionIndex][i]);
		}

		myDropTarget = null;
		isTreeCanvasValid = true;	//for redrawing canvas
		isCanvasValid = true;	//for redrawing canvas
	}
}
//initialize tree pane(tree canvas)----------------------------------------------------------------------------------------------------------------------


//initialize tree pane(tree pre)----------------------------------------------------------------------------------------------------------------------
function detailTreeInit(){
	var treeBody = document.getElementById("treeBody");
	treeBody.innerHTML="<pre class='canvas' id='detailTreeBody' style='width:600px; height:400px;'></pre>";
}
//initialize tree pane(tree pre)----------------------------------------------------------------------------------------------------------------------


//About Tree---------------------------------------------------------------------------------------------------------------------------------------------
//generate tree
function generateTree(){
	treeBoxForDrag = null;
	tree = [];
	var length = treeQuestion.length;
	for(var i=0; i<length; i++){
		var newBox = getCloneBox(treeQuestion[i]);

		newBox.x = 50;
		newBox.y = i*50;
		newBox.w = TREE_BOX_WIDTH;
		newBox.h = TREE_BOX_HEIGHT
		tree.push(newBox);
	}
}

//show tree as a TOP-DOWN or BOTTOM-UP tree
function showTree(syntax, context) {
	function BoxCoordinates() {
		this.x;
		this.y;
		this.level;
	}

	var HEIGHT_GAP = 75;
	var MINUS = 35;
	var drawingObjects = [];
	var drawingLeftLines = [];
	var drawingRightLines = [];
	var highestLevel = 1;

	function checkHighestLevel(object, level) {
		var node = object;

		if(highestLevel < level){
			highestLevel ++;
		}

		for (key in node) {
			if (node instanceof Box){
				return;
			}
       		if(key != 'toString'){
       			if(key == 'Binary'){
       				level++;
       				checkHighestLevel(node['Binary']['operator']);
       				checkHighestLevel(node['Binary']['Left'], level);
       				checkHighestLevel(node['Binary']['Right'], level);
       			}else if(key == 'Parenthesis'){
       				level++;
       				checkHighestLevel(node['Parenthesis']['Binary']['operator']);
       				checkHighestLevel(node['Parenthesis']['Binary']['Left'], level);
       				checkHighestLevel(node['Parenthesis']['Binary']['Right'], level);
       			}else{
       				checkHighestLevel(node[key], level);
       			}
       		}
	    }
	}

	checkHighestLevel(syntax, 1);

	var WIDTH_GAP = highestLevel * MINUS + 35;

	//show TOP-DOWN tree
	if(treeState == "TOP-DOWN"){
		var longestBoxX = 595;
		var longestBoxY = 395;

		function drawTopDownTree(object, boxX, boxY, level) {
		    if (object instanceof Box){
				object.x = boxX;
				object.y = boxY;

				if(longestBoxX < boxX)
					longestBoxX = boxX;

				if(longestBoxY < boxY)
					longestBoxY = boxY;

				drawingObjects.push(object);

	    		return;
	    	}else if(object == 'Left'){
	    		boxCoordinates = new BoxCoordinates;
	    		boxCoordinates.x = boxX;
	    		boxCoordinates.y = boxY;
	    		boxCoordinates.level = level;
	    		drawingLeftLines.push(boxCoordinates);

	    	}else if(object == 'Right'){
	    		boxCoordinates = new BoxCoordinates;
	    		boxCoordinates.x = boxX;
	    		boxCoordinates.y = boxY;
	    		boxCoordinates.level = level;
	    		drawingRightLines.push(boxCoordinates);
	    	}

		    for (key in object) {
	       		if(key != 'toString'){
	       			if(key == 'Binary'){
	       				level++;
	       				drawTopDownTree(object['Binary']['operator'], boxX, boxY);
	       				drawTopDownTree(object['Binary']['Left'], boxX - (WIDTH_GAP-MINUS*level), boxY + HEIGHT_GAP, level);
	       				drawTopDownTree(object['Binary']['Right'], boxX + (WIDTH_GAP-MINUS*level), boxY + HEIGHT_GAP, level);
	       			}else if(key == 'Parenthesis'){
	       				level++;
	       				drawTopDownTree(object['Parenthesis']['Binary']['operator'], boxX, boxY);
	       				drawTopDownTree(object['Parenthesis']['Binary']['Left'], boxX - (WIDTH_GAP-MINUS*level), boxY + HEIGHT_GAP, level);
	       				drawTopDownTree(object['Parenthesis']['Binary']['Right'], boxX + (WIDTH_GAP-MINUS*level), boxY + HEIGHT_GAP, level);
	       			}else{
	       				drawTopDownTree(object[key], boxX, boxY, level);
	       			}
	       		}
		    }
		}
		drawTopDownTree(syntax, 250, 10, 1);
		if(longestBoxX > 590){
			treeCanvas.width = longestBoxX + 50;
			treeGhostCanvas.width = treeCanvas.width;
		}

		if(longestBoxY > 390){
			treeCanvas.height = longestBoxY + 50;
			treeGhostCanvas.height = treeCanvas.height;
		}


		context.strokeStyle = "#000000";
		context.lineWidth = 2;

		var length = drawingLeftLines.length;
		for(var i=0; i<length; i++){
			context.beginPath();
    		context.moveTo(drawingLeftLines[i].x + TREE_BOX_WIDTH/2, drawingLeftLines[i].y + TREE_BOX_HEIGHT/2);
    		context.lineTo(drawingLeftLines[i].x + (WIDTH_GAP-MINUS*drawingLeftLines[i].level) + TREE_BOX_WIDTH/2, drawingLeftLines[i].y - HEIGHT_GAP + TREE_BOX_HEIGHT/2);
    		context.stroke();
		}

		var length = drawingRightLines.length;
		for(var i=0; i<length; i++){
			context.beginPath();
    		context.moveTo(drawingRightLines[i].x + TREE_BOX_WIDTH/2, drawingRightLines[i].y + TREE_BOX_HEIGHT/2);
    		context.lineTo(drawingRightLines[i].x - (WIDTH_GAP-MINUS*drawingRightLines[i].level) + TREE_BOX_WIDTH/2, drawingRightLines[i].y - HEIGHT_GAP + TREE_BOX_HEIGHT/2);
    		context.stroke();
		}

		length = drawingObjects.length;
		for(var i=0; i<length; i++){
			drawingObjects[i].draw(context);
		}
	}
	//show BOTTOM-UP tree
	else if(treeState == "BOTTOM-UP"){
		var longestBoxX = 595;
		var shortestBoxY = 0;

		function drawBottomUpTree(object, boxX, boxY, level) {
		    if (object instanceof Box){
				object.x = boxX;
				object.y = boxY;

				if(longestBoxX < boxX)
					longestBoxX = boxX;

				if(shortestBoxY > boxY)
					shortestBoxY = boxY;

				drawingObjects.push(object);

	    		return;
	    	}else if(object == 'Left'){
	    		boxCoordinates = new BoxCoordinates;
	    		boxCoordinates.x = boxX;
	    		boxCoordinates.y = boxY;
	    		boxCoordinates.level = level;
	    		drawingLeftLines.push(boxCoordinates);

	    	}else if(object == 'Right'){
	    		boxCoordinates = new BoxCoordinates;
	    		boxCoordinates.x = boxX;
	    		boxCoordinates.y = boxY;
	    		boxCoordinates.level = level;
	    		drawingRightLines.push(boxCoordinates);
	    	}

		    for (key in object) {
	       		if(key != 'toString'){
	       			if(key == 'Binary'){
	       				level++;
	       				drawBottomUpTree(object['Binary']['operator'], boxX, boxY);
	       				drawBottomUpTree(object['Binary']['Left'], boxX - (WIDTH_GAP-MINUS*level), boxY - HEIGHT_GAP, level);
	       				drawBottomUpTree(object['Binary']['Right'], boxX + (WIDTH_GAP-MINUS*level), boxY - HEIGHT_GAP, level);
	       			}else if(key == 'Parenthesis'){
	       				level++;
	       				drawBottomUpTree(object['Parenthesis']['Binary']['operator'], boxX, boxY);
	       				drawBottomUpTree(object['Parenthesis']['Binary']['Left'], boxX - (WIDTH_GAP-MINUS*level), boxY - HEIGHT_GAP, level);
	       				drawBottomUpTree(object['Parenthesis']['Binary']['Right'], boxX + (WIDTH_GAP-MINUS*level), boxY - HEIGHT_GAP, level);
	       			}else{
	       				drawBottomUpTree(object[key], boxX, boxY, level);
	       			}
	       		}
		    }
		}


		drawBottomUpTree(syntax, 250, 350, 1);

		if(longestBoxX > 595){
			treeCanvas.width = longestBoxX + 50;
			treeGhostCanvas.width = treeCanvas.width;
		}

		if(shortestBoxY < 0){
			treeCanvas.height = 395 - shortestBoxY;
			treeGhostCanvas.height = treeCanvas.height;
		}

		context.strokeStyle = "#000000";
		context.lineWidth = 2;


		var length = drawingLeftLines.length;
		for(var i=0; i<length; i++){
			context.beginPath();
    		context.moveTo(drawingLeftLines[i].x + TREE_BOX_WIDTH/2, drawingLeftLines[i].y + TREE_BOX_HEIGHT/2 - shortestBoxY + 10);
    		context.lineTo(drawingLeftLines[i].x + (WIDTH_GAP-MINUS*drawingLeftLines[i].level) + TREE_BOX_WIDTH/2, drawingLeftLines[i].y + HEIGHT_GAP + TREE_BOX_HEIGHT/2- shortestBoxY + 10);
    		context.stroke();
		}

		var length = drawingRightLines.length;
		for(var i=0; i<length; i++){
			context.beginPath();
    		context.moveTo(drawingRightLines[i].x + TREE_BOX_WIDTH/2, drawingRightLines[i].y + TREE_BOX_HEIGHT/2 - shortestBoxY + 10);
    		context.lineTo(drawingRightLines[i].x - (WIDTH_GAP-MINUS*drawingRightLines[i].level) + TREE_BOX_WIDTH/2, drawingRightLines[i].y + HEIGHT_GAP + TREE_BOX_HEIGHT/2- shortestBoxY + 10);
    		context.stroke();
		}

		length = drawingObjects.length;
		for(var i=0; i<length; i++){
			drawingObjects[i].y = drawingObjects[i].y - shortestBoxY + 10;
			drawingObjects[i].draw(context);
		}
	}
}

//show detail tree visually
function showDetailTree(syntax) {
	function stringify(object, key, depth) {
	    var indent = "",
	        str = "",
	        value = object[key],
	        i;

	    //to express tree hierachically
	    while (indent.length < depth * 3) {
	        indent += " ";
	    }

	    switch (typeof value) {
	    case "string"://+,-,*,/, number
	        str = value;
	        break;
	    case "number":
	    case "boolean":
	    case "null":
	        str = String(value);
	        break;
	    case "object":
	        for (i in value) {
				if (value instanceof Box){
					//to show a clicked box's key in red color
					if(myDragSource === value){
						str += ("<br><font style='color:#ff0000 '>" + stringify(value, 'key', depth + 1)+"</font>");
					}else{
						str += ("<br>"+stringify(value, 'key', depth + 1));
					}
	        		break;
	        	}else if (value.hasOwnProperty(i)) {
	        		if(i != "toString"){
	        			str += ("<br>"+stringify(value, i, depth + 1));
	        		}
	            }
	        }
	        break;
	    }

	    return indent + ' ' + key + ': ' + str;
	}

	document.getElementById("detailTreeBody").innerHTML = stringify(syntax, 'Expression', 0);
}
//About Tree---------------------------------------------------------------------------------------------------------------------------------------------


//About helping function of dragDropBox()----------------------------------------------------------------------------------------------------------------
//get index of left parenthesis
function getOpenParenthesisIndex(boxes, questionIndex, numberIndex){
	for(var i=numberIndex-1; i>=0; i--){
		if(boxes[questionIndex][i].key == "("){
			return i;
		}
	}
	return -1;
}

//get index of right parenthesis
function getCloseParenthesisIndex(boxes, questionIndex, numberIndex){
	var length = boxes[questionIndex].length;
	for(var i=numberIndex+1; i<length; i++){
		if(boxes[questionIndex][i].key == ")"){
			return i;
		}
	}

	return -1;
}

//check whether it is multiplication or division or not
function isMulDiv(p){
	if(p == "*" || p =="/"){
		return true;
	}
	return false;
}

//check whether it is number or not
function isNumber(p){
	for (var i=0; i < p.length; i++) {
		//for negative number
    	if(p.length >= 2 && i == 0){
     		if (  ! (p.charAt(i) == '-' || (p.charAt(i) >= '0' && p.charAt(i) <= '9') ) ) {
     			return false;
     		}
     	}
    	//for positive number
    	else{
     		if (  !(p.charAt(i) >= '0' && p.charAt(i) <= '9')  ) {
	        	return false;
     		}
    	}
	}
	return true;
}

function isFraction(p){
	var isNumerator = false;
	var isDenominator = false;
	var divisionCount = 0;
	var divisionIndex = 0;

	for (var i=0; i < p.length; i++) {


		if(p.charAt(i) == '/'){
			divisionCount++;
			divisionIndex = i;
		}

		if(divisionCount >= 2){
			return false;
		}
	}

	if( !(p.length > divisionIndex+1) ){
		return false;
	}


	for (var i=0; i < p.length; i++) {
		if(i < divisionIndex){
			//for negative number
			if(divisionIndex >= 2 && i == 0){
				if (  ! (p.charAt(i) == '-' || (p.charAt(i) >= '0' && p.charAt(i) <= '9') ) ) {
					return false;
				}
			}
			//for positive number
			else{
				if (  ! (p.charAt(i) >= '0' && p.charAt(i) <= '9') ) {
					return false;
				}
			}
			isNumerator = true;

		}else if(i > divisionIndex){
			//for negative number
			if(p.length - divisionIndex+1 >= 2 && i == divisionIndex+1){
				if (  ! (p.charAt(i) == '-' || (p.charAt(i) >= '0' && p.charAt(i) <= '9') ) ) {
					return false;
				}
			}
			//for positive number
			else{
				if (  ! (p.charAt(i) >= '0' && p.charAt(i) <= '9') ) {
					return false;
				}
			}
			isDenominator = true;
		}
	}

	if(isDenominator && isNumerator){
		return true;
	}else{
		return false;
	}
}

//check whether it is operator or not
function isOperator(p){
	if(p == "+" || p =="-" || isMulDiv(p)){
		return true;
	}
	return false;
}

//check whether it is parenthesis or not
function isParenthesis(p){
	if(p == "(" || p ==")"){
		return true;
	}
	return false;
}
//About helping function of dragDropBox()----------------------------------------------------------------------------------------------------------------



//mode has two options. one of them is 'drag' and rest of them is 'drop'
//'drag' mode is for checking candidate
//'drop' mode is for calculating
function dragDropBox(mode, myQuestion, myQuestionIndex, myDragSource, myDropTarget){
	//index of a dragged source box


	myDropTarget.rules = [];
	var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);

	//if a dragged source is a operator
	if(isOperator(myDragSource.key)){
		//make before number or after number of the operator a source    ex)(3-4)*5
		if(myQuestion[dragSourceBoxIndex-1].key == ")"){
			dragSourceBoxIndex++;
		}else{
			dragSourceBoxIndex--;
		}
		myDragSource = myQuestion[dragSourceBoxIndex];
	}

	var syntax = parser.parse(myQuestion);	//get syntax from parser

	//type == 'operator' or 'parenthesis' or ''number'
	var dragSourceType = checkKeyType(myDragSource.key);
	var dropTargetType = checkKeyType(myDropTarget.key);

	//If user drags one Number(N1) onto one Operator(O1)
	if(dragSourceType == 'number' && dropTargetType == 'operator'){

		function getNumerator(fraction){
			var divisionIndex = 0;
			var numerator = "";

			for (var i=0; i < fraction.length; i++) {
				if(fraction.charAt(i) == '/'){
					divisionIndex = i;
					break;
				}
			}

			for (var i=0; i < divisionIndex; i++) {
				numerator += fraction.charAt(i);
			}

			numerator = parseFloat(numerator);
			return numerator;
		}

		function getDenominator(fraction){
			var divisionIndex = 0;
			var denominator = "";

			for (var i=0; i < fraction.length; i++) {
				if(fraction.charAt(i) == '/'){
					divisionIndex = i;
					break;
				}
			}

			for (var i=divisionIndex+1; i < fraction.length; i++) {
				denominator += fraction.charAt(i);
			}

			denominator = parseFloat(denominator);
			return denominator;
		}

		function getGreatestCommonDenominator(x,y) {
			function small(x,y) {
				if(x<y)
					return x;
				else
					return y;
			}

			var res = 1;
			var s = small(x,y);
			for(var i=1; i<=s; i++) {
				if((x%i)==0 && (y%i) == 0){
					res=i;
				}
			}
			return res;
		}

		//calculate
		function calculate(myQuestion, myDragSource, myDropTarget, left, operator, right){

			var result = "";
			var leftNumerator;
			var leftDenominator;
			var rightNumerator;
			var rightDenominator;

			if(isFraction(left)){
				leftNumerator = getNumerator(left);
				leftDenominator = getDenominator(left);
			}else{
				leftNumerator = parseFloat(left);
				leftDenominator = 1;
			}

			if(isFraction(right)){
				rightNumerator = getNumerator(right);
				rightDenominator = getDenominator(right);
			}else{
				rightNumerator = parseFloat(right);
				rightDenominator = 1;
			}

			var numerator;
			var denominator;
			if(operator == '+'){
				numerator = leftNumerator * rightDenominator + rightNumerator * leftDenominator;
				denominator = leftDenominator * rightDenominator;
			}else if(operator == '-'){
				numerator = leftNumerator * rightDenominator - rightNumerator * leftDenominator;
				denominator = leftDenominator * rightDenominator;
			}else if(operator == '*'){
				numerator = leftNumerator * rightNumerator;
				denominator = leftDenominator * rightDenominator;
			}else if(operator == '/'){
				numerator = leftNumerator * rightDenominator;
				denominator = leftDenominator * rightNumerator;
			}

			greatestCommonDenominator = getGreatestCommonDenominator(numerator, denominator);
			numerator = numerator / greatestCommonDenominator;
			denominator = denominator / greatestCommonDenominator;

			if(denominator < 0){
				numerator = -numerator;
				denominator = -denominator;
			}

			if(denominator == 1){
				result = numerator.toString();
			}else if(numerator == 0){
				result = "0"
			}else{
				result = numerator + "/" + denominator;
			}

			var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
			var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

			myDragSource.key = result;

			//remove unnecessary boxes after calulating
			if(dragSourceBoxIndex < dropTargetBoxIndex){
	        	myQuestion.splice(dragSourceBoxIndex+1, 2);
	        }else{
	        	myQuestion.splice(dragSourceBoxIndex-2, 2);
	        }

			//if there are just one box inside parenthesis, remove parenthesis
			var resultBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
			if(resultBoxIndex != 0 && myQuestion[resultBoxIndex-1].key == "(" && myQuestion[resultBoxIndex+1].key == ")"){
				myQuestion.splice(resultBoxIndex+1, 1);
				myQuestion.splice(resultBoxIndex-1, 1);
			}
		}

		/*
		Rule ID ("Rule_R1-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), HasChild(B1.L, N2), HasChild(RChild(B1), N3),
		        Equal(O1, B1.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [B1.L.n.k] and [B1.R.n.k].)

		Example
		3/*+-4 or +-3+-4 or /*+-3/*4 or /*+-3/*4+-
		drag '3' or '4' and drop on 'operator' between '3' and '4'
		*/

		/*
		Rule ID ("Rule_W1-1-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), HasChild(B1.L, N2), HasChild(RChild(B1), N3),
		        !Equal(O1, B1.o) )
		THEN Write(You must first simplify [B1.L.n.k][B1.o.k][B1.R.n.k] before continuing.)

		Example
		3/*+-4 or +-3+-4 or /*+-3/*4 or /*+-3/*4+-
		drag '3' or '4' and drop on 'operator' which is not between '3' and '4'
		*/

		/*
		Rule ID ("Rule_R1-2")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {*, /}),
		        Equal(O1, B1.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [N2.k].)

		Example
		3/*4/* or /*+-3/*4/*
		drag '3' and drop on 'operator' between '3'
		*/

		/*
		Rule ID ("Rule_W1-2-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {*, /}),
		        !Equal(O1, B1.o) )
		THEN Write(You must first simplify [N1.k][B1.o.k][B2.L.n.k] before continuing.)

		Example
		3/*4/* or /*+-3/*4/*
		drag '3' and drop on 'operator' which is not between '3' and '4'
		*/

		/*
		Rule ID ("Rule_R1-3")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {+, -}),
		        Equal(O1, B1.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [N2.k].)

		Example
		3+-4+- or +-3+-4+-
		drag '3' and drop on 'operator' between '3' and '4'
		*/

		/*
		Rule ID ("Rule_W1-3-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        HasChild(B1.R, B2), HasChild(B2.L, N2), Equal(B1.o.k, {+, -}),
		        !Equal(O1, B1.o) )
		THEN Write(You must first simplify [N1.k][B1.o.k][B2.L.n.k] before continuing.)

		Example
		3+-4+- or +-3+-4+-
		drag '3' and drop on 'operator' between '3' and '4'
		*/

		/*
		Rule ID ("Rule_R4-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        Equal(B1.o.k, *), Include(B1.R, P1),
		        Equal(O1, B1.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [N1.k] and [P1-subtree].)

		Example
		/*+-2*(3+-4)/*+-
		drag '2' and drop on 'operator' between '2' and '(3+-4)'
		*/


		/*
		Rule ID ("Rule_W4-1-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        Equal(B1.o.k, *), Include(B1.R, P1),
		        !Equal(O1, B1.o) )
		THEN Write(You must first simplify [N1.k][B1.o.k][P1-subtree] before continuing.)

		Example
		/*+-2*(3+-4)/*+-
		drag '2' and drop on 'operator' between '2' and '(3+-4)'
		*/

		/*
		Rule ID ("Rule_W4-1-2")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1), !HasChild(B1.R, N3),
		        Or( And(HasChild(B1.R, P1), !Equal(B1.o, *)),
		            And(HasChild(B1.R, B2), HasChild(B2.L, P1), !Equal(B1.o, *)) ),
		        Equal(O1, B1.o) )
		THEN Write([O1.k] between [N1] and [P1-subtree] must be * for distribution.)

		Example
		2/+-(3+-4) or 2/+-(3+-4)+- or +-2/+-(3+-4) or +-2/+-(3+-4)+- or /*2/(3+-4)/*+-
		drag '2' and drop on 'operator' between '2' and '(3+-4)'
		*/

		/*
		Rule ID ("Rule_W4-1-3")

		Rule
		IF And( Drag(N1,O1),
		        Or( And(Equal(B1.o.k, {*, /}), HasChild(B2.R, P1)),
				    And(Equal(B1.o.k, {*, /}), HasChild(B2.R, B3), HasChild(B3.L, P1)),
				    And(Equal(B1.o.k, {*, /}), HasChild(B2.R, B3), HasChild(B3.L, B4), HasChild(B3.L, P1)) ),
		        Equal(O1, B2.o) )
		THEN Write([O1.k] between [N1] and [P1-subtree] must be * for distribution.)

		Example
		/*2+-(3+-4) or /*2+-(3+-4)/*+-
		drag '2' and drop on 'operator' between '2' and '(3+-4)'
		*/

		var number1 = myDragSource;
		var operator1 = myDropTarget;
		var parentOfParentOfNumber1 = findParentNode(syntax, findParentNode(syntax, number1));

		//Rule1-1, Rule1-2, Rule1-3 or Rule4-1
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Left'].hasOwnProperty('number') && parentOfParentOfNumber1['Right'].hasOwnProperty('number')){
			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

			//Rule_R1-1
			if(operator1 === binary1['operator']){
				myDropTarget.rules = [];
				myDropTarget.rules.push("R_R1-1");
				if(mode == "drag"){
					myDropTarget.isCandidate = true;
					myDropTarget.isRightRule = true;
					return;
				}else if(mode == "drop"){

					tempQuestion = getCloneQuestion(myQuestion);
					var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
					var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

					if(operator1.key == '*' || operator1.key == '/'){
						rightDropMessage = "Right!\nYou simplified the expression by " + getOperatoString(operator1.key) + "ing " + binary1['Left']['number'].key + " with " + binary1['Right']['number'].key;

						calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], binary1['Left']['number'].key, operator1.key, binary1['Right']['number'].key);

						if(dragSourceBoxIndex < dropTargetBoxIndex){
							myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
							myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
							myQuestion[dragSourceBoxIndex+1].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

							var questionLength = myQuestion.length;
							for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
								myQuestion[i].animationType = 'linearMotion';
								myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
								myQuestion[i].destinationY = myQuestion[i].y;
								myQuestion[i].isAnimating = true;
								setAnimationAceleration(myQuestion[i]);
							}
						}else{
							myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
							myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
							myQuestion[dragSourceBoxIndex-1].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

							myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
							myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
							myQuestion[dragSourceBoxIndex].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

							var questionLength = myQuestion.length;
							for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
								myQuestion[i].animationType = 'linearMotion';
								myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
								myQuestion[i].destinationY = myQuestion[i].y;
								myQuestion[i].isAnimating = true;
								setAnimationAceleration(myQuestion[i]);
							}
						}

						return;
					}else{

						var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));
						var operatorOfNumber1;

						if(parentOfParentOfBinary1 == 'Binary'){
							operatorOfNumber1 = parentOfParentOfBinary1['operator'].key;
						}else{
							operatorOfNumber1 = '+';
						}

						if(operatorOfNumber1 == binary1['operator'].key){

							rightDropMessage = "Right!\nYou simplified the expression by " + "adding " + binary1['Left']['number'].key + " with " + binary1['Right']['number'].key + ".";

							calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], binary1['Left']['number'].key, '+', binary1['Right']['number'].key);

							if(dragSourceBoxIndex < dropTargetBoxIndex){
								myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
								myQuestion[dragSourceBoxIndex+1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}
							}else{
								myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
								myQuestion[dragSourceBoxIndex-1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}
							}

							return;
						}else{
							if(operatorOfNumber1 == '+'){

								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + binary1['Left']['number'].key + " with " + binary1['Right']['number'].key + ".";

								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], binary1['Left']['number'].key, '-', binary1['Right']['number'].key);

								if(dragSourceBoxIndex < dropTargetBoxIndex){
									myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
									myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
									myQuestion[dragSourceBoxIndex+1].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

									var questionLength = myQuestion.length;
									for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}
								}else{
									myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
									myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
									myQuestion[dragSourceBoxIndex-1].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

									myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
									myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
									myQuestion[dragSourceBoxIndex].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

									var questionLength = myQuestion.length;
									for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}
								}

								return;

							}else if(operatorOfNumber1 == '-'){

								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + binary1['Right']['number'].key + " with " + binary1['Left']['number'].key + ".";

								parentOfParentOfBinary1['operator'].key = '+';
								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], binary1['Right']['number'].key, '-', binary1['Left']['number'].key);

								if(dragSourceBoxIndex < dropTargetBoxIndex){
									myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
									myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
									myQuestion[dragSourceBoxIndex+1].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

									var questionLength = myQuestion.length;
									for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}
								}else{
									myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
									myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
									myQuestion[dragSourceBoxIndex-1].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

									myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
									myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
									myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
									myQuestion[dragSourceBoxIndex].isAnimating = true;
									setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

									var questionLength = myQuestion.length;
									for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}
								}

								return;
							}
						}
					}
				}
			}
			//Rule_W1-1-1
			else{
				myDropTarget.rules.push("R_W1-1-1");
				if(mode == "drag"){
					myDropTarget.isCandidate = true;
					myDropTarget.isRightRule = false;
				}else if(mode == "drop"){
					wrongDropMessages.push("You must first simplify " + binary1['Left']['number'].key + binary1['operator'].key + binary1['Right']['number'].key + " before continuing.");
				}
			}
		}

		//Rule1-2, Rule1-4 or Rule1-3
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Left']['number'] == number1 && !parentOfParentOfNumber1['Right'].hasOwnProperty('number')){
			var binary1 = parentOfParentOfNumber1;
			//Rule1-2
			if( binary1['Right'].hasOwnProperty('Binary') && binary1['Right']['Binary']['Left'].hasOwnProperty('number') && (binary1['operator'].key == '*' || binary1['operator'].key == '/')){
				var binary2 = binary1['Right']['Binary'];
				var number2 = binary2['Left']['number'];
				var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));

				//Rule_R1-2
				if(operator1 === binary1['operator']){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R1-2");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;
					}else if(mode == "drop"){
						rightDropMessage = "Right!\nYou simplified the expression by " + getOperatoString(operator1.key) + "ing " + number1.key + " with " + number2.key + ".";

						tempQuestion = getCloneQuestion(myQuestion);
						var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
						var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

						calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number1.key, operator1.key, number2.key);

						myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
						myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
						myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
						myQuestion[dragSourceBoxIndex+1].isAnimating = true;
						setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

						var questionLength = myQuestion.length;
						for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
							myQuestion[i].animationType = 'linearMotion';
							myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
							myQuestion[i].destinationY = myQuestion[i].y;
							myQuestion[i].isAnimating = true;
							setAnimationAceleration(myQuestion[i]);
						}

						return;
					}
				}
				//Rule_W1-2-1
				else{
					myDropTarget.rules.push("R_W1-2-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						wrongDropMessages.push("You must first simplify " + number1.key + binary1['operator'].key + number2.key + " before continuing.");
					}
				}
			}

			//Rule1-3
			if( binary1['Right'].hasOwnProperty('Binary') && binary1['Right']['Binary']['Left'].hasOwnProperty('number') && ( binary1['Right']['Binary']['operator'].key == '+' || binary1['Right']['Binary']['operator'].key == '-')){
				var binary2 = binary1['Right']['Binary'];
				var number2 = binary2['Left']['number'];
				var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));

				//Rule_R1-3
				if(operator1 === binary1['operator']){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R1-3");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;

					}else if(mode == "drop"){
						var number2 = binary2['Left']['number'];
						var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));
						var operatorOfNumber1;

						if(parentOfParentOfBinary1 == 'Binary'){
							operatorOfNumber1 = parentOfParentOfBinary1['operator'].key;
						}else{
							operatorOfNumber1 = '+';
						}

						tempQuestion = getCloneQuestion(myQuestion);
						var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
						var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

						if(operatorOfNumber1 == binary1['operator'].key){
							rightDropMessage = "Right!\nYou simplified the expression by " + "adding " + number1.key + " with " + number2.key + ".";

							calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number1.key, '+', number2.key);

							myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
							myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
							myQuestion[dragSourceBoxIndex+1].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

							var questionLength = myQuestion.length;
							for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
								myQuestion[i].animationType = 'linearMotion';
								myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
								myQuestion[i].destinationY = myQuestion[i].y;
								myQuestion[i].isAnimating = true;
								setAnimationAceleration(myQuestion[i]);
							}

							return;
						}else{
							if(operatorOfNumber1 == '+'){
								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + number1.key + " with " + number2.key + ".";
								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number1.key, '-', number2.key);

								myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
								myQuestion[dragSourceBoxIndex+1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;

							}else if(operatorOfNumber1 == '-'){
								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + number2.key + " with " + number1.key + ".";
								parentOfParentOfBinary1['operator'].key = '+';
								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number2.key, '-', number1.key);

								myQuestion[dragSourceBoxIndex+1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex+1].destinationX = myQuestion[dragSourceBoxIndex+1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex+1].destinationY = myQuestion[dragSourceBoxIndex+1].y;
								myQuestion[dragSourceBoxIndex+1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex+1]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
					}
				}
				//Rule_W1-3-1
				else{
					myDropTarget.rules.push("R_W1-3-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						wrongDropMessages.push("You must first simplify " + number1.key + binary1['operator'].key + number2.key + " before continuing.");
					}

				}

			}

			//Rule4-1
			var parenthesis1 = findParenthesis(binary1['Right']);
			if((binary1['operator'].key == '*' || binary1['operator'].key == '/') && typeof parenthesis1 != 'undefined'){
				var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));
				//Rule_R4-1
				if(operator1 === binary1['operator']){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R4-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;
					}else if(mode == "drop"){
						rightDropMessage = "Right!\nYou simplified the expression by " + getOperatoString(operator1.key) + "ing " + number1.key + " with " + parseSubtreeToString(parenthesis1) + ".";

						var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box
						var mainOperandIndex = dropTargetBoxIndex-1; // index of 3  ex)3*(4+5)

						var openParenthesisIndex = dropTargetBoxIndex + 1; // index of (
						var closeParenthesisIndex = getCloseParenthesisIndex(boxes, myQuestionIndex, openParenthesisIndex); // index of )


						var insertionIndexes = [];

						//figure out to what index 3* is inserted  ex)3*(4+5)
						insertionIndexes.push(openParenthesisIndex);
						for(var i = openParenthesisIndex; i < closeParenthesisIndex ; i++){
							 if(myQuestion[i].key == '+' || myQuestion[i].key == '-' ){
								 insertionIndexes.push(i);
							 }
						}

						tempQuestion = getCloneQuestion(myQuestion);

						var mainOperandBox = tempQuestion[mainOperandIndex]; // box having key3  ex)3*(4+5)
						var mainOperatorBox = tempQuestion[dropTargetBoxIndex];// box havning key*  ex)3*(4+5)

						for(var i = insertionIndexes.length-1 ; 0 <= i; i--){
							// ex)3*(4+5) = (3*4+3*5)
							tempQuestion.splice(insertionIndexes[i]+1,0, getCloneBox(mainOperandBox), getCloneBox(mainOperatorBox));

						}

						tempQuestion.splice(mainOperandIndex,2); //remove 3*  ex)3*(4+5)

						alignBox(myQuestionIndex);

						var questionLength = myQuestion.length;


						myQuestion[openParenthesisIndex].animationType = 'linearMotion';
						myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex].x - (2*(BOX_WIDTH+GAP));
						myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex].y;
						myQuestion[openParenthesisIndex].isAnimating = true;
						setAnimationAceleration(myQuestion[openParenthesisIndex]);

						for(var i = 0; i <insertionIndexes.length; i++){

							if(i==0){
								setArcAnimation(myQuestion,'1ArcForward', mainOperandIndex);
								setArcAnimation(myQuestion,'1ArcForward', dropTargetBoxIndex);
							}else{
								var mainOperandClone = getCloneBox(myQuestion[mainOperandIndex]);
								var mainOperatorClone = getCloneBox(myQuestion[dropTargetBoxIndex]);
								myQuestion.push(mainOperandClone);
								myQuestion.push(mainOperatorClone);
								setArcAnimation(myQuestion, (1+(insertionIndexes[i]-openParenthesisIndex)+(i*2))+'ArcForward', myQuestion.length-2);
								setArcAnimation(myQuestion, (1+(insertionIndexes[i]-openParenthesisIndex)+(i*2))+'ArcForward', myQuestion.length-1);

								for(var j = insertionIndexes[i]+1; j<closeParenthesisIndex; j++){
									myQuestion[j].animationType = 'linearMotion';
									myQuestion[j].destinationX = myQuestion[j].x + ((2*(BOX_WIDTH+GAP))*i);
									myQuestion[j].destinationY = myQuestion[j].y;
									myQuestion[j].isAnimating = true;
									setAnimationAceleration(myQuestion[j]);
								}
							}
						}

						for(var i=closeParenthesisIndex; i<questionLength; i++){
							myQuestion[i].animationType = 'linearMotion';
							myQuestion[i].destinationX = myQuestion[i].x + ((2*(BOX_WIDTH+GAP))*(insertionIndexes.length-1));
							myQuestion[i].destinationY = myQuestion[i].y;
							myQuestion[i].isAnimating = true;
							setAnimationAceleration(myQuestion[i]);
						}

						return;
					}
				}
				//Rule_W4-1-1
				else{
					myDropTarget.rules.push("R_W4-1-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						wrongDropMessages.push("You must first simplify " + number1.key + binary1['operator'].key + parseSubtreeToString(parenthesis1) + " before continuing.");
					}
				}
			}

			//Rule_W4-1-2
			if( (binary1['Right'].hasOwnProperty('Parenthesis') && binary1['operator'].key != '*' && binary1['operator'].key != '/')
				|| (binary1['Right'].hasOwnProperty('Binary') && binary1['Right']['Binary']['Left'].hasOwnProperty('Parenthesis') && binary1['operator'].key != '*' && binary1['operator'].key != '/') ){

				if(operator1 === binary1['operator']){
					myDropTarget.rules.push("R_W4-1-2");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						var parenthesis1;
						if(binary1['Right'].hasOwnProperty('Parenthesis')){
							parenthesis1 = binary1['Right']['Parenthesis'];
						}else{
							parenthesis1 = binary1['Right']['Binary']['Left']['Parenthesis'];
						}

						wrongDropMessages.push(operator1.key+ " between " + number1.key + " and " + parseSubtreeToString(parenthesis1) + " must be * for distribution.");
					}
				}
			}

		}

		//Rule_W4-1-3
		var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, number1);
		if(parentOfParentOfNumber1 == 'Binary' && binaryHavingOperatorPlusOrMinus == 'Binary'){
			var binary1 = parentOfParentOfNumber1;
			var binary2 = binaryHavingOperatorPlusOrMinus;

			if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right'].hasOwnProperty('Parenthesis'))
				|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right'].hasOwnProperty('Binary') && binary2['Right']['Binary']['Left'].hasOwnProperty('Parenthesis'))
				|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right'].hasOwnProperty('Binary') && binary2['Right']['Binary']['Left'].hasOwnProperty('Binary') && binary2['Right']['Binary']['Left']['Binary']['Left'].hasOwnProperty('Parenthesis')) ){

				if(operator1 === binary2['operator']){
					myDropTarget.rules.push("R_W4-1-3");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						var parenthesis1;
						if(binary2['Right'].hasOwnProperty('Parenthesis')){
							parenthesis1 = binary2['Right']['Parenthesis'];
						}else if(binary2['Right']['Binary']['Left'].hasOwnProperty('Parenthesis')){
							parenthesis1 = binary2['Right']['Binary']['Left']['Parenthesis'];
						}else if(binary2['Right']['Binary']['Left']['Binary']['Left'].hasOwnProperty('Parenthesis')){
							parenthesis1 = binary2['Right']['Binary']['Left']['Binary']['Left']['Parenthesis'];
						}

						wrongDropMessages.push(operator1.key+ " between " + number1.key + " and " + parseSubtreeToString(parenthesis1) + " must be * for distribution.");
					}
				}
			}
		}

		/*
		Rule ID ("Rule_R4-2")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1),
				Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), Equal(B2.o.k, *)),
				    And(Equal(B1.R.n, N1), HasChild(B1.L, P1), Equal(B1.o.k, *)) ),
				And(Equal(GParent(P1), B3), Equal(B3.o, O1)) )
		THEN Write(You simplified the expression by [O1]ing [P1-subtree] and [N1.k].)

		Example
		/*+-(3+-4)*5/*+-
		drag '5' and drop on 'operator' between '(3+-4)' and '5'
		*/

		/*
		Rule ID ("Rule_W4-2-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1),
				Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), Equal(B2.o.k, *)),
				    And(Equal(B1.R.n, N1), HasChild(B1.L, P1), Equal(B1.o.k, *)) ),
				And(Equal(GParent(P1), B3), !Equal(B3.o, O1)) )
		THEN Write(You must first simplify [P1-subtree][B1.o.k][N1.k] before continuing.)

		Example
		/*+-(3+-4)*5/*+-
		drag '5' and drop on 'operator' which is not between '(3+-4)' and '5'
		*/

		/*
		Rule ID ("W4-2-2")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1),
				Or( And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), HasChild(B2.L, P1), !Equal(B2.o.k, *), Equal(B2.o, O1)),
				    And(Equal(B1.L.n, N1), Equal(GParent(B1), B2), Include(B2.L, P1), Equal(Parent(P1), R), !Equal(B2.o.k, *), Equal(B2.o, O1)),
					And(Equal(B1.R.n, N1), HasChild(B1.L, P1), !Equal(B1.o.k, *), Equal(B1.o, O1)),
					And(Equal(B1.R.n, N1), Include(B1.L, P1), Equal(Parent(P1), R), !Equal(B1.o.k, *), Equal(B1.o, O1)) ),
		        And(Equal(GParent(P1), B3), Equal(B3.o, O1)) )
		THEN Write([O1.k] between [P1-subtree] and [N1.k] must be * for distribution.)

		Example
		(3+-4)/+-5 or /*+-(3+-4)/+-5 or (3+-4)/+-5/*+- or +-(3+-4)/+-5/*+-
		drag '5' and drop on 'operator' between '(3+-4)' and '5'
		*/

		//Rule4-2
		if(parentOfParentOfNumber1 == 'Binary'){

			var binary1 = parentOfParentOfNumber1;
			var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));

			if(  (binary1['Left']['number'] == number1 && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left'].hasOwnProperty('Parenthesis') && (parentOfParentOfBinary1['operator'].key == '*' || parentOfParentOfBinary1['operator'].key == '/'))
				|| (binary1['Right']['number'] == number1 && binary1['Left'].hasOwnProperty('Parenthesis') && (binary1['operator'].key == '*' || binary1['operator'].key == '/')) ){
				var binary2 = parentOfParentOfBinary1;
				var parenthesis1;

				if( binary1['Left'].hasOwnProperty('Parenthesis')){
					parenthesis1 = binary1['Left']['Parenthesis'];
				}else{
					parenthesis1 = binary2['Left']['Parenthesis'];
				}

				var parentOfParentOfParenthesis1 = findParentNode(syntax, findParentNode(syntax, parenthesis1));

				//Rule_R4-2
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['operator'] === operator1){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R4-2");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;
					}else if(mode == "drop"){

						rightDropMessage = "Right!\nYou simplified the expression by " + getOperatoString(operator1.key) + "ing " + parseSubtreeToString(parenthesis1) + " with " + number1.key + ".";

						if(typeof parenthesis1 != 'undefined'){
							var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box
							var mainOperandIndex = dropTargetBoxIndex+1; // index of 3  ex)(4+5)*3



							var closeParenthesisIndex = dropTargetBoxIndex - 1; // index of )
							var openParenthesisIndex = getOpenParenthesisIndex(boxes, myQuestionIndex, closeParenthesisIndex); // index of (

							var insertionIndexes = [];

							//figure out to what index *3 is inserted  ex)(4+5)*3

							for(var i = openParenthesisIndex; i < closeParenthesisIndex ; i++){
								if(myQuestion[i].key == '+' || myQuestion[i].key == '-' ){
									insertionIndexes.push(i);
								}
							}

							insertionIndexes.push(closeParenthesisIndex);

							tempQuestion = getCloneQuestion(myQuestion);

							var mainOperandBox = tempQuestion[mainOperandIndex]; // box having key3  ex)(4+5)*3
							var mainOperatorBox = tempQuestion[dropTargetBoxIndex];// box havning key*  ex)(4+5)*3

							tempQuestion.splice(dropTargetBoxIndex,2); //remove *3  ex)(4+5)*3

							for(var i = insertionIndexes.length-1; i >= 0; i--){
								tempQuestion.splice(insertionIndexes[i], 0, getCloneBox(mainOperatorBox),getCloneBox(mainOperandBox));
							}

							alignBox(myQuestionIndex);

							var questionLength = myQuestion.length;

							for(var i = 0; i <insertionIndexes.length; i++){

								if(i != insertionIndexes.length-1){
									var mainOperandClone = getCloneBox(myQuestion[mainOperandIndex]);
									var mainOperatorClone = getCloneBox(myQuestion[dropTargetBoxIndex]);
									myQuestion.push(mainOperatorClone);
									myQuestion.push(mainOperandClone);

									var movingLevel = (dropTargetBoxIndex - insertionIndexes[i])-(i*2);

									if(movingLevel > 0){
										setArcAnimation(myQuestion, (movingLevel)+'ArcBackward', myQuestion.length-1);
										setArcAnimation(myQuestion, (movingLevel)+'ArcBackward', myQuestion.length-2);

									}else{
										setArcAnimation(myQuestion, (-movingLevel)+'ArcForward', myQuestion.length-1);
										setArcAnimation(myQuestion, (-movingLevel)+'ArcForward', myQuestion.length-2);
									}
								}else{

									var movingLevel = (dropTargetBoxIndex - insertionIndexes[i])-(i*2);

									if(movingLevel > 0){
										setArcAnimation(myQuestion, (movingLevel)+'ArcBackward', dropTargetBoxIndex);
										setArcAnimation(myQuestion, (movingLevel)+'ArcBackward', mainOperandIndex);
									}else{
										setArcAnimation(myQuestion, (-movingLevel)+'ArcForward', dropTargetBoxIndex);
										setArcAnimation(myQuestion, (-movingLevel)+'ArcForward', mainOperandIndex);
									}
								}

								for(var j = insertionIndexes[i]; j<=closeParenthesisIndex; j++){

									myQuestion[j].animationType = 'linearMotion';
									myQuestion[j].destinationX = myQuestion[j].x + ((2*(BOX_WIDTH+GAP))*(i+1));
									myQuestion[j].destinationY = myQuestion[j].y;
									myQuestion[j].isAnimating = true;
									setAnimationAceleration(myQuestion[j]);
								}

							}


							for(var i=closeParenthesisIndex+3; i<questionLength; i++){
								myQuestion[i].animationType = 'linearMotion';



								myQuestion[i].destinationX = myQuestion[i].x + ((2*(BOX_WIDTH+GAP))*(insertionIndexes.length-1));
								myQuestion[i].destinationY = myQuestion[i].y;
								myQuestion[i].isAnimating = true;
								setAnimationAceleration(myQuestion[i]);
							}



							return;
						}
					}
				}
				//Rule_W4-2-1
				else if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['operator'] !== operator1){
					myDropTarget.rules.push("R_W4-2-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;
					}else if(mode == "drop"){
						wrongDropMessages.push("You must first simplify " + parseSubtreeToString(parenthesis1) + binary1['operator'].key + number1.key + " before continuing.");
					}
				}
			}


			var tempParenthesis1 = 	findParenthesis(parentOfParentOfBinary1['Left']);
			var parentOfTempParenthesis1 = findParentNode(syntax, tempParenthesis1);
			var tempParenthesis2 = 	findParenthesis(binary1['Left']);
			var parentOfTempParenthesis2 = findParentNode(syntax, tempParenthesis2);

			//Rule_W4-2-2
			if(  (binary1['Left']['number'] == number1 && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left'].hasOwnProperty('Parenthesis') && parentOfParentOfBinary1['operator'].key != '*' && parentOfParentOfBinary1['operator'].key != '/' && parentOfParentOfBinary1['operator'] === operator1)
				|| (binary1['Left']['number'] == number1 && parentOfParentOfBinary1 == 'Binary' && typeof tempParenthesis1 != 'undefined' && parentOfTempParenthesis1 == 'Right' && parentOfParentOfBinary1['operator'].key != '*' && parentOfParentOfBinary1['operator'].key != '/' && parentOfParentOfBinary1['operator'] === operator1)
				|| (binary1['Right']['number'] == number1 && binary1['Left'].hasOwnProperty('Parenthesis') && binary1['operator'].key != '*' && binary1['operator'].key != '/'  &&  binary1['operator'] === operator1)
				|| (binary1['Right']['number'] == number1 && typeof tempParenthesis2 != 'undefined' && parentOfTempParenthesis2 == 'Right' && binary1['operator'].key != '*' && binary1['operator'].key != '/' &&  binary1['operator'] === operator1) ){

				var binary2 = parentOfParentOfBinary1;
				var parenthesis1;

				if(typeof tempParenthesis1 != 'undefined'){
					parenthesis1 = tempParenthesis1;
				}else if(typeof tempParenthesis2 != 'undefined'){
					parenthesis1 = tempParenthesis2;
				}else if(binary1['Left'].hasOwnProperty('Parenthesis')){
					parenthesis1 = binary1['Left']['Parenthesis'];
				}else if(binary2['Left'].hasOwnProperty('Parenthesis')){
					parenthesis1 = binary2['Left']['Parenthesis'];
				}

				myDropTarget.rules.push("R_W4-2-2");
				if(mode == "drag"){
					myDropTarget.isCandidate = true;
					myDropTarget.isRightRule = false;
				}else if(mode == "drop"){
					wrongDropMessages.push(operator1.key + " between " + parseSubtreeToString(parenthesis1) + " and " + number1.key + " must be * for distribution.");
				}
			}
		}

		/*
		Rule ID ("Rule_R1-4")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B2.L, N2), Equal(B2.o.k, {*, /}),
				Equal(O1, B2.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [N2.k] and [N1.k].)

		Example
		3/*4/* or /*+-3/*4/*
		drag '4' and drop on 'operator' between '3' and '4'
		*/

		/*
		Rule ID ("Rule_W1-4-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B2.L, N2), Equal(B2.o.k, {*, /}),
				!Equal(O1, B2.o) )
		THEN Write(You must first simplify [N2.k][O1.k][N1.k] before continuing.)

		Example
		3/*4/* or /*+-3/*4/*
		drag '4' and drop on 'operator' which is not between '3' and '4'
		*/

		/*
		Rule ID ("Rule_R1-5")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B2.L, N2), !Equal(B2.o.k, {*, /}),
				Equal(O1, B2.o) )
		THEN Write(Right! You simplified the expression by [O1]ing [N2.k] and [N1.k].)

		Example
		3+-4+- or +-3+-4+-
		drag '4' and drop on 'operator' between '3' and '4'
		*/

		/*
		Rule ID ("Rule_W1-5-1")

		Rule
		IF And( Drag(N1,O1),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B2.L, N2), !Equal(B2.o.k, {*, /}),
				!Equal(O1, B2.o) )
		THEN Write(You must first simplify [N2.k][O1.k][N1.k] before continuing.)

		Example
		3+-4+- or +-3+-4+-
		drag '4' and drop on 'operator' which is not between '3' and '4'
		*/

		//Rule1-4 or Rule1-5
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Left']['number'] === number1){
			var binary1 = parentOfParentOfNumber1;
			var parentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, binary1));

			//Rule1-4
			if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left'].hasOwnProperty('number') && (parentOfParentOfBinary1['operator'].key == '*' || parentOfParentOfBinary1['operator'].key == '/')){
				var binary2 = parentOfParentOfBinary1;

				//Rule_R1-4
				if(operator1 === binary2['operator']){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R1-4");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;

					}else if(mode == "drop"){
						var number2 = parentOfParentOfBinary1['Left']['number'];

						rightDropMessage = "Right!\nYou simplified the expression by " + getOperatoString(operator1.key) + "ing " + number2.key + " with " + number1.key + ".";

						tempQuestion = getCloneQuestion(myQuestion);
						var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
						var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

						calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number2.key, operator1.key, number1.key);

						myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
						myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
						myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
						myQuestion[dragSourceBoxIndex-1].isAnimating = true;
						setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

						myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
						myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
						myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
						myQuestion[dragSourceBoxIndex].isAnimating = true;
						setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

						var questionLength = myQuestion.length;
						for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
							myQuestion[i].animationType = 'linearMotion';
							myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
							myQuestion[i].destinationY = myQuestion[i].y;
							myQuestion[i].isAnimating = true;
							setAnimationAceleration(myQuestion[i]);
						}

						return;
					}
				}
				//Rule_W1-4-1
				else{
					myDropTarget.rules.push("R_W1-4-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						var number2 = parentOfParentOfBinary1['Left']['number'];
						wrongDropMessages.push("You must first simplify " + number2.key + operator1.key + number1.key + " before continuing.");
					}
				}
			}

			//Rule1-5
			if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left'].hasOwnProperty('number') && (binary1['operator'].key != '*' && binary1['operator'].key != '/')){
				var binary2 = parentOfParentOfBinary1;

				//Rule_R1-5
				if(operator1 === binary2['operator']){
					myDropTarget.rules = [];
					myDropTarget.rules.push("R_R1-5");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = true;
						return;

					}else if(mode == "drop"){

						var number2 = parentOfParentOfBinary1['Left']['number'];
						var parentOfParentOfBinary2 = findParentNode(syntax, findParentNode(syntax, binary2));
						var operatorOfNumber3;

						if(parentOfParentOfBinary2 == 'Binary'){
							operatorOfNumber3 = parentOfParentOfBinary2['operator'].key;
						}else{
							operatorOfNumber3 = '+';
						}

						tempQuestion = getCloneQuestion(myQuestion);
						var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
						var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);


						if(operatorOfNumber3 == binary2['operator'].key){
							rightDropMessage = "Right!\nYou simplified the expression by " + "adding " + number2.key + " with " + number1.key + ".";

							calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number2.key, '+', number1.key);

							myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
							myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
							myQuestion[dragSourceBoxIndex-1].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

							myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
							myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
							myQuestion[dragSourceBoxIndex].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

							var questionLength = myQuestion.length;
							for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
								myQuestion[i].animationType = 'linearMotion';
								myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
								myQuestion[i].destinationY = myQuestion[i].y;
								myQuestion[i].isAnimating = true;
								setAnimationAceleration(myQuestion[i]);
							}


							return;
						}else{
							if(operatorOfNumber3 == '+'){
								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + number2.key + " with " + number1.key + ".";

								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number2.key, '-', number1.key);

								myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
								myQuestion[dragSourceBoxIndex-1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}else if(operatorOfNumber3 == '-'){
								rightDropMessage = "Right!\nYou simplified the expression by " + "substracting " + number1.key + " with " + number2.key + ".";

								parentOfParentOfBinary2['operator'].key = '+'
								calculate(tempQuestion, tempQuestion[dragSourceBoxIndex], tempQuestion[dropTargetBoxIndex], number1.key, '-', number2.key);

								myQuestion[dragSourceBoxIndex-1].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex-1].destinationX = myQuestion[dragSourceBoxIndex-1].x - (BOX_WIDTH+GAP);
								myQuestion[dragSourceBoxIndex-1].destinationY = myQuestion[dragSourceBoxIndex-1].y;
								myQuestion[dragSourceBoxIndex-1].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex-1]);

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dragSourceBoxIndex-2].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dragSourceBoxIndex-2].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								var questionLength = myQuestion.length;
								for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
					}
				}
				//Rule_W1-5-1
				else{
					myDropTarget.rules.push("R_W1-5-1");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						var number2 = parentOfParentOfBinary1['Left']['number'];
						wrongDropMessages.push("You must first simplify " + number2.key + operator1.key + number1.key + " before continuing.");
					}
				}
			}
		}
	}

	if(dragSourceType == 'number' && dropTargetType == 'number'){//If user drags one Number(N1) onto another Number(O2)
		/*
		Rule ID ("Rule_R2-1")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), HasChild(B1.R, N3)
				Or( And(Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
				    And(Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, -)),
					And(Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),
					Equal(B1.o.k, *) ),
				HasChild(B1.L.has(N4)),
				Equal(GParent(N1), GParent(N2)) )
		THEN Write(Right! [B2.o.k][B1.L.n.k][B1.o.k][B1.R.n.k] is commutative.)

		Example
		3*+4 or +3+4 or -3-4 or /*+-3*4
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-1-1")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), HasChild(B1.R, N3)
				Or( And(Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
				    And(Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, -)),
					And(Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),
					Equal(B1.o.k, *) ),
				HasChild(B1.L.has(N4)),
				!Equal(GParent(N1), GParent(N2)) )
		THEN Write(You can switch [B1.L.n.k] to [B1.R.n.k] in [B1.L.n.k][B1.o.k][B1.R.n.k] for commutation.)

		Example
		3*+4 or +3+4 or -3-4 or /*+-3*4
		drag '3' and drop on 'number' which is not '4' OR drag '4' and drop on 'number' which is not '3'
		*/

		/*
		Rule ID ("Rule_W2-1-2")

		Rule
		IF And( Drag(N1,N2),
				Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),
				Equal(B1.o.k, {/, -}), Equal(Parent(B1), {P, E}),
				Equal(GParent(N1), GParent(N2)) )
		THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)

		Example
		3/-4
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-1-3")

		Rule
		IF And( Drag(N1,N2),
				Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),
				Equal(B1.o.k, /), Equal(GParent(B1), B2), Equal(B2.o.k, {*, /}),
				Equal(GParent(N1), GParent(N2))
		THEN Write([B1.o.k] in [B1-subtree] must be * for commutation.)

		Example
		/*3/4 or /*3/4+-
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-1-4")

		Rule
		IF And( Drag(N1,N2),
				Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),
				Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -}), !Equal(B1.o.k, B2.o.k)),
				Equal(GParent(N1), GParent(N2)) )
		THEN Write([B1.o.k] in [B1-subtree] must be [B2.o.k] or * for commutation.)

		Example
		+3-4 or -3+4
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-1-5")

		Rule
		IF And( Drag(N1,N2),
				Equal(GParent(N1), B1), HasChild(B1.L, N3), HasChild(B1.L, N4),
				Or( And(Equal(B1.o.k, /), Equal(GParent(B1), B2), !Equal(B2.L.B, B1), Equal(B2.o.k, {+, -})),
				    And(Equal(B1.o.k, /), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})) ),
				Equal(GParent(N1), GParent(N2)) )
		THEN
			IF !Equal(B2.L.B, B1)
				Write([B1.o.k] in [B1-subtree] must be [B2.o.k] or * for commutation.)
			ELSE IF Equal(B2.L.B, B1)
				Write([B1.o.k] in [B1-subtree] must be [B3.o.k] or * for commutation.)

		Example
		+-3/4 or +-3/4+-
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-1-6")

		Rule
		IF And( Drag(N1,N2),
				Equal(GParent(N1), B1), HasChild(B1.R, N3),
				Or( And(Equal(B2.o.k, {+, -}), HasAncestor(N1, B2), Equal(B1.R, N4), Equal(B1.o.k, {*, /}), Equal(B2.o.k, {+, -}),
				    And(HasChild(B2.R, N4), Include(B1.L, B2), Equal(B2.o.k, {*, /}), Equal(B1.o.k, {+, -})) ),
				Equal(N1, B1.R.n), Equal(N2, B2.R.n)) )
		THEN
			IF Equal(B1.o.k, {*, /})
				Write([B1.o.k] before [B1.R.n.k] must be [B2.o.k] for commutation.)
				Write([B2.o.k] in [B1.R.n.k][B2.o.k][B2.R.n.k] must be * for commutation.)
			ELSE IF Equal(B1.o.k, {+, -})
				Write([B2.o.k] before [B2.o.k][B2.R.n.k] must be [B1.o.k] for commutation.)
				Write([B1.o.k] in [B2.R.n.k][B1.o.k][B1.R.n.k] must be * for commutation.)

		Example
		/*3+-4
		drag '3' and drop on '4' OR drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_R2-2")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Euqal(GParent(B1), B2)
				Or( And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
				    And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, -)),
					And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {P, E}),
					!Equal(B2.o.k, *) ),
				HasChild(B2.L, N3),
				Equal(N2, B2.L.n) )
		THEN Write(Right! [B4.o.k][B2.L.n.k][B2.o.k][B1.L.n.k] is commutative.)

		Example
		3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-1")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Euqal(GParent(B1), B2)
				Or( And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
				    And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, -)),
					And(!Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {P, E}),
					!Equal(B2.o.k, *) ),
				HasChild(B2.L, N3),
				!Equal(N2, B2.L.n) )
		THEN Write(You can switch [B2.L.n.k] to [N1.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] for commutation.)

		Example
		3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-
		drag '3' and drop on 'number' which is not '4'
		*/

		/*
		Rule ID ("Rule_W2-2-2")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				HasChild(B1.R, B2), Equal(Parent(B1), {P, E}),
				Or( And(Equal(B1.o.k, /), Equal(B2.o.k, {*, /})),
				    And(Equal(B1.o.k, -), Equal(B2.o.k, {+, -})) ),
				Equal(N1, B2.L.n) )
		THEN
			IF Equal(B1.o.k, /)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be * for commutation.)
			ELSE IF Equal(B1.o.k, -)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be + or * for commutation.)

		Example
		3/4/*  or 3-4+-
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-3")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {P, E}),
				Equal(B1.o.k, /), Equal(B2.o.k, {+, -}),
				Equal(N2, B1.L.n) )
		THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)

		Example
		3/4+-
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-4")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				HasChild(B1.R, B2), Equal(Parent(B1), {P, E}),
				Or( And(HasChild(B2.L, N3), Equal(B1.o.k, {+, -}), Equal(B2.o.k, {*, /})),
				    And(HasChild(B2.L, B3), Equal(B1.o.k, {+, -}), Equal(B3.o.k, {*, /})) ),
				Or( Equal(N2, B2.L.n), And(HasChild(B2.L, B3), Equal(N2, B3.L.n)) ) )
		THEN
			IF And(Equal(B1.o.k, +), Equal(N2, B2.L.n))
				Write([B2.o.k] after [B2.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(B1.o.k, +), Equal(N2, B3.L.n))
				Write([B3.o.k] after [B3.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n] must be * for commutation.)
			ELSE IF And(Equal(B1.o.k, -), Equal(N2, B2.L.n))
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B2.L.n] must be * for commutation.)
			ELSE IF And(Equal(B1.o.k, -), Equal(N2, B3.L.n))
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n] must be * for commutation.)

		Example
		/*3+-4/*+-
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-5")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(B2.o.key, {+, -}), HasAncestor(N1, B2), Equal(B1.o.k, {*, /}), HasChild(B2.R, B3)
				Or( Equal(N2, B3.L.n), And(HasChild(B3.L, B4), Equal(N2, B4.L.n)) ) )
		THEN Write()
			IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {+, -}))
				Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] for commutation.)
				Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B3.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}))
				Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] AND [B3.o.k] after [B3.L.n.k] must be + or - for commutation.)
				Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B3.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}))
				Wirte([B1.o.k] before [B1.R.n.k] must be [B2.o.k] AND [B4.o.k] after [B4.L.n.k] must be + or - for commutation.)
				Wirte([B2.o.k] in [B1.R.n.k][B2.o.k][B4.L.n.k] must be * for commutation.)
		Example
		/*3+-4/*+-
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-6")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B1.R, B3),
				Or( And(Equal(B2.o.k, -), Equal(B1.o.k, +)),
					And(Equal(B2.o.k, +), Equal(B1.o.k, -)),
					And(Equal(B2.o.k, +), Equal(B1.o.k, +)),
					And(Equal(B2.o.k, -), Equal(B1.o.k, -)),
				    And(Equal(B2.o.k, {*, /}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})) ),
				Or( Equal(N2, B3.L.n), And(HasChild(B3.L, B4), Equal(N2, B4.L.n)) ) )
		THEN
			IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {+, -}))
				Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be [B2.o.k] or * for commutation.)
			ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}), !Equal(B1.o.k, B2.o.k))
				Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] AND [B3.o.k] after [B3.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}), !Equal(B1.o.k, B2.o.k))
				Write([B2.o.k] before [B1.L.n.k] must be [B1.o.k] AND [B4.o.k] after [B4.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B4.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, {*, /}), Equal(B1.o.k, B2.o.k))
				Write([B3.o.k] after [B3.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B4.L.n), Equal(B4.o.k, {*, /}), Equal(B1.o.k, B2.o.k))
				Write([B4.o.k] after [B4.L.n.k] must be + or - for commutation.)
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B4.L.n.k] must be * for commutation.)
			ELSE IF And(Equal(N2, B3.L.n), Equal(B3.o.k, /))
				Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)

		Example
		-3+-4+- or +-3+-4/* or /*3/4/*
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W2-2-7")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), HasChild(B1.R, B3),
				Or( And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})),
				    And(Equal(B2.L.B, B1), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -}), Equal(B1.o.k, /), Equal(B3.o.k, {*, /})) ),
				Equal(N2, B3.L.n) )
		THEN Write([B1.o.k] in [B1.L.n.k][B1.o.k][B3.L.n.k] must be * for commutation.)

		Example
		+-3/4/*
		drag '3' and drop on '4'
		*/

		/*
		Rule ID ("Rule_R2-3")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(HasChild(B1.R, B2), HasChild(B2.L, N3),
				Or( And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B3) , Equal(B3.o.k, +)),
					And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, -), Equal(GParent(B1), B3) , Equal(B3.o.k, -)),
					And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),
				    Equal(B1.o.k, *) ),
				Equal(N2, B2.L.n) )
		THEN Write(Right! [B4.o.k][B1.L.n.k][B1.o.k][B2.L.n.k] is commutative.)

		Example
		3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-1")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(HasChild(B1.R, B2), HasChild(B2.L, N3),
				Or( And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B3) , Equal(B3.o.k, +)),
					And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, -), Equal(GParent(B1), B3) , Equal(B3.o.k, -)),
					And(!Equal(B2.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {P, E})),
				    Equal(B1.o.k, *) ),
				!Equal(N2, B2.L.n) )
		THEN Write(You can switch [B1.L.n.k] to [B2.L.n.k] in [B1.L.n.k][B1.o.k][N2.k] for commutation.)

		Example
		3+4+- or 3*4/*+- or +3+4+- or -3-4+- or /*+-3*4/*+-
		drag '4' and drop on 'number' which is not '3'
		*/

		/*
		Rule ID ("Rule_W2-3-2")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), Equal(Parent(B2), {P, E}),
				Or( And(Equal(B2.o.k, /), Equal(B1.o.k, {*, /})),
				    And(Equal(B2.o.k, -), Equal(B1.o.k, {+, -})) ),
				Equal(N2, B2.L.n) )
		THEN
			IF (Equal(B2.o.k, /))
				Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)
			ELSE IF (Equal(B2.o.k, -))
				Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be + or * for commutation.)

		Example
		3/4/*  or 3-4+-
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-3")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.R.n, N1),
				Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {P, E}),
				Equal(B1.o.k, /), Equal(B2.o.k, {+, -})
				Equal(N2, B1.L.n) )
		THEN Write([B1.o.k] in [B1-subtree] must be + or * for commutation.)

		Example
		3/4+-
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-4")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2)
				Or( And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(Parent(B2), {P, E})),
					And(Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),
					And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(Parent(B3), {P, E})),
				    And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})) ),
				Or( Equal(N2, B2.L.n), And(HasChild(B2.L, B1), Equal(N2, B3.L.n)) ) )
		THEN
			IF Equal(N2, B2.L.n))
				IF AND(Equal(B2.o.k, +), Equal(Parent(B2), {P, E}))
					Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF AND(Equal(B2.o.k, -), Equal(Parent(B2), {P, E}))
					Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF AND(Equal(GParent(B2), B3), !Equal(B2.o.k, B3.o.k))
					Write([B3.o.k] before [B2.L.n.k] must be [B2.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B2.o.k] in [B3.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF AND(Equal(GParent(B2), B3), Equal(B2.o.k, B3.o.k))
					Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B2.o.k] in [B3.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)

			ELSE IF Equal(N2, B3.L.n)
				IF Equal(B3.o.k, +)
					Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B3.o.k] in [B3.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF Equal(B3.o.k, -)
					Write([B3.o.k] in [B3.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF And(Equal(GParent(B3), B4), !Equal(B3.o.k, B4.o.k))
					Write([B4.o.k] before [B3.L.n.k] must be [B3.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B3.o.k] in [B4.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)
				ELSE IF And(Equal(GParent(B3), B4), Equal(B3.o.k, B4.o.k))
					Write([B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
					Write([B3.o.k] in [B4.L.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)

		Example
		3+-4/* or +-3+-4/*
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-5")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), Equal(B3.R, N3), Include(B2.L, B3)
				Equal(B3.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {+, -})
				Equal(N2, B3.R.n) )
		THEN Write([B3.o.k] before [B3.R.n.k] must be [B2.o.k] for commutation.)
		     Write([B2.o.k] in [B3.R.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)

		Example
		/*3+-4+-
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-6")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2),
				Or( And(Equal(B2.R.B, B1), Equal(B3.R, N3), Include(B2.L, B3), Equal(B3.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(B1.o.k, {*, /})),
				    And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B4.R, N3), Include(B3.L, B4), Equal(B4.o.k, {*, /}), Equal(B3.o.k, {+, -}), Equal(B1.o.k, {*, /})) ),
				Or( Equal(N2, B3.R.n), And(HasChild(B2.L, B1), Equal(N2, B4.R.n)) ) )
		THEN
			IF Equal(B2.R.B, B1)
				Write([B3.o.k] before [B3.R.n.k] must be [B2.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
				Write([B2.o.k] in [B3.R.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)
			ELSE IF Equal(B2.L.B, B1)
				Write([B4.o.k] before [B4.R.n.k] must be [B3.o.k] AND [B1.o.k] after [B1.L.n.k] must be + or - for commutation.)
				Write([B3.o.k] in [B4.R.n.k][B3.o.k][B1.L.n.k] must be * for commutation.)

		Example
		/*3+-4/*
		drag '4' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W2-3-7")

		Rule
		IF And( Drag(N1,N2),
		        Equal(GParent(N1), B1), Equal(B1.L.n, N1),
				Equal(GParent(B1), B2), Equal(GParent(B2), B3),
				Or( And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(B1.o.k, {+, -})),
					And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(B1.o.k, {+, -})),
					And(Equal(B3.R.B, B2), Equal(B3.o.k, {+, -}), Equal(B2.o.k, /), Equal(B1.o.k, {*, /})),
				    And(Equal(B3.L.B, B2), Equal(GParent(B3), B4) ,Equal(B4.o.k, {+, -}), Equal(B2.o.k, /), Equal(B1.o.k, {*, /})) ),
				Equal(N2, B2,L.n) )
		THEN
			IF Equal(B2.o.k, {+, -})
				Write([B3.o.k] before [B2.L.n.k] must be [B2.o.k] for commutation.)
				Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be [B3.o.k] or * for commutation.)
			ELSE IF Equal(B2.o.k, /)
				Write([B2.o.k] in [B2.L.n.k][B2.o.k][B1.L.n.k] must be * for commutation.)

		Example
		-3+4+- or +3-4+- or /*3/4/* or +-3/4/*
		drag '4' and drop on '3'
		*/

		var number1 = myDragSource;
		var number2 = myDropTarget;
		var parentOfParentOfNumber1 = findParentNode(syntax, findParentNode(syntax, number1));

		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Right'].hasOwnProperty('number')){
			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

			//Rule2-1
			if( (binary1['operator'].key == '+' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
					|| (binary1['operator'].key == '-' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
					|| (binary1['operator'].key == '+' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
					|| (binary1['operator'].key == '*')){

				var binary2 = parentOfParentOfBinary1;
				//Rule_R2-1
				if(parentOfParentOfNumber1['Left'].hasOwnProperty('number')){

					var parentOfParentOfNumber2 = findParentNode(syntax, findParentNode(syntax, number2));
					if(parentOfParentOfNumber1 === parentOfParentOfNumber2){
						myDropTarget.rules = [];
						myDropTarget.rules.push("R_R2-1");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = true;
							return;
						}else if(mode == "drop"){
							var binary2Key = "";
							if( binary1['operator'].key != '*' && binary2 == 'Binary'){
								binary2Key = binary2['operator'].key;
							}

							rightDropMessage = "Right!\n" + binary2Key + binary1['Left']['number'].key + binary1['operator'].key + binary1['Right']['number'].key + " is commutative.";

							var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
							var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

							if(dragSourceBoxIndex > dropTargetBoxIndex){
								tempQuestion = getCloneQuestion(myQuestion);

								// to swich two number each other
								var tempBox = tempQuestion[dragSourceBoxIndex];
								tempQuestion[dragSourceBoxIndex] = tempQuestion[dropTargetBoxIndex];
								tempQuestion[dropTargetBoxIndex] = tempBox;

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								setArcAnimation(myQuestion, '2ArcForward', dropTargetBoxIndex);

							}else if(dragSourceBoxIndex < dropTargetBoxIndex){
								tempQuestion = getCloneQuestion(myQuestion);

								// to swich two number each other
								var tempBox = tempQuestion[dragSourceBoxIndex];
								tempQuestion[dragSourceBoxIndex] = tempQuestion[dropTargetBoxIndex];
								tempQuestion[dropTargetBoxIndex] = tempBox;

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								setArcAnimation(myQuestion, '2ArcBackward', dropTargetBoxIndex);
							}

							return;
						}
					}
					//Rule_W2-1-1
					else{
						myDropTarget.rules.push("R_W2-1-1");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;

						}else if(mode == "drop"){
							var binary2Key = "";
							if( binary1['operator'].key != '*' && binary2 == 'Binary'){
								binary2Key = binary2['operator'].key;
							}
							wrongDropMessages.push("You can switch " + binary1['Left']['number'].key + " to " + binary1['Right']['number'].key + " in " + binary2Key + binary1['Left']['number'].key + binary1['operator'].key + binary1['Right']['number'].key + " for commutation.");
						}
					}
				}
			}

			//Rule_W2-1-6
			var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, number1);
			var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary1['Left']);

			if( (binaryHavingOperatorPlusOrMinus == 'Binary' && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('number') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && (binaryHavingOperatorPlusOrMinus['operator'].key == '+' || binaryHavingOperatorPlusOrMinus['operator'].key == '-'))
				|| (binaryHavingNumberInRightChild == 'Binary' && (binaryHavingNumberInRightChild['operator'].key == '*' || binaryHavingNumberInRightChild['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-'))  ){

				var binary2;
				if(binaryHavingNumberInRightChild == 'Binary' && (binaryHavingNumberInRightChild['operator'].key == '*' || binaryHavingNumberInRightChild['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-')){
					binary2 = binaryHavingNumberInRightChild;
				}else if(binaryHavingOperatorPlusOrMinus == 'Binary' && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('number') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && (binaryHavingOperatorPlusOrMinus['operator'].key == '+' || binaryHavingOperatorPlusOrMinus['operator'].key == '-')){
					binary2 = binaryHavingOperatorPlusOrMinus;
				}

				if(number1 === binary1['Right']['number'] && number2 === binary2['Right']['number']){
					myDropTarget.rules.push("R_W2-1-6");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						if(binary1['operator'].key == '*' || binary1['operator'].key == '/'){
							wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Right']['number'].key + " must be " + binary2['operator'].key + " for commutation.");
							wrongDropMessages.push(binary2['operator'].key + " in " + binary1['Right']['number'].key + binary2['operator'].key + binary2['Right']['number'].key + " must be * for commutation.");
						}else if(binary1['operator'].key == '+' || binary1['operator'].key == '-'){
							wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be " + binary1['operator'].key+ " for commutation.");
							wrongDropMessages.push(binary1['operator'].key + " in " + binary2['Right']['number'].key + binary1['operator'].key + binary1['Right']['number'].key + " must be * for commutation.");
						}
					}
				}
			}
		}

		//Rule_W2-1-2 or Rule_W2-1-3 or Rule_W2-1-4 or Rule_W2-1-5
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Left'].hasOwnProperty('number') && parentOfParentOfNumber1['Right'].hasOwnProperty('number')){
			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

			//Rule_W2-1-2
			if((binary1['operator'].key == '/' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')){
				var parentOfParentOfNumber2 = findParentNode(syntax, findParentNode(syntax, number2));
				if(parentOfParentOfNumber1 === parentOfParentOfNumber2){

					myDropTarget.rules.push("R_W2-1-2");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be + or * for commutation.");
					}
				}
			}

			//Rule_W2-1-3
			if(binary1['operator'].key == '/' && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '*' || parentOfParentOfBinary1['operator'].key == '/')){
				var parentOfParentOfNumber2 = findParentNode(syntax, findParentNode(syntax, number2));
				if(parentOfParentOfNumber1 === parentOfParentOfNumber2){

					myDropTarget.rules.push("R_W2-1-3");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be * for commutation.");
					}
				}
			}
			//Rule_W2-1-4
			if((binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-') && binary1['operator'].key != parentOfParentOfBinary1['operator'].key){
				var parentOfParentOfNumber2 = findParentNode(syntax, findParentNode(syntax, number2));
				if(parentOfParentOfNumber1 === parentOfParentOfNumber2){

					myDropTarget.rules.push("R_W2-1-4");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						var binary2 = parentOfParentOfBinary1;
						wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be " + binary2['operator'].key + " or * for commutation.");
					}
				}
			}

			//Rule_W2-1-5
			var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, findParentNode(syntax, parentOfParentOfBinary1));
			if( (binary1['operator'].key == '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] !== binary1 && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
				|| (binary1['operator'].key == '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary1['operator'].key == '-') ) ){

				var parentOfParentOfNumber2 = findParentNode(syntax, findParentNode(syntax, number2));
				if(parentOfParentOfNumber1 === parentOfParentOfNumber2){

					myDropTarget.rules.push("R_W2-1-5");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						var binary2 = parentOfParentOfBinary1;
						if(binary2['Left']['Binary'] === binary1){
							wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be " + binary2['operator'].key + " or * for commutation.");
						}else if(binary2['Left']['Binary'] !== binary1){
							var binary3 = parentOfParentOfParentOfParentOfBinary1;
							wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be " + binary3['operator'].key + " or * for commutation.");
						}
					}
				}
			}
		}

		//Rule2-2 or Rule2-3
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Left']['number'] == number1){
			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
			//Rule2-2
			if(parentOfParentOfBinary1 == 'Binary'){
				var binary2 = parentOfParentOfBinary1;
				var parentOfBinary2 = findParentNode(syntax, binary2);
				var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);
				if( (binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '+')
					|| (binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '-' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '-')
					|| (binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
					|| (binary2['operator'].key == '*')){
					var binary4 = parentOfParentOfBinary2;
					//Rule_R2-2
					if(binary2['Left'].hasOwnProperty('number')){
						if(number2 === binary2['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R2-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;

							}else if(mode == "drop"){

								var binary4Key = "";
								if(binary4 == 'Binary' && binary2['operator'].key != '*'){
									binary4Key = binary4['operator'].key;
								}

								rightDropMessage = "Right!\n" + binary4Key + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " is commutative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								tempQuestion = getCloneQuestion(myQuestion);

								// to swich two number each other
								var tempBox = tempQuestion[dragSourceBoxIndex];
								tempQuestion[dragSourceBoxIndex] = tempQuestion[dropTargetBoxIndex];
								tempQuestion[dropTargetBoxIndex] = tempBox;

								myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
								myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
								myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
								myQuestion[dragSourceBoxIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

								myQuestion[dropTargetBoxIndex].animationType = '2ArcForward';
								myQuestion[dropTargetBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
								myQuestion[dropTargetBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
								myQuestion[dropTargetBoxIndex].isAnimating = true;

								return;
							}

						}
						//Rule_W2-2-1
						else{
							myDropTarget.rules.push("R_W2-2-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								var binary4Key = "";
								if(binary4 == 'Binary' && binary2['operator'].key != '*'){
									binary4Key = binary4['operator'].key;
								}
								wrongDropMessages.push("You can switch " + binary2['Left']['number'].key + " to " +  binary1['Left']['number'].key + " in " + binary4Key + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " for commutation.");
							}
						}
					}
				}
			}


			//Rule_W2-2-2
			if(binary1['Right'].hasOwnProperty('Binary') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')){
				var binary2 = binary1['Right']['Binary'];
				if( (binary1['operator'].key == '/' && (binary2['operator'].key == '*' || binary2['operator'].key == '/'))
					|| (binary1['operator'].key == '-' && (binary2['operator'].key == '+' || binary2['operator'].key == '-')) ){

					if(number2 === binary2['Left']['number']){
						myDropTarget.rules.push("R_W2-2-2");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(binary1['operator'].key == '/'){
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " must be * for commutation.");
							}else if(binary1['operator'].key == '-'){
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " must be + or * for commutation.");
							}
						}

					}
				}
			}

			//Rule_W2-2-3
			var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);
			if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression') ){
				var binary2 = parentOfParentOfBinary1;
				if(binary1['operator'].key == '/' && (binary2['operator'].key == '+' || binary2['operator'].key == '-')){
					if(number2 === binary1['Right']['number']){
						myDropTarget.rules.push("R_W2-2-3");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be + or * for commutation.");
						}

					}
				}
			}

			//Rule_W2-2-4
			if(binary1['Right'].hasOwnProperty('Binary') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')){
				var binary2 = binary1['Right']['Binary'];
				if( (binary2['Left'].hasOwnProperty('number') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (binary2['operator'].key == '*' || binary2['operator'].key == '/'))
					|| (binary2['Left'].hasOwnProperty('Binary') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (binary2['Left']['Binary']['operator'].key == '*' || binary2['Left']['Binary']['operator'].key == '/')) ){

					if(number2 === binary2['Left']['number'] || (binary2['Left'].hasOwnProperty('Binary') && number2 === binary2['Left']['Binary']['Left']['number']) ){
						myDropTarget.rules.push("R_W2-2-4");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(binary1['operator'].key == '+'){
								if(number2 === binary2['Left']['number']){
									wrongDropMessages.push(binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for commutation.");
									wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " must be * for commutation.");
								}else if(number2 === binary2['Left']['Binary']['Left']['number']){
									var binary3 = binary2['Left']['Binary'];

									wrongDropMessages.push(binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + or - for commutation.");
									wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
								}
							}else if(binary1['operator'].key == '-'){
								if(number2 === binary2['Left']['number']){
									wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " must be * for commutation.");
								}else if(number2 === binary2['Left']['Binary']['Left']['number']){
									var binary3 =  binary2['Left']['Binary'];
									wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
								}
							}
						}

					}
				}
			}

			//Rule_W2-2-6
			if(parentOfParentOfBinary1 == 'Binary' && binary1['Right'].hasOwnProperty('Binary')){
				var binary2 = parentOfParentOfBinary1;
				var binary3 = binary1['Right']['Binary'];

				if( (binary2['operator'].key == '-' && binary1['operator'].key == '+')
					|| (binary2['operator'].key == '+' && binary1['operator'].key == '-')
					|| (binary2['operator'].key == '+' && binary1['operator'].key == '+')
					|| (binary2['operator'].key == '-' && binary1['operator'].key == '-')
					|| ((binary2['operator'].key == '*' || binary2['operator'].key == '/') && binary1['operator'].key == '/' && (binary3['operator'].key == '*' || binary3['operator'].key == '/')) ){

					if(number2 === binary3['Left']['number'] || (binary3['Left'].hasOwnProperty('Binary') && number2 === binary3['Left']['Binary']['Left']['number']) ){
						myDropTarget.rules.push("R_W2-2-6");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;

						}else if(mode == "drop"){
							if(number2 === binary3['Left']['number'] && (binary3['operator'].key == '+' || binary3['operator'].key == '-')){
								wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be " + binary1['operator'].key + " for commutation.");
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be " + binary2['operator'].key + " or * for commutation.");

							}else if(number2 === binary3['Left']['number'] && (binary3['operator'].key == '*' || binary3['operator'].key == '/') && binary1['operator'].key != binary2['operator'].key){
								wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be " + binary1['operator'].key + " AND " + binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");

							}else if(binary3['Left'].hasOwnProperty('Binary') && number2 === binary3['Left']['Binary']['Left']['number'] && (binary3['Left']['Binary']['operator'].key == '*' || binary3['Left']['Binary']['operator'].key == '/') && binary1['operator'].key != binary2['operator'].key){
								var binary4 = binary3['Left']['Binary'];
								wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be " + binary1['operator'].key + " AND " + binary4['operator'].key + " after " + binary4['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary4['Left']['number'].key + " must be * for commutation.");

							}else if(number2 === binary3['Left']['number'] && (binary3['operator'].key == '*' || binary3['operator'].key == '/') && binary1['operator'].key == binary2['operator'].key){
								wrongDropMessages.push(binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");

							}else if(binary3['Left'].hasOwnProperty('Binary') && number2 === binary3['Left']['Binary']['Left']['number'] && (binary3['Left']['Binary']['operator'].key == '*' || binary3['Left']['Binary']['operator'].key == '/') && binary1['operator'].key == binary2['operator'].key){
								var binary4 = binary3['Left']['Binary'];
								wrongDropMessages.push(binary4['operator'].key + " after " + binary4['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary4['Left']['number'].key + " must be * for commutation.");

							}else if(number2 === binary3['Left']['number'] && binary3['operator'].key == '/'){
								wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
							}
						}
					}
				}
			}


			//Rule_W2-2-7
			if(parentOfParentOfBinary1 == 'Binary' && binary1['Right'].hasOwnProperty('Binary')){
				var binary2 = parentOfParentOfBinary1;
				var binary3 = binary1['Right']['Binary'];
				var parentOfParentOfBinary2 = findParentNode(syntax, findParentNode(syntax, binary2));
				if( (binary2['Right']['Binary'] === binary1 && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && binary1['operator'].key == '/' && (binary3['operator'].key == '*' || binary3['operator'].key == '/'))
					|| (binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' &&  (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && binary1['operator'].key == '/' && (binary3['operator'].key == '*' || binary3['operator'].key == '/')) ){

					if(number2 === binary3['Left']['number']){
						myDropTarget.rules.push("R_W2-2-7");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;

						}else if(mode == "drop"){
							wrongDropMessages.push(binary1['operator'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
						}
					}
				}
			}



			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

			if(binary1['Right'].hasOwnProperty('Binary') && binary1['Right']['Binary']['Left'].hasOwnProperty('number')){
				var binary2 = binary1['Right']['Binary'];

				//Rule_R2-3
				if( (binary2['operator'].key != '*' && binary2['operator'].key != '/' && binary1['operator'].key == '+' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
					|| (binary2['operator'].key != '*' && binary2['operator'].key != '/' && binary1['operator'].key == '-' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
					|| (binary2['operator'].key != '*' && binary2['operator'].key != '/' && binary1['operator'].key == '+' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
					|| (binary1['operator'].key == '*')){

					var binary4 = parentOfParentOfBinary1;
					//Rule_R2-3
					if(number2 === binary2['Left']['number']){

						myDropTarget.rules = [];
						myDropTarget.rules.push("R_R2-3");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = true;
							return;

						}else if(mode == "drop"){

							var binary4Key = "";
							if(binary4 == 'Binary' && binary1['operator'].key != '*' ){
								binary4Key = binary4['operator'].key;
							}

							rightDropMessage = "Right!\n" + binary4Key + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " is commutative.";

							var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
							var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

							tempQuestion = getCloneQuestion(myQuestion);

							// to swich two number each other
							var tempBox = tempQuestion[dragSourceBoxIndex];
							tempQuestion[dragSourceBoxIndex] = tempQuestion[dropTargetBoxIndex];
							tempQuestion[dropTargetBoxIndex] = tempBox;

							myQuestion[dragSourceBoxIndex].animationType = 'linearMotion';
							myQuestion[dragSourceBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
							myQuestion[dragSourceBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
							myQuestion[dragSourceBoxIndex].isAnimating = true;
							setAnimationAceleration(myQuestion[dragSourceBoxIndex]);

							myQuestion[dropTargetBoxIndex].animationType = '2ArcBackward';
							myQuestion[dropTargetBoxIndex].destinationX = myQuestion[dropTargetBoxIndex].x;
							myQuestion[dropTargetBoxIndex].destinationY = myQuestion[dropTargetBoxIndex].y;
							myQuestion[dropTargetBoxIndex].isAnimating = true;

							return;
						}
					}
					//Rule_W2-3-1
					else{
						myDropTarget.rules.push("R_W2-3-1");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							var binary4Key = "";
							if(binary4 == 'Binary' && binary1['operator'].key != '*' ){
								binary4Key = binary4['operator'].key;
							}
							wrongDropMessages.push("You can switch " + binary1['Left']['number'].key + " to " +  binary2['Left']['number'].key + " in " + binary4Key + binary1['Left']['number'].key + binary1['operator'].key + binary2['Left']['number'].key + " for commutation.");
						}
					}
				}
			}

			//Rule_W2-3-2
			if(parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')){
				var binary2 = parentOfParentOfBinary1;

				if( (binary2['operator'].key == '/' && (binary1['operator'].key == '*' || binary1['operator'].key == '/'))
					|| (binary2['operator'].key == '-' && (binary1['operator'].key == '+' || binary1['operator'].key == '-')) ){

					if(number2 === binary2['Left']['number']){
						myDropTarget.rules.push("R_W2-3-2");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(binary2['operator'].key == '/'){
								wrongDropMessages.push(binary2['operator'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
							}else if(binary2['operator'].key == '-'){
								wrongDropMessages.push(binary2['operator'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be + or * for commutation.");
							}
						}

					}
				}
			}

			//Rule_W2-3-4
			if(parentOfParentOfBinary1 == 'Binary'){
				var binary2 = parentOfParentOfBinary1;
				var parentOfBinary2 = findParentNode(syntax, binary2);
				var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);
				var parentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfBinary2);
				var parentOfParentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfParentOfBinary2);

				if( (binary2['Right']['Binary'] === binary1 && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
					|| (binary2['Right']['Binary'] === binary1 && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
					|| (binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && (parentOfParentOfParentOfBinary2 == 'Parenthesis' || parentOfParentOfParentOfBinary2 == 'Expression'))
					|| (binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && parentOfParentOfParentOfParentOfBinary2 == 'Binary' && (parentOfParentOfParentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary2['operator'].key == '-')) ){

					if(number2 === binary2['Left']['number'] || (binary2['Left']['Binary'] === binary1 && number2 === parentOfParentOfBinary2['Left']['number']) ){
						myDropTarget.rules.push("R_W2-3-4");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(number2 === binary2['Left']['number']){
								if(binary2['operator'].key == '+' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression')){
									wrongDropMessages.push(binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}else if(binary2['operator'].key == '-' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression')){
								}else if(parentOfParentOfBinary2 == 'Binary' && binary2['operator'].key != parentOfParentOfBinary2['operator'].key){

									var binary3 = parentOfParentOfBinary2;
									wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be " + binary2['operator'].key + " AND " + binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}else if(parentOfParentOfBinary2 == 'Binary' && binary2['operator'].key == parentOfParentOfBinary2['operator'].key){
									var binary3 = parentOfParentOfBinary2;
									wrongDropMessages.push(binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}
								wrongDropMessages.push(binary2['operator'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");

							}else if(number2 === parentOfParentOfBinary2['Left']['number']){
								var binary3 = parentOfParentOfBinary2;
								var parentOfBinary3 = findParentNode(syntax, binary3);
								var parentOfParentOfBinary3 = findParentNode(syntax, parentOfBinary3);
								if(binary3['operator'].key == '+' && (parentOfBinary3 == 'Parenthesis' || parentOfBinary3 == 'Expression')){
									wrongDropMessages.push(binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}else if(binary3['operator'].key == '-' && (parentOfBinary3 == 'Parenthesis' || parentOfBinary3 == 'Expression')){

								}else if(parentOfParentOfBinary3 == 'Binary' && binary3['operator'].key != parentOfParentOfBinary3['operator'].key){
									var binary4 = parentOfParentOfBinary3;
									wrongDropMessages.push(binary4['operator'].key + " before " + binary3['Left']['number'].key + " must be " + binary3['operator'].key + " AND " + binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}else if(parentOfParentOfBinary3 == 'Binary' && binary3['operator'].key == parentOfParentOfBinary3['operator'].key){
									var binary4 = parentOfParentOfBinary3;
									wrongDropMessages.push(binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								}
								wrongDropMessages.push(binary3['operator'].key + " in " + binary3['Left']['number'].key + binary3['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
							}
						}
					}
				}
			}

			//Rule_W2-3-5
			var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(parentOfParentOfBinary1['Left']);
			if(parentOfParentOfBinary1 == 'Binary' && binaryHavingNumberInRightChild == 'Binary'){
				var binary3 = binaryHavingNumberInRightChild;

				if((binary3['operator'].key == '/' || binary3['operator'].key == '*') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') ){

					if(number2 === binary3['Right']['number']){
						myDropTarget.rules.push("R_W2-3-5");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be " + binary2['operator'].key + " for commutation.");
							wrongDropMessages.push(binary2['operator'].key + " in " + binary3['Right']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
						}
					}
				}
			}


			//Rule_W2-3-6
			if(parentOfParentOfBinary1 == 'Binary'){
				var binary2 = parentOfParentOfBinary1;
				var parentOfBinary2 = findParentNode(syntax, binary2);
				var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);
				var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary2['Left']);
				var binaryHavingNumberInRightChild2 = findBinaryHavingNumberInRightChild(parentOfParentOfBinary2['Left']);

				if( (binary2['Right']['Binary'] === binary1 && binaryHavingNumberInRightChild == 'Binary' && (binaryHavingNumberInRightChild['operator'].key == '*' || binaryHavingNumberInRightChild['operator'].key == '/') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/'))
					|| (binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && binaryHavingNumberInRightChild2 == 'Binary' && (binaryHavingNumberInRightChild2['operator'].key == '*' || binaryHavingNumberInRightChild2['operator'].key == '/') && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && (binary1['operator'].key == '*' || binary1['operator'].key == '/')) ){

					if(number2 === binaryHavingNumberInRightChild['Right']['number'] || (binary2['Left']['Binary'] === binary1 && number2 === binaryHavingNumberInRightChild2['Right']['number']) ){
						myDropTarget.rules.push("R_W2-3-6");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(binary2['Right']['Binary'] === binary1){
								var binary3 = binaryHavingNumberInRightChild;
								wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be " + binary2['operator'].key + " AND " + binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary2['operator'].key + " in " + binary3['Right']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
							}else if(binary2['Left']['Binary'] === binary1){
								var binary3 = parentOfParentOfBinary2;
								var binary4 = binaryHavingNumberInRightChild2;
								wrongDropMessages.push(binary4['operator'].key + " before " + binary4['Right']['number'].key + " must be " + binary3['operator'].key + " AND " + binary1['operator'].key + " after " + binary1['Left']['number'].key + " must be + or - for commutation.");
								wrongDropMessages.push(binary3['operator'].key + " in " + binary4['Right']['number'].key + binary3['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
							}
						}
					}
				}

			}

			//Rule_W2-3-7
			var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfParentOfBinary1);
			if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfParentOfParentOfBinary1 == 'Binary'){
				var binary2 = parentOfParentOfBinary1;
				var binary3 = parentOfParentOfParentOfParentOfBinary1;
				var parentOfParentOfBinary3 = findParentNode(syntax, findParentNode(syntax, binary3));

				if( (binary3['operator'].key == '-' && binary2['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-'))
					|| (binary3['operator'].key == '+' && binary2['operator'].key == '-' && (binary1['operator'].key == '+' || binary1['operator'].key == '-'))
					|| ((binary3['operator'].key == '*' || binary3['operator'].key == '/') && binary2['operator'].key == '/' && (binary1['operator'].key == '*' || binary1['operator'].key == '/'))
					|| (binary3['Right']['Binary'] === binary2 && (binary3['operator'].key == '+' || binary3['operator'].key == '-') && binary2['operator'].key == '/' && (binary1['operator'].key == '*' || binary1['operator'].key == '/'))
					|| (binary3['Left']['Binary'] === binary2 && parentOfParentOfBinary3 == 'Binary' && (parentOfParentOfBinary3['operator'].key == '+' || parentOfParentOfBinary3['operator'].key == '-') && binary2['operator'].key == '/' && (binary1['operator'].key == '*' || binary1['operator'].key == '/')) ){

					if(number2 === binary2['Left']['number']){
						myDropTarget.rules.push("R_W2-3-7");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(binary2['operator'].key == '+' || binary2['operator'].key == '-'){
								wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be " + binary2['operator'].key + " for commutation.");
								wrongDropMessages.push(binary2['operator'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be " + binary3['operator'].key + "  * for commutation.");
							}else if(binary2['operator'].key == '/'){
								wrongDropMessages.push(binary2['operator'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + binary1['Left']['number'].key + " must be * for commutation.");
							}
						}
					}
				}
			}
		}

		//Rule_W2-2-5
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Right']['number'] == number1){
			var binary1 = parentOfParentOfNumber1;
			var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, number1);

			if(binaryHavingOperatorPlusOrMinus == 'Binary' && (binary1['operator'].key == '*' || binary1['operator'].key == '/') && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('Binary') ){
				var binary2 = binaryHavingOperatorPlusOrMinus;
				var binary3 = binary2['Right']['Binary'];

				if(number2 === binary3['Left']['number'] || (binary3['Left'].hasOwnProperty('Binary') && number2 === binary3['Left']['Binary']['Left']['number']) ){
					myDropTarget.rules.push("R_W2-2-5");
					if(mode == "drag"){
						myDropTarget.isCandidate = true;
						myDropTarget.isRightRule = false;

					}else if(mode == "drop"){
						if(number2 === binary3['Left']['number'] && (binary3['operator'].key == '+' || binary3['operator'].key == '-')){
							wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Right']['number'].key + " must be " + binary2['operator'].key + " for commutation.");
							wrongDropMessages.push(binary2['operator'].key + " in " + binary1['Right']['number'].key + binary2['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
						}else if(number2 === binary3['Left']['number'] && (binary3['operator'].key == '*' || binary3['operator'].key == '/')){
							wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Right']['number'].key + " must be " + binary2['operator'].key + " AND " + binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + or - for commutation.");
							wrongDropMessages.push(binary2['operator'].key + " in " + binary1['Right']['number'].key + binary2['operator'].key + binary3['Left']['number'].key + " must be * for commutation.");
						}else if(number2 === binary3['Left']['Binary']['Left']['number'] && (binary3['Left']['Binary']['operator'].key == '*' || binary3['Left']['Binary']['operator'].key == '/')){
							var binary4 = binary3['Left']['Binary'];
							wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Right']['number'].key + " must be " + binary2['operator'].key + " AND " + binary4['operator'].key + " after " + binary4['Left']['number'].key + " must be + or - for commutation.");
							wrongDropMessages.push(binary2['operator'].key + " in " + binary1['Right']['number'].key + binary2['operator'].key + binary4['Left']['number'].key + " must be * for commutation.");
						}
					}
				}
			}
		}

		//Rule_W2-3-3
		if(parentOfParentOfNumber1 == 'Binary' && parentOfParentOfNumber1['Right'].hasOwnProperty('number')){
			var binary1 = parentOfParentOfNumber1;
			var parentOfBinary1 = findParentNode(syntax, binary1);
			var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
			var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);

			if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression') ){
				var binary2 = parentOfParentOfBinary1;
				if(binary1['operator'].key == '/' && (binary2['operator'].key == '+' || binary2['operator'].key == '-')){

					if(number2 === binary1['Left']['number']){
						myDropTarget.rules.push("R_W2-3-3");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							wrongDropMessages.push(binary1['operator'].key + " in " + parseSubtreeToString(binary1) + " must be + or * for commutation.");
						}
					}
				}
			}
		}
	}
	if(dragSourceType == 'parenthesis' && dropTargetType == 'number'){//If user drags ‘(‘ or ‘)’ onto one Number(N1)

		/*
		Rule ID ("Rule_R3-1")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				Equal(N1, P1.B.R.n) )
		THEN Write(Right! [P1-subtree][B1.o.k][B1.R.n.k] is associative.)

		Example
		(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-1-1")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				!Equal(N1, P1.B.R.n) )
		THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B1.R.n.k] for association.)

		Example
		(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5
		drag '(' and drop on 'number' which is not '4'
		*/

		/*
		Rule ID ("Rule_W3-1-2")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), HasChild(B2.R, N4),
				Equal(B1.o.k, {*, /}),
				Equal(N1, P1.B.R.n) )
		THEN
			IF Equal(P1.B.o.k, +)
				ex) /*(3+4)+-5
				Write([B1.o.k] before [P1-subtree] must be + for association.)
			ELSE IF And(Equal(B1.o.k, *) ,Equal(P1.B.o.k, *))
				ex) *(3*4)+-5
				Write([B2.o.k] between [P1-subtree] and [B2.R.n.k] must be * for association.)
			ELSE
				ex) /*(3/-4)+-5 or /(3*4)+-5
				Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)

		Example
		/*(3/*+-4)+-5
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-1-3")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, -)),
					And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
				    And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF AND(Equal(Parent(B1), {E, P}), Equal(P1.B.o.k, *))
				ex) (3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(Parent(B1), {E, P}), !Equal(P1.B.o.k, *))
				ex) (3/-4)-+5
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, *))
				ex) -(3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([B2.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, {/, -}))
				ex) -(3/-4)-+5
				Write()
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
				ex) +(3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, {/, -}))
				ex) +(3/-4)-+5
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)

		Example
		-(3/*+-4)+-5 or +(3/*-4)-+5 or (3/*-4)-+5
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-1-4")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.R.B, B1), Equal(B2.o.k, {+, -})),
					And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3), Equal(B2.o.k, {+, -})),
					And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(Parent(B1), {P, E})),
				    And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P})) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF AND(Or(Equal(Parent(B1), {E, P}), And(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P}))))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) (3*4)/5 or (3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +))
					ex) (3+4)/5 or (3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}))
					ex) (3/-4)/5 or (3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +))
					ex) (3+4)*5 or (3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) (3/-4)*5 or (3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.R.B, B1))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-(3*4)/5 or +-(3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, +))
					ex) +(3+4)/5 or +(3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, -))
					ex) -(3+4)/5 or -(3+4)/5+-
					Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, +))
					ex) +(3/-4)/5 or +(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, -))
					ex) -(3/-4)/5 or -(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, +))
					ex) +(3+4)*5 or +(3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, -))
					ex) -(3+4)*5 or -(3+4)*5+-
					Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) +-(3/-4)*5 or +-(3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF AND(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-(3*4)/5 or +-(3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, +))
					ex) +(3+4)/5 or +(3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, -))
					ex) -(3+4)/5 or -(3+4)/5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, +))
					ex) +(3/-4)/5 or +(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, -))
					ex) -(3/-4)/5 or -(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, +))
					ex) +(3+4)*5 or +(3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, -))
					ex) -(3+4)*5 or -(3+4)*5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) +-(3/-4)*5 or +-(3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		+-(3/*+-4)/5 or +-(3/+-4)*5 or (3/*+-4)/5 or (3/+-4)*5 or
		+-(3/*+-4)/5+- or +-(3/+-4)*5+- or (3/*+-4)/5+- or (3/+-4)*5+-
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_R3-2")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				Equal(N1, P1.B.R.n) )
		THEN Write(Right! [P1-subtree][B1.o.k][B2.L.n.k] is associative.)

		Example
		(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-2-1")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *)) ),
				!Equal(N1, P1.B.R.n) )
		THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B2.L.n.k] for association.)

		Example
		(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-
		drag '(' and drop on 'number' which is not '4'
		*/

		/*
		Rule ID ("Rule_W3-2-2")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.R, B2), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), Include(B2.L, P1), HasChild(B2.R, B3),
				Or( And(Equal(B1.o.k, {*, /}), HasChild(B3.L, N4)),
				    And(Equal(B1.o.k, {*, /}), HasChild(B3.L, B4)), HasChild(B4.L, N4)) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF AND(Equal(B3.L, N4), Equal(B3.o.k, {+, -}))
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5+-
					Write([B1.o.k] before [P1-subtree] must be + for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5+-
					Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5+-
					Write([B1.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)

			ELSE IF AND(Equal(B3.L, N4), Equal(B3.o.k, {*, /}))
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5/*6
					Write([B1.o.k] before [P1-subtree] must be + AND [B3.o.k] after [B3.L.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5/*6
					Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5/*6
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)

			ELSE HasChild(B3.L, B4)
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5/*6+-
					Write([B1.o.k] before [P1-subtree] must be + AND [B4.o.k] after [B4.L.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5/*6+-
					Write([B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5/*6+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)

		Example
		/*(3/*+-4)+-5/*+-
		 drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-2-3")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, -)),
					And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
				    And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B1), {E, P})) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF Equal(P1.B.o.k, *)
					ex)	(3*4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association.)
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) (3/-4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association.)

			ELSE IF  Equal(GParent(B1), B3)
				IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, +))
					ex)	-(3+4)+-5+-
					Write([B3.o.k] before [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, *))
					ex)	-(3*4)+-5+-
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, {/, -}))
					ex)	-(3/-4)+-5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association)
				ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, *))
					ex)	+(3*4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association)
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, {/, -}))
					ex)	+(3/-4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association)

		Example
		 -(3/*+-4)+-5+- or +(3/*-4)+-5+- or (3/*-4)+-5+-
		 drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-2-4")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(GParent(B1), B3), Equal(B3.o.k, {+, -})),
				    And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(Parent(B1), {E, P})) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF Equal(P1.B.o.k, +)
					ex) (3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

				ELSE IF Equal(P1.B.o.k, *)
					ex) (3*4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) (3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

			ELSE IF Equal(GParent(B1), B3)
				IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, +))
					ex) +(3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

				ELSE IF AND(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) +-(3*4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, {/, -}))
					ex) +(3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, +))
					ex) -(3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B3.o.k] before [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B3.o.k] before [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, {/, -}))
					ex) -(3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

		Example
		+-(3/*+-4)+-5/* or (3/*+-4)+-5/*
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_W3-2-5")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.R, P1), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.L, P1), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.L.B, B1), Equal(Parent(B3), {E, P})) ),
				Equal(N1, P1.B.R.n) )
		THEN
			IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
				ex) (3*4)/5/* or +-(3*4)/5/*
				Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
			ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))
				ex) (3/+-4)/5/* or +-(3/+-4)/5/*
				Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
			ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))
				ex) (3/+-4)*5/* or +-(3/+-4)*5/*
				Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		+-(3/*+-4)/5/* or +-(3/+-4)*5/* or (3/*+-4)/5/* or (3/+-4)*5/*
		drag '(' and drop on '4'
		*/

		/*
		Rule ID ("Rule_R3-3")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))
				    And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),
				Equal(N1, B1.L.n) )
		THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)

		Example
		2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-3-1")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))
				    And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),
				!Equal(N1, B1.L.n) )
		THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)

		Example
		2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)
		drag '(' and drop on 'number' which is not '2'
		*/

		/*
		Rule ID ("Rule_W3-3-2")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),
					And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),
					And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),
				    And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),
				Equal(N1, B1.L.n) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) 2+(3*4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) 2+(3/4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))
					ex) 2-(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) 2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) 2-(3+-4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
			ELSE IF Equal(GParent(B1), B2)
				IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) +2+(3*4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) -2+(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) +2+(3/4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) -2+(3/4)
					Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))
					ex) +-2-(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) +2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) -2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) +2-(3+-4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) -2-(3+-4)
					Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-3-3")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),
				Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),
				Equal(N1, B2.R.n) )
		THEN
			IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))
				ex)/*2+(3+-4)
				Write([B2.o.k] before [B2.R.n.k] must be + for association.)
			ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))
				ex)/*2-(3+-4)
				Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(P.B.o.k, *)
				ex)/*2+-(3*4)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))
				ex)/*2+(3/4)
				Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))
				ex)/*2-(3/4)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-4)
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-3-4")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),
				Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),
				    And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),
				Equal(N1, B1.L.n) )
		THEN
			IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )
				IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) 2/(3+-4) or 2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) 2/(3*4) or 2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) 2/(3/4) or 2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) 2*(3+-4) or 2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) 2*(3/4) or 2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))
				IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) +2/(3+-4) or +2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) -2/(3+-4) or -2/(3+-4)+-
					Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-2/(3*4) or +-2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) +2/(3/4) or +2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) -2/(3/4) or -2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) +2*(3+-4) or +2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) -2*(3+-4) or -2*(3+-4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) +-2*(3/4) or +-2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))
				IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) +2/(3+-4) or +2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) -2/(3+-4) or -2/(3+-4)+-
					Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-2/(3*4) or +-2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) +2/(3/4) or +2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) -2/(3/4) or -2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) +2*(3+-4) or +2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) -2*(3+-4) or -2*(3+-4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) +-2*(3/4) or +-2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or
		2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_R3-4")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),
				Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),
					And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),
				Equal(N1, B2.L.n) )
		THEN
			Write(Right! [B2.L.n.k][B2.o.k][P1-subtree] is associative.)

		Example
		2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-4-1")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),
				Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),
					And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),
				!Equal(N1, B2.L.n) )
		THEN
			Write(You can drag [OP1.k] over [B2.L.n.k] in [B2.L.n.k][B2.o.k][P1-subtree] for association.)

		Example
		2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-
		drag '(' and drop 'number' which is not '2'
		*/

		/*
		Rule ID ("Rule_W3-4-2")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -})),
					And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),
					And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),
				    And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(Parent(B3), {E, P})) ),
				Equal(Or( Equal(N1, B2.L.n), And(Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(N1, B3.L.n))))
		THEN
			IF And(Equal(B2.R.B, B1), Equal(Parent(B2), {E, P}))
				IF(And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) 2+-(3*4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) 2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) 2-(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) 2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) 2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B2), B4))
				IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) +-2+-(3*4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) +2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) -2+(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) +-2-(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) +2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) -2+(3+-4)/*
					Write([B4.o.k] before [B2.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) +2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) -2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(Parent(B3), {E, P}))
				IF(And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) 2+-(3*4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, /)))
					ex) 2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, /)))
					ex) 2-(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) 2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) 2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B3), B4))
				IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) +-2+-(3*4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) +2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) -2+(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) +-2-(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) +2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) -2+(3+-4)/*
					Write([B4.o.k] before [B3.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) +2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) -2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*+-4)/* or +-2+-(3/*+-4)/*
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-4-3")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4)
				Or( And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(Parent(B2), {E, P})),
				    And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, -)) ),
				Equal(N1, B2.L.n) )
		THEN
			IF Equal(Parent(B2), {E, P})
				IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) 2+(3*4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) 2+(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))
					ex) 2-(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) 2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) 2-(3+-4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
			ELSE IF Equal(GParent(B2), B3)
				IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) +2+(3*4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) -2+(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) +2+(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) -2+(3/4)+-
					Write([B3.o.k] before [B2.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))
					ex) +-2-(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) +2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) -2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) +2-(3+-4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) -2-(3+-4)+-
					Write([B3.o.k] before [B2.L.n.k] must be + AND [B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*4)+- or +-2+-(3/*4)+- or 2-(3+-4)+- or +-2-(3+-4)+- or -2+(3+-4)+-
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-4-4")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B4.R, N4), Include(B2.L, B4)),
				    And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B4.R, N4), Include(B3.L, B4)) ),
				Equal(N1, B4.R.n) )
		THEN
			IF Equal(B2.R.B, B1)
				IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -}))
					ex) /*2+(3+-4)/*
					Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) /*2-(3+-4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) /*2+-(3*4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, /))
					ex) /*2+-(3/4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(B2.L.B, B1)
				IF And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -}))
					ex) /*2+(3+-4)/*
					Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) /*2-(3+-4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) /*2+-(3*4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, /))
					ex) /*2+-(3/4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-4)/*
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-4-5")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Equal(B1.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(B3.R, N4), Include(B2.L, B3)
				Equal(N1, B3.R.n) )
		THEN
			IF And(Equal(B2.o.k, +), Equal(P.B.o.k, {+, -}))
				ex)/*2+(3+-4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + for association.)
			ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, {+, -}))
				ex)/*2-(3+-4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + AND [B2.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(P.B.o.k, *)
				ex)/*2+-(3*4)+-
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B2.o.k, +), Equal(P.B.o.k, /))
				ex)/*2+(3/4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, /))
				ex)/*2-(3/4)+-
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-2)+-
		drag '(' and drop on '2'
		*/

		/*
		Rule ID ("Rule_W3-4-6")

		Rule
		IF And( Drag(OP1,N1),
				Equal(Parent(OP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or(Equal(B1.o.k, /), And(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}))
				Equal(N1, B1.L.n) )
		THEN
			IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
				ex) /*2/(3*4) or /*2/(3*4)+-
				Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))
				ex) /*2/(3/+-4) or /*2/(3/+-4)+-
				Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))
				ex) /*2*(3/+-4) or /*2*(3/+-4)+-
				Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2/(3/*+-4) or /*2/(3/*+-4)+- or /*2*(3/+-4) or /*2*(3/+-4)+-
		drag '(' and drop on '2'
		*/

		var number1 = myDropTarget;

		//Rule3-1, Rule3-2, Rule3-3 or Rule3-4
		if(myDragSource.key == '('){

			var openParenthesis1 = myDragSource;
			var parentOfOpenParenthesis1 = findParentNode(syntax, openParenthesis1);

			//Rule3-1, Rule3-2, Rule3-3 or Rule3-4
			if(parentOfOpenParenthesis1 == 'Parenthesis' && parentOfOpenParenthesis1['Binary']['Left'].hasOwnProperty('number') && parentOfOpenParenthesis1['Binary']['Right'].hasOwnProperty('number')){
				var parenthesis1 = parentOfOpenParenthesis1;
				var parentOfParenthesis1 = findParentNode(syntax, parenthesis1);
				var parentOfParentOfParenthesis1 = findParentNode(syntax, parentOfParenthesis1);

				//Rule3-1
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left'] === parentOfParenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

					//Rule3-1
					if( (parenthesis1['Binary']['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*') ){

						//Rule_R3-1
						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;
							}else if(mode == "drop"){

								rightDropMessage = "Right!\n" + parseSubtreeToString(parenthesis1)+ binary1['operator'].key + binary1['Right']['number'].key + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

								var closeParenthesisIndex = dragSourceBoxIndex + 4;  // )
								var openParenthesisIndex = dragSourceBoxIndex; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(openParenthesisIndex,1);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(closeParenthesisIndex,1);


								for(var i=openParenthesisIndex+1; i<=openParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex+2].x;
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex+2].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex].x + 2*(BOX_WIDTH+GAP);
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex+1; i<=closeParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-1-1
						else{
							myDropTarget.rules.push("R_W3-1-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + openParenthesis1.key + " over " + parenthesis1['Binary']['Right']['number'].key + " in " + parseSubtreeToString(parenthesis1)+ binary1['operator'].key + binary1['Right']['number'].key + " for association.");
							}
						}
					}

					//Rule_W3-1-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){
						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-1-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){

								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') && parenthesis1['Binary']['operator'].key == '*'){
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') && parenthesis1['Binary']['operator'].key != '*'){
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
								}
							}
						}
					}

					//Rule_W3-1-4
					var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);
					var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfParentOfBinary1);
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1 && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression'))	){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-1-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') || (parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)/5 or (3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)/5 or (3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) (3/-4)/5 or (3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)*5 or (3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) (3/-4)*5 or (3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1){
									var binary2 = parentOfParentOfBinary1;

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)/5 or +-(3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '+'){
										//ex) +(3+4)/5 or +(3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '-'){
										//ex) -(3+4)/5 or -(3+4)/5+-
										wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '+'){
										//ex) +(3/-4)/5 or +(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-'){
										//ex) -(3/-4)/5 or -(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '+'){
										//ex) +(3+4)*5 or +(3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '-'){
										//ex) -(3+4)*5 or -(3+4)*5+-
										wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +-(3/-4)*5 or +-(3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfParentOfParentOfBinary1;

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)/5 or +-(3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '+'){
										//ex) +(3+4)/5 or +(3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '-'){
										//ex) -(3+4)/5 or -(3+4)/5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary3['operator'].key == '+'){
										//ex) +(3/-4)/5 or +(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary3['operator'].key == '-'){
										//ex) -(3/-4)/5 or -(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '+'){
										//ex) +(3+4)*5 or +(3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '-'){
										//ex) -(3+4)*5 or -(3+4)*5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +-(3/-4)*5 or +-(3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}
				}

				//Rule_W3-1-2
				var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, parenthesis1);
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right'] === parentOfParenthesis1 && binaryHavingOperatorPlusOrMinus == 'Binary' && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = binaryHavingOperatorPlusOrMinus;
					if(binary1['operator'].key == '*' || binary1['operator'].key == '/'){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-1-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parenthesis1['Binary']['operator'].key == '+'){
									//ex) /*(3+4)+-5
									wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) *(3*4)+-5
									wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Right']['number'].key + " must be * for association.");

								}else{
									//ex) /*(3/-4)+-5 or /(3*4)+-5
									wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
								}
							}
						}

					}
				}

				//Rule3-2
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('Binary') && parentOfParentOfParenthesis1['Right']['Binary']['Left'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
					var binary2 = binary1['Right']['Binary'];

					//Rule3-2
					if( (parenthesis1['Binary']['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key == '+' &&(binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*')	){

						//Rule_R3-2
						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;
							}else if(mode == "drop"){

								rightDropMessage = "Right!\n" + parseSubtreeToString(parenthesis1)+ binary1['operator'].key + binary2['Left']['number'].key + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);

								var closeParenthesisIndex = dragSourceBoxIndex + 4;  // )
								var openParenthesisIndex = dragSourceBoxIndex; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(openParenthesisIndex,1);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(closeParenthesisIndex,1);


								for(var i=openParenthesisIndex+1; i<=openParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex+2].x;
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex+2].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex].x + 2*(BOX_WIDTH+GAP);
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex+1; i<=closeParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-2-1
						else{
							myDropTarget.rules.push("R_W3-2-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + openParenthesis1.key + " over " + parenthesis1['Binary']['Right']['number'].key + " in " + parseSubtreeToString(parenthesis1)+ binary1['operator'].key + binary2['Left']['number'].key + " for association.");
							}
						}
					}

				}

				//Rule_W3-2-3 or Rule_W3-2-4 or Rule_W3-2-5
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
					var binary2 = binary1['Right']['Binary'];

					//Rule_W3-2-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-2-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')){
									if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) (3/-4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfBinary1;
									if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) -(3+4)+-5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -(3*4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -(3/-4)+-5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +(3*4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +(3/-4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}
							}
						}
					}

					//Rule_W3-2-4
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && ( (binary2['operator'].key == '*' || binary2['operator'].key == '/') || binary2['Left'].hasOwnProperty('Binary') ) && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && ( (binary2['operator'].key == '*' || binary2['operator'].key == '/') || binary2['Left'].hasOwnProperty('Binary') ) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-2-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) (3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfBinary1;

									if(binary3['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +(3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +(3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) -(3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary3['operator'].key + " before " +  parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary3['operator'].key + " before " +  parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -(3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}
								}
							}
						}
					}

					//Rule_W3-2-5
					var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, binary1);
					var parentOfParentBinaryHavingOperatorPlusOrMinus = findParentNode(syntax, findParentNode(syntax, binaryHavingOperatorPlusOrMinus));
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Right'], parenthesis1) && (binaryHavingOperatorPlusOrMinus['operator'].key == '+' || binaryHavingOperatorPlusOrMinus['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Left'], parenthesis1) && parentOfParentBinaryHavingOperatorPlusOrMinus == 'Binary' && (parentOfParentBinaryHavingOperatorPlusOrMinus['operator'].key == '+' || parentOfParentBinaryHavingOperatorPlusOrMinus['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-2-5");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) (3*4)/5/* or +-(3*4)/5/*
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

								}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) (3/+-4)/5/* or +-(3/+-4)/5/*
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) (3/+-4)*5/* or +-(3/+-4)*5/*
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}

				}


				//Rule_W3-2-2
				var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, parenthesis1);
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right'] === parentOfParenthesis1 && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Left'], parenthesis1) && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = binaryHavingOperatorPlusOrMinus;
					var binary3 = binary2['Right']['Binary']
					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary3['Left'].hasOwnProperty('number'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary3['Left'].hasOwnProperty('Binary') && binary3['Left']['Binary']['Left'].hasOwnProperty('number'))	){

						if(number1 === parenthesis1['Binary']['Right']['number']){
							myDropTarget.rules.push("R_W3-2-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary3['Left'].hasOwnProperty('number') && (binary3['operator'].key == '+' || binary3['operator'].key == '-')){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5+-
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(binary3['Left'].hasOwnProperty('number') && (binary3['operator'].key == '*' || binary3['operator'].key == '/')){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5/*6
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5/*6
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5/*6
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");
									}
								}else if(binary3['Left'].hasOwnProperty('Binary')){
									var binary4  = binary3['Left']['Binary'];
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5/*6+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary4['operator'].key + " after " + binary4['Left']['number'].key + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5/*6+-
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5/*6+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");
									}
								}
							}
						}
					}
				}


				//Rule3-3
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Left'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

					//Rule3-3
					if( ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '+' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '+' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*')){

						//Rule_R3-3
						if(number1 === binary1['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;
							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" + binary1['Left']['number'].key + binary1['operator'].key + parseSubtreeToString(parenthesis1) + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex+4;  // )
								var openParenthesisIndex = dragSourceBoxIndex; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex,1);
								tempQuestion.splice(openParenthesisIndex-2,0,tempBox);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex,1);
								tempQuestion.splice(closeParenthesisIndex-2,0,tempBox);

								for(var i=openParenthesisIndex-2; i<=openParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex-2].x;
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex-2].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex].x - 2*(BOX_WIDTH+GAP);
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex-2; i<=closeParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-3-1
						else{
							myDropTarget.rules.push("R_W3-3-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + openParenthesis1.key + " over " + binary1['Left']['number'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + parseSubtreeToString(parenthesis1) + " for association.");
							}
						}
					}

					//Rule_W3-3-2
					if( ((parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '-' && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '-' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){

						if(number1 === binary1['Left']['number']){
							myDropTarget.rules.push("R_W3-3-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'){
									if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2-(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2-(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary2 = parentOfParentOfBinary1;

									if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -2+(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)
										wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2-(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2-(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2-(3+-4)
										wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}



					//Rule_W3-3-4
					var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);
					var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfParentOfBinary1);
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1 && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression'))	){

						if(number1 === binary1['Left']['number']){
							myDropTarget.rules.push("R_W3-3-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') || (parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){
									if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2/(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2/(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2/(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2*(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2*(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1){
									var binary2 = parentOfParentOfBinary1;
									if(binary2['operator'].key == '+' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2/(3+-4) or +2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2/(3+-4) or -2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2/(3*4) or +-2/(3*4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2/(3/4) or +2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2/(3/4) or -2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2*(3+-4) or +2*(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2*(3+-4) or -2*(3+-4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2*(3/4) or +-2*(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfParentOfParentOfBinary1;
									if(binary3['operator'].key == '+' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2/(3+-4) or +2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2/(3+-4) or -2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2/(3*4) or +-2/(3*4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2/(3/4) or +2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2/(3/4) or -2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2*(3+-4) or +2*(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2*(3+-4) or -2*(3+-4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2*(3/4) or +-2*(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}
				}

				//Rule_W3-3-3
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Left'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary1['Left']);
					if((binary1['operator'].key == '+' || binary1['operator'].key == '-') && binaryHavingNumberInRightChild == 'Binary'){
						var binary2 = binaryHavingNumberInRightChild;
						if(number1 === binary2['Right']['number']){
							myDropTarget.rules.push("R_W3-3-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2+(3+-4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + for association.");

								}else if(binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2-(3+-4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(parenthesis1['Binary']['operator'].key == '*'){
									//ex)/*2+-(3*4)
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2+(3/4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2-(3/4)
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}
				}


				var parentOfParentOfParentOfParentOfParenthesis1 = findParentNode(syntax, findParentNode(syntax, parentOfParentOfParenthesis1));
				//Rule3-4
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParentOfParentOfParenthesis1['Left'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);

					//Rule3-4
					if( ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '+')
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary2['operator'].key == '*')){

						//Rule_R3-4
						if(number1 === binary2['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;
							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" +binary2['Left']['number'].key + binary2['operator'].key + parseSubtreeToString(parenthesis1) + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex+4;  // )
								var openParenthesisIndex = dragSourceBoxIndex; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex,1);
								tempQuestion.splice(openParenthesisIndex-2,0,tempBox);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex,1);
								tempQuestion.splice(closeParenthesisIndex-2,0,tempBox);

								for(var i=openParenthesisIndex-2; i<=openParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex-2].x;
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex-2].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex].x - 2*(BOX_WIDTH+GAP);
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex-2; i<=closeParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}


								return;
							}
						}
						//Rule_W3-4-1
						else{
							myDropTarget.rules.push("R_W3-4-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + openParenthesis1.key + " over " + binary2['Left']['number'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + parseSubtreeToString(parenthesis1) + " for association.");
							}
						}
					}

					//Rule_W3-4-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-' && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '+' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '-')){


						if(number1 === binary2['Left']['number']){
							myDropTarget.rules.push("R_W3-4-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'){
									if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2-(3*4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2-(3+-4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary2 == 'Binary'){
									var binary3 = parentOfParentOfBinary2;

									if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +2+(3*4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -2+(3*4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2-(3*4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2-(3/4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2-(3/4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2-(3+-4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2-(3+-4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2+(3+-4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + for association.");
									}
								}
							}
						}
					}
				}

				//Rule_W3-4-2 or Rule_W3-4-4 or Rule_W3-4-5
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary'){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);
					var parentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfBinary2);
					var parentOfParentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfParentOfBinary2);

					//Rule_W3-4-2
					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && binary2['Left'].hasOwnProperty('number') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && binary2['Left'].hasOwnProperty('number') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['Left'].hasOwnProperty('number') && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && parentOfParentOfParentOfParentOfBinary2 == 'Binary' && (parentOfParentOfParentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['Left'].hasOwnProperty('number') && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && (parentOfParentOfParentOfBinary2 == 'Parenthesis' || parentOfParentOfParentOfBinary2 == 'Expression')) ){

						if(number1 === binary2['Left']['number'] || (binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && number1 === parentOfParentOfBinary2['Left']['number'])){
							myDropTarget.rules.push("R_W3-4-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['Right']['Binary'] === binary1 && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression')){
									if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Right']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary'){
									var binary4 = parentOfParentOfBinary2;
									if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary2 == 'Parenthesis' || parentOfParentOfParentOfBinary2 == 'Expression')){
									var binary3 = parentOfParentOfBinary2;

									if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}

								}else if(binary2['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary2 == 'Binary'){
									var binary3 = parentOfParentOfBinary2;
									var binary4 = parentOfParentOfParentOfParentOfBinary2;
									if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && (binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary3['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}

					//Rule_W3-4-4
					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && findBinaryHavingNumberInRightChild(binary2['Left']) == 'Binary')
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && findBinaryHavingNumberInRightChild(parentOfParentOfBinary2['Left']) == 'Binary') ){

						var binary4;
						if(binary2['Right']['Binary'] === binary1){
							binary4 = findBinaryHavingNumberInRightChild(binary2['Left']);
						}else if(binary2['Left']['Binary'] === binary1){
							binary4 = findBinaryHavingNumberInRightChild(parentOfParentOfBinary2['Left']);
						}

						if(number1 === binary4['Right']['number']){
							myDropTarget.rules.push("R_W3-4-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['Right']['Binary'] === binary1){
									if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary4['Right']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '/'){
										//ex) /*2+-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Left']['Binary'] === binary1){
									var binary3 = parentOfParentOfBinary2;
									if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary4['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '/'){
										//ex) /*2+-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}

					//Rule_W3-4-5
					var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary2['Left']);
					if((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && binaryHavingNumberInRightChild == 'Binary'){
						var binary3 = binaryHavingNumberInRightChild;
						if(number1 === binary3['Right']['number']){
							myDropTarget.rules.push("R_W3-4-5");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2+(3+-4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + for association.");

								}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2-(3+-4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + AND " + binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(parenthesis1['Binary']['operator'].key == '*'){
									//ex)/*2+-(3*4)+-
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2+(3/4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2-(3/4)+-
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}

				}

				//Rule_W3-4-6
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary'){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);

					if((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/')){
						if(number1 === binary1['Left']['number']){
							myDropTarget.rules.push("R_W3-4-6");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) /*2/(3*4) or /*2/(3*4)+-
									wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) /*2/(3/+-4) or /*2/(3/+-4)+-
									wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must * for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) /*2*(3/+-4) or /*2*(3/+-4)+-
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}
				}

			}
		}
		/*
		Rule ID ("Rule_R3-5")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))
				    And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),
				Equal(N1, P1.B.L.n) )
		THEN Write(Right! [B1.L.n.k][B1.o.k][P1-subtree] is associative.)

		Example
		2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-5-1")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(GParent(B1), B2), Equal(B2.o.k, +))
				    And(Equal(B1.o.k, {*, /}), Equal(B1.o.k, +), Equal(Parent(B1), {E, P})) ),
				!Equal(N1, P1.B.L.n) )
		THEN Write(You can drag [OP1.k] over [B1.L.n.k] in [B1.L.n.k][B1.o.k][P1-subtree] for association.)

		Example
		2+(3+-4) or +2+(3+-4) or 2*(3*4) or /*+-2*(3*4)
		drag ')' and drop on 'number' which is not '3'
		*/

		/*
		Rule ID ("Rule_W3-5-2")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, N4),
				Or( And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),
					And(Equal(P1.B.o.k, {*, /}), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P})),
					And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(GParent(B1), B2), Equal(B2.o.k, {+, -})),
				    And(Equal(P1.B.o.k, {+, -}), Equal(B1.o.k, -), Equal(Parent(B1), {E, P})) ),
				Equal(N1, P1.B.L.n) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF And(Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) 2+(3*4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) 2+(3/4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))
					ex) 2-(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) 2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) 2-(3+-4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
			ELSE IF Equal(GParent(B1), B2)
				IF And(Equal(B2.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) +2+(3*4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, *))
					ex) -2+(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) +2+(3/4)
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, +), Equal(P.B.o.k, /))
					ex) -2+(3/4)
					Write([B2.o.k] before [B1.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(P.B.o.k, *))
					ex) +-2-(3*4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) +2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, /))
					ex) -2-(3/4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, +), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) +2-(3+-4)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B1.o.k, -), Equal(B1.o.k, -), Equal(P.B.o.k, {+, -}))
					ex) -2-(3+-4)
					Write([B2.o.k] before [B1.L.n.k] must be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*4) or +-2+-(3/*4) or 2-(3+-4) or +-2-(3+-4)
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-5-3")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),
				Equal(B1.o.k, {+, -}), Equal(B2.R, N4), Include(B1.L, B2),
				Equal(N1, P1.B.L.n) )
		THEN
			IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, {+, -}))
				ex)/*2+(3+-4)
				Write([B2.o.k] before [B2.R.n.k] must be + for association.)
			ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, {+, -}))
				ex)/*2-(3+-4)
				Write([B2.o.k] before [B2.R.n.k] must be + AND [B1.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(P.B.o.k, *)
				ex)/*2+-(3*4)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, +), Equal(P1.B.o.k, /))
				ex)/*2+(3/4)
				Write([B2.o.k] before [B2.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, -), Equal(P1.B.o.k, /))
				ex)/*2-(3/4)
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-4)
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-5-4")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.L, B3),
				Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(GParent(B1, B3)), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(Parent(B1), {E, P})),
				    And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(GParent(B1), B2), Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})) ),
				Equal(N1, P1.B.L.n) )
		THEN
			IF And(Or(Equal(Parent(B1), {E, P}), And( Equal(B2.L.B, B1), Equal(Parent(B2), {E, P})))  )
				IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) 2/(3+-4) or 2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) 2/(3*4) or 2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) 2/(3/4) or 2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) 2*(3+-4) or 2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) 2*(3/4) or 2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(GParent(B1), B2), Equal(B2.R.B, B1))
				IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) +2/(3+-4) or +2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) -2/(3+-4) or -2/(3+-4)+-
					Write([B2.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-2/(3*4) or +-2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) +2/(3/4) or +2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) -2/(3/4) or -2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) +2*(3+-4) or +2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) -2*(3+-4) or -2*(3+-4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) +-2*(3/4) or +-2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(GParent(B2), B3), Equal(B2.L.B, B1), Equal(GParent(B1), B3))
				IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) +2/(3+-4) or +2/(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, {+, -}))
					ex) -2/(3+-4) or -2/(3+-4)+-
					Write([B3.o.k] before [B1.L.n].k muast be + AND [B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-2/(3*4) or +-2/(3*4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) +2/(3/4) or +2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, /), Equal(P1.B.o.k, /))
					ex) -2/(3/4) or -2/(3/4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) +2*(3+-4) or +2*(3+-4)+-
					Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B1.o.k, *), Equal(P1.B.o.k, {+, -}))
					ex) -2*(3+-4) or -2*(3+-4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B1.o.k, *), Equal(P1.B.o.k, /))
					ex) +-2*(3/4) or +-2*(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2/(3/*+-4) or +-2/(3/*+-4) or 2*(3/+-4) or +-2*(3/+-4) or
		2/(3/*+-4)+- or +-2/(3/*+-4)+- or 2*(3/+-4)+- or +-2*(3/+-4)+-
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_R3-6")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),
				Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),
					And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),
				Equal(N1, P1.B.L.n) )
		THEN
			Write(Right! [B2.L.n.k][B2.o.k][P1-subtree] is associative.)

		Example
		2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-6-1")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4),
				Or( And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, {+, -}), !Equal(B1.o.k, {*, /}), Equal(B2.o.k, +), Equal(Parent(B2), {E, P})),
					And(Equal(P1.B.o.k, *), Equal2(B2.o.k, *)) ),
				!Equal(N1, P1.B.L.n) )
		THEN
			Write(You can drag [OP1.k] over [B2.L.n.k] in [B2.L.n.k][B2.o.k][P1-subtree] for association.)

		Example
		2+(3+-4)+- or +2+(3+-4)+- or 2*(3*4)/*+- or /*+-2*(3*4)/*+-
		drag ')' and drop on 'number' which is not '3'
		*/

		/*
		Rule ID ("Rule_W3-6-2")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B4), Equal(B4.o.k, {+, -})),
					And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),
					And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),
				    And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), HasChild(B3.L, N4), Equal(B3.o.k, {+, -}), Equal(Parent(B3), {E, P})) ),
				Equal(N1, P1.B.L.n) )
		THEN
			IF And(Equal(B2.R.B, B1), Equal(Parent(B2), {E, P}))
				IF(And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) 2+-(3*4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) 2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) 2-(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) 2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) 2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B2), B4))
				IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) +-2+-(3*4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) +2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) -2+(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) +-2-(3/4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) +2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) -2+(3+-4)/*
					Write([B4.o.k] before [B2.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) +2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) -2-(3+-4)/*
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(Parent(B3), {E, P}))
				IF(And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) 2+-(3*4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, /)))
					ex) 2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, /)))
					ex) 2-(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) 2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) 2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF And(Equal(B2.R.B, B1), Equal(GParent(B3), B4))
				IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *)))
					ex) +-2+-(3*4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) +2+(3/4)/*
					Write([P1.B.o.k] in [P1-subtree] must be + or - AND [B1.o.k] after [P1-subtree] must be + or - for association. )
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /)))
					ex) -2+(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, {+, -}), Equal(B2.o.k, -), Equal(P1.B.o.k, /)))
					ex) +-2-(3/4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) +2+(3+-4)/*
					Write([B1.o.k] after [P1-subtree] must be + or - for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -})))
					ex) -2+(3+-4)/*
					Write([B4.o.k] before [B3.L.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) +2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF(And(Equal(B4.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -})))
					ex) -2-(3+-4)/*
					Write([B3.o.k] between [B3.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*+-4)/* or +-2+-(3/*+-4)/*
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-6-3")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2), HasChild(B2.L, N4)
				Or( And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {*, /}), Equal(B2.o.k, {+, -}), Equal(Parent(B2), {E, P})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, -), Equal(Parent(B2), {E, P})),
				    And(Equal(B1.o.k, {+, -}), Equal(P1.B.o.k, {+, -}), Equal(B2.o.k, +), Equal(GParent(B2), B3), Equal(B3.o.k, -)) ),
				Equal(N1, P1.B.L.n) )
		THEN
			IF Equal(Parent(B2), {E, P})
				IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) 2+(3*4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) 2+(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))
					ex) 2-(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) 2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) 2-(3+-4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
			ELSE IF Equal(GParent(B2), B3)
				IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) +2+(3*4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
					ex) -2+(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) +2+(3/4)+-
					Write([P1.B.o.k] in [P1-subtree] must be + or - for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, +), Equal(P1.B.o.k, /))
					ex) -2+(3/4)+-
					Write([B3.o.k] before [B2.L.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, *))
					ex) +-2-(3*4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) +2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(B2.o.k, -), Equal(P1.B.o.k, /))
					ex) -2-(3/4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) +2-(3+-4)+-
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, +), Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) -2-(3+-4)+-
					Write([B3.o.k] before [B2.L.n.k] must be + AND [B2.o.k] between [B2.L.n.k] and [P1-subtree] must be + for association.)
					Write([B2.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		2+-(3/*4)+- or +-2+-(3/*4)+- or 2-(3+-4)+- or +-2-(3+-4)+- or -2+(3+-4)+-
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-6-4")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or( And(Equal(B1.o.k, {*, /}), Equal(B2.R.B, B1), Equal(B2.o.k, {+, -}), Equal(B4.R, N4), Include(B2.L, B4)),
				    And(Equal(B1.o.k, {*, /}), Equal(B2.L.B, B1), Equal(GParent(B2), B3), Equal(B3.o.k, {+, -}), Equal(B4.R, N4), Include(B3.L, B4)) ),
				Equal(N1, P1.B.L.n) )
		THEN
			IF Equal(B2.R.B, B1)
				IF And(Equal(B2.o.k, +), Equal(P1.B.o.k, {+, -}))
					ex) /*2+(3+-4)/*
					Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) /*2-(3+-4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) /*2+-(3*4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B2.o.k, {+, -}), Equal(P1.B.o.k, /))
					ex) /*2+-(3/4)/*
					Write([B2.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(B2.L.B, B1)
				IF And(Equal(B3.o.k, +), Equal(P1.B.o.k, {+, -}))
					ex) /*2+(3+-4)/*
					Write([B4.o.k] before [B4.R.n.k] must be + AND [B1.o.k] after [P1-subtree] must be + or - for association.)
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -), Equal(P1.B.o.k, {+, -}))
					ex) /*2-(3+-4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) /*2+-(3*4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * for association.)
				ELSE IF And(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, /))
					ex) /*2+-(3/4)/*
					Write([B3.o.k] between [B4.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-4)/*
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-6-5")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Equal(B1.o.k, {+, -}), Equal(B2.o.k, {+, -}), Equal(B3.R, N4), Include(B2.L, B3)
				Equal(N1, P1.B.L.n) )
		THEN
			IF And(Equal(B2.o.k, +), Equal(P.B.o.k, {+, -}))
				ex)/*2+(3+-4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + for association.)
			ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, {+, -}))
				ex)/*2-(3+-4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + AND [B2.o.k] between [B2.R.n.k] and [P1-subtree] must be + for association)
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF Equal(P.B.o.k, *)
				ex)/*2+-(3*4)+-
				Write([B1.o.k] between [B2.R.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B2.o.k, +), Equal(P.B.o.k, /))
				ex)/*2+(3/4)+-
				Write([B3.o.k] before [B3.R.n.k] must be + AND [P1.B.o.k] in [P1-subtree] must be + or - for association.)
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B2.o.k, -), Equal(P.B.o.k, /))
				ex)/*2-(3/4)+-
				Write([B2.o.k] between [B3.R.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2+-(3/*+-2)+-
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_W3-6-6")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), Equal(GParent(B1), B2),
				Or(Equal(B1.o.k, /), And(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}))
				Equal(N1, P1.B.L.n) )
		THEN
			IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
				ex) /*2/(3*4) or /*2/(3*4)+-
				Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))
				ex) /*2/(3/+-4) or /*2/(3/+-4)+-
				Write([B1.o.k] between [B2.L.n.k] and [P1-subtree] must be * AND [P1.B.o.k] in [P1-subtree] must be * for association.)
			ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))
				ex) /*2*(3/+-4) or /*2*(3/+-4)+-
				Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		/*2/(3/*+-4) or /*2/(3/*+-4)+- or /*2*(3/+-4) or /*2*(3/+-4)+-
		drag ')' and drop on '3'
		*/

		/*
		Rule ID ("Rule_R3-7")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				Equal(N1, B1.R.n) )
		THEN Write(Right! [P1-subtree][B1.o.k][B1.R.n.k] is associative.)

		Example
		(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-7-1")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				!Equal(N1, B1.R.n) )
		THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B1.R.n.k] for association.)

		Example
		(3+4)+-5 or +(3+4)+-5 or (3*4)*5 or /*+-(3*4)*5
		drag ')' and drop on 'number' which is not '5'
		*/

		/*
		Rule ID ("Rule_W3-7-2")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), HasChild(B2.R, N4),
				Equal(B1.o.k, {*, /}),
				Equal(N1, B2.R.n) )
		THEN
			IF Equal(P1.B.o.k, +)
				ex) /*(3+4)+-5
				Write([B1.o.k] before [P1-subtree] must be + for association.)
			ELSE IF And(Equal(B1.o.k, *) ,Equal(P1.B.o.k, *))
				ex) *(3*4)+-5
				Write([B2.o.k] between [P1-subtree] and [B2.R.n.k] must be * for association.)
			ELSE
				ex) /*(3/-4)+-5 or /(3*4)+-5
				Write([B1.o.k] between [B1.L.n.k] and [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)

		Example
		/*(3/*+-4)+-5
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-7-3")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, -)),
					And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(GParent(B1), B2), Equal(B2.o.k, +)),
				    And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), Equal(Parent(B1), {E, P}) ),
				Equal(N1, B1.R.n) )
		THEN
			IF AND(Equal(Parent(B1), {E, P}), Equal(P1.B.o.k, *))
				ex) (3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(Parent(B1), {E, P}), !Equal(P1.B.o.k, *))
				ex) (3/-4)-+5
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, *))
				ex) -(3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([B2.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, -), Equal(P1.B.o.k, {/, -}))
				ex) -(3/-4)-+5
				Write()
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, *))
				ex) +(3*4)-+5
				Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)
			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.o.k, +), Equal(P1.B.o.k, {/, -}))
				ex) +(3/-4)-+5
				Write([P1.B.o.k] in [P1-subtree] must be + for association.)

		Example
		-(3/*+-4)+-5 or +(3/*-4)-+5 or (3/*-4)-+5
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-7-4")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, N4),
				Or( And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.R.B, B1), Equal(B2.o.k, {+, -})),
					And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3), Equal(B2.o.k, {+, -})),
					And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(Parent(B1), {P, E})),
				    And(Or(Equal(B1.o.k, /), And(Equal(P1.B.o.k, *), Equal(B1.o.k, *))), Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P})) ),
				Equal(N1, B1.R.n) )
		THEN
			IF AND(Or(Equal(Parent(B1), {E, P}), And(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(Parent(B2), {E, P}))))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) (3*4)/5 or (3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +))
					ex) (3+4)/5 or (3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}))
					ex) (3/-4)/5 or (3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +))
					ex) (3+4)*5 or (3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) (3/-4)*5 or (3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF AND(Equal(GParent(B1), B2), Equal(B2.R.B, B1))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-(3*4)/5 or +-(3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, +))
					ex) +(3+4)/5 or +(3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B2.o.k, -))
					ex) -(3+4)/5 or -(3+4)/5+-
					Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, +))
					ex) +(3/-4)/5 or +(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B2.o.k, -))
					ex) -(3/-4)/5 or -(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, +))
					ex) +(3+4)*5 or +(3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B2.o.k, -))
					ex) -(3+4)*5 or -(3+4)*5+-
					Write([B2.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) +-(3/-4)*5 or +-(3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

			ELSE IF AND(Equal(GParent(B1), B2), Equal(R2.L.B, B1), Equal(GParent(B2), B3))
				IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
					ex) +-(3*4)/5 or +-(3*4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, +))
					ex) +(3+4)/5 or +(3+4)/5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, +), Equal(B3.o.k, -))
					ex) -(3+4)/5 or -(3+4)/5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, +))
					ex) +(3/-4)/5 or +(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, /), Equal(P1.B.o.k, {/, -}), Equal(B3.o.k, -))
					ex) -(3/-4)/5 or -(3/-4)/5+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, +))
					ex) +(3+4)*5 or +(3+4)*5+-
					Write([B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, +), Equal(B3.o.k, -))
					ex) -(3+4)*5 or -(3+4)*5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [B1.o.k] between [P1-subtree] and [B1.R.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)
				ELSE IF AND(Equal(B1.o.k, *), Equal(P1.B.o.k, {/, -}))
					ex) +-(3/-4)*5 or +-(3/-4)*5+-
					Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		+-(3/*+-4)/5 or +-(3/+-4)*5 or (3/*+-4)/5 or (3/+-4)*5 or
		+-(3/*+-4)/5+- or +-(3/+-4)*5+- or (3/*+-4)/5+- or (3/+-4)*5+-
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_R3-8")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *) ),
				Equal(N1, B2.L.n) )
		THEN Write(Right! [P1-subtree][B1.o.k][B2.L.n.k] is associative.)

		Example
		(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-8-1")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
					And(Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), !Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(P1.B.o.k, *), Equal(B1.o.k, *)) ),
				!Equal(N1, B2.L.n) )
		THEN Write(You can drag [OP1.k] over [P1.B.R.n.k] in [P1-subtree][B1.o.k][B2.L.n.k] for association.)

		Example
		(3+4)+-5+- or +(3+4)+-5+- or (3*4)*5/*+- or /*+-(3*4)*5/*+-
		drag ')' and drop on 'number' which is not '5'
		*/

		/*
		Rule ID ("Rule_W3-8-2")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.R.P, P1), HasChild(B1.R, B2), Equal(B2.o.k, {+, -}), HasAncestor(P1, B2), Include(B2.L, P1), HasChild(B2.R, B3),
				Or( And(Equal(B1.o.k, {*, /}), HasChild(B3.L, N4)),
				    And(Equal(B1.o.k, {*, /}), HasChild(B3.L, B4)), HasChild(B4.L, N4)) ),
				Or( Equal(N1, B3.L.n), And(HasChild(B3.L, B4), Equal(N1, B4.L.n)) ) )
		THEN
			IF AND(Equal(B3.L, N4), Equal(B3.o.k, {+, -}))
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5+-
					Write([B1.o.k] before [P1-subtree] must be + for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5+-
					Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5+-
					Write([B1.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association.)

			ELSE IF AND(Equal(B3.L, N4), Equal(B3.o.k, {*, /}))
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5/*6
					Write([B1.o.k] before [P1-subtree] must be + AND [B3.o.k] after [B3.L.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5/*6
					Write([B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5/*6
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B3.L.n.k] must be * for association.)

			ELSE HasChild(B3.L, B4)
				IF Equal(P1.B.o.k, +)
					ex) /*(3+4)+-5/*6+-
					Write([B1.o.k] before [P1-subtree] must be + AND [B4.o.k] after [B4.L.n.k] must be + or - for association.)
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, *)
					ex) /*(3*4)+-5/*6+-
					Write([B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) /*(3/-4)+-5/*6+-
					Write([P1.B.o.k] in [P1-subtree] must be * AND [B2.o.k] between [P1-subtree] and [B4.L.n.k] must be * for association.)

		Example
		/*(3/*+-4)+-5/*+-
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-8-3")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, -)),
					And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(GParent(B1), B3), Equal(B3.o.k, +)),
				    And(!Equal(P1.B.o.k, +), Equal(B1.o.k, {+, -}), HasChild(B2.L, N4), Equal(B2.o.k, {+, -}), Equal(Parent(B1), {E, P})) ),
				Equal(N1, B2.L.n) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF Equal(P1.B.o.k, *)
					ex)	(3*4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association.)
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) (3/-4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association.)

			ELSE IF  Equal(GParent(B1), B3)
				IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, +))
					ex)	-(3+4)+-5+-
					Write([B3.o.k] before [P1-subtree] must be + for association.)
				ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, *))
					ex)	-(3*4)+-5+-
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF And(Equal(B3.o.k, -),  Equal(P1.B.o.k, {/, -}))
					ex)	-(3/-4)+-5+-
					Write([B3.o.k] before [P1-subtree] must be + AND [P1.B.o.k] in [P1-subtree] must be + for association)
				ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, *))
					ex)	+(3*4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association)
					Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
				ELSE IF And(Equal(B3.o.k, +),  Equal(P1.B.o.k, {/, -}))
					ex)	+(3/-4)+-5+-
					Write([P1.B.o.k] in [P1-subtree] must be + for association)

		Example
		 -(3/*+-4)+-5+- or +(3/*-4)+-5+- or (3/*-4)+-5+-
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-8-4")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(GParent(B1), B3), Equal(B3.o.k, {+, -})),
				    And(Equal(B1.o.k, {+, -}), Or(Equal(B2.o.k, {*, /}) , HasChild(B2.L, B4)), Equal(Parent(B1), {E, P})) ),
				Or( Equal(N1, B2.L.n), And(HasChild(B2.L, B4), Equal(N1, B4.L.n)) ) )
		THEN
			IF Equal(Parent(B1), {E, P})
				IF Equal(P1.B.o.k, +)
					ex) (3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

				ELSE IF Equal(P1.B.o.k, *)
					ex) (3*4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF Equal(P1.B.o.k, {/, -})
					ex) (3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

			ELSE IF Equal(GParent(B1), B3)
				IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, +))
					ex) +(3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B2.o.k] after [B2.L.n.k] must be + or - for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)

				ELSE IF AND(Equal(B3.o.k, {+, -}), Equal(P1.B.o.k, *))
					ex) +-(3*4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B1.L.B.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, +), Equal(P1.B.o.k, {/, -}))
					ex) +(3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, +))
					ex) -(3+4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([B3.o.k] before [P1-subtree] must be + AND [B2.o.k] after [B2.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([B3.o.k] before [P1-subtree] must be + AND [B2.L.B.o.k] after [B2.L.B.L.n.k] must be + or - for association.)
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

				ELSE IF AND(Equal(B3.o.k, -), Equal(P1.B.o.k, {/, -}))
					ex) -(3/-4)+-5/*
					IF Equal(B2.o.k, {*, /})
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
					ELSE IF Equal(HasChild(B2.L, B4))
						Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.B.L.n.k] must be * for association.)

		Example
		+-(3/*+-4)+-5/* or (3/*+-4)+-5/*
		drag ')' and drop on '5'
		*/

		/*
		Rule ID ("Rule_W3-8-5")

		Rule
		IF And( Drag(CP1,N1),
				Equal(Parent(CP1), P1), HasChild(P1.B.L, N2), HasChild(P1.B.R, N3),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Equal(GParent(P1), B1), Equal(B1.L.P, P1), HasChild(B1.R, B2),
				Or( And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.R, P1), Equal(B3.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(B3.o, {+, -}), HasAncestor(B1, B3), Include(B3.L, P1), Equal(GParent(B3), B4), Equal(B4.o.k, {+, -})),
					And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(Parent(B1), {E, P})),
				    And(Equal(B1.o.k, /), Or(!Equal(P1.B.o.k, *), Equal(B1.o.k, *)), Equal(B2.o.k, {*, /}), Equal(GParent(B1), B3), Equal(B3.L.B, B1), Equal(Parent(B3), {E, P})) ),
				Equal(N1, B2.L.n) )
		THEN
			IF And(Equal(B1.o.k, /), Equal(P1.B.o.k, *))
				ex) (3*4)/5/* or +-(3*4)/5/*
				Write([B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
			ELSE IF And(Equal(B1.o.k, /), !Equal(P1.B.o.k, *))
				ex) (3/+-4)/5/* or +-(3/+-4)/5/*
				Write([P1.B.o.k] in [P1-subtree] must be * AND [B1.o.k] between [P1-subtree] and [B2.L.n.k] must be * for association.)
			ELSE IF And(Equal(B1.o.k, *), !Equal(P1.B.o.k, *))
				ex) (3/+-4)*5/* or +-(3/+-4)*5/*
				Write([P1.B.o.k] in [P1-subtree] must be * for association.)

		Example
		+-(3/*+-4)/5/* or +-(3/+-4)*5/* or (3/*+-4)/5/* or (3/+-4)*5/*
		drag ')' and drop on '5'
		*/

		//Rule3-5, Rule3-6, Rule3-7 or Rule3-8
		if(myDragSource.key == ')'){
			var closeParenthesis1 = myDragSource;
			var parentOfCloseParenthesis = findParentNode(syntax, closeParenthesis1);

			//Rule3-5, Rule3-6, Rule3-7 or Rule3-8
			if(parentOfCloseParenthesis == 'Parenthesis' && parentOfCloseParenthesis['Binary']['Left'].hasOwnProperty('number') && parentOfCloseParenthesis['Binary']['Right'].hasOwnProperty('number')){
				var parenthesis1 = parentOfCloseParenthesis;
				var parentOfParenthesis1 = findParentNode(syntax, parenthesis1);
				var parentOfParentOfParenthesis1 = findParentNode(syntax, parentOfParenthesis1);

				//Rule3-5
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Left'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

					//Rule3-5
					if( ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '+' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '+' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*')){

						//Rule_R3-5
						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-5");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;

							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" + binary1['Left']['number'].key + binary1['operator'].key + parseSubtreeToString(parenthesis1) + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex;  // )
								var openParenthesisIndex = dragSourceBoxIndex - 4; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex,1);
								tempQuestion.splice(openParenthesisIndex-2,0,tempBox);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex,1);
								tempQuestion.splice(closeParenthesisIndex-2,0,tempBox);

								for(var i=openParenthesisIndex-2; i<=openParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex].x - 2*(BOX_WIDTH+GAP);
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex-2].x;
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex-2].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex-2; i<=closeParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-5-1
						else{
							myDropTarget.rules.push("R_W3-5-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + closeParenthesis1.key + " over " +parenthesis1['Binary']['Left']['number'].key + " in " + binary1['Left']['number'].key + binary1['operator'].key + parseSubtreeToString(parenthesis1) + " for association.");
							}
						}
					}

					//Rule_W3-5-2
					if( ((parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '-' && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '-' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key == '+' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-') ){

						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-5-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'){
									if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2-(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2-(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary2 = parentOfParentOfBinary1;

									if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -2+(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)
										wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2-(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2-(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2-(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2-(3+-4)
										wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2+(3+-4)
										wrongDropMessages.push(binary2['operator'].key + " before " + binary1['Left']['number'].key + " must be + for association.");
									}
								}
							}
						}
					}

					//Rule_W3-5-4
					var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);
					var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfParentOfBinary1);
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1 && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression'))	){

						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-5-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') || (parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){
									if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2/(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2/(3*4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2/(3/4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2*(3+-4)
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2*(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1){
									var binary2 = parentOfParentOfBinary1;
									if(binary2['operator'].key == '+' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2/(3+-4) or +2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2/(3+-4) or -2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2/(3*4) or +-2/(3*4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2/(3/4) or +2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2/(3/4) or -2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2*(3+-4) or +2*(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2*(3+-4) or -2*(3+-4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2*(3/4) or +-2*(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfParentOfParentOfBinary1;
									if(binary3['operator'].key == '+' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2/(3+-4) or +2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2/(3+-4) or -2/(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " before " + binary1['Left']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2/(3*4) or +-2/(3*4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2/(3/4) or +2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2/(3/4) or -2/(3/4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2*(3+-4) or +2*(3+-4)+-
										wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2*(3+-4) or -2*(3+-4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2*(3/4) or +-2*(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}

				}

				//Rule_W3-5-3
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Left'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary1['Left']);
					if((binary1['operator'].key == '+' || binary1['operator'].key == '-') && binaryHavingNumberInRightChild == 'Binary'){
						var binary2 = binaryHavingNumberInRightChild;
						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-5-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2+(3+-4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + or - for association.");

								}else if(binary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2-(3+-4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + AND " + binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(parenthesis1['Binary']['operator'].key == '*'){
									//ex)/*2+-(3*4)
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2+(3/4)
									wrongDropMessages.push(binary2['operator'].key + " before " + binary2['Right']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2-(3/4)
									wrongDropMessages.push(binary1['operator'].key + " between " + binary2['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}
				}


				var parentOfParentOfParentOfParentOfParenthesis1 = findParentNode(syntax, findParentNode(syntax, parentOfParentOfParenthesis1));
				//Rule3-6
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParentOfParentOfParenthesis1['Left'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);

					//Rule3-6
					if( ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '+')
						|| ((parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary1['operator'].key != '*' && binary1['operator'].key != '/' && binary2['operator'].key == '+' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary2['operator'].key == '*')){

						//Rule_R3-6
						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-6");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;

							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" +binary2['Left']['number'].key + binary2['operator'].key + parseSubtreeToString(parenthesis1) + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex;  // )
								var openParenthesisIndex = dragSourceBoxIndex - 4; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex,1);
								tempQuestion.splice(openParenthesisIndex-2,0,tempBox);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex,1);
								tempQuestion.splice(closeParenthesisIndex-2,0,tempBox);

								for(var i=openParenthesisIndex-2; i<=openParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex].x - 2*(BOX_WIDTH+GAP);
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex-2].x;
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex-2].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex-2; i<=closeParenthesisIndex-1; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x + (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-6-1
						else{
							myDropTarget.rules.push("R_W3-6-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + closeParenthesis1.key + " over " +parenthesis1['Binary']['Left']['number'].key + " in " + binary2['Left']['number'].key + binary2['operator'].key + parseSubtreeToString(parenthesis1) + " for association.");
							}
						}
					}

					//Rule_W3-6-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '*' || parenthesis1['Binary']['operator'].key == '/') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-' && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-' && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '+' && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['operator'].key == '-')){


						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-6-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'){
									if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+(3*4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2-(3*4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) 2-(3+-4)
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary2 == 'Binary'){
									var binary3 = parentOfParentOfBinary2;

									if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +2+(3*4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -2+(3*4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2-(3*4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2-(3/4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2-(3/4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +2-(3+-4)+-
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2-(3+-4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -2+(3+-4)+-
										wrongDropMessages.push(binary3['operator'].key + " before " + binary2['Left']['number'].key + " must be + for association.");
									}
								}
							}
						}
					}

				}

				//Rule_W3-6-2 or Rule_W3-6-4 or Rule_W3-6-5
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary'){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);
					var parentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfBinary2);
					var parentOfParentOfParentOfParentOfBinary2 = findParentNode(syntax, parentOfParentOfParentOfBinary2);

					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && binary2['Left'].hasOwnProperty('number') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && binary2['Left'].hasOwnProperty('number') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['Left'].hasOwnProperty('number') && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && parentOfParentOfParentOfParentOfBinary2 == 'Binary' && (parentOfParentOfParentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary2['operator'].key == '-'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && parentOfParentOfBinary2['Left'].hasOwnProperty('number') && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && (parentOfParentOfParentOfBinary2 == 'Parenthesis' || parentOfParentOfParentOfBinary2 == 'Expression')) ){

						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-6-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['Right']['Binary'] === binary1 && (parentOfBinary2 == 'Parenthesis' || parentOfBinary2 == 'Expression')){
									if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Right']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary'){
									var binary4 = parentOfParentOfBinary2;
									if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary2['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary2['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary2 == 'Parenthesis' || parentOfParentOfParentOfBinary2 == 'Expression')){
									var binary3 = parentOfParentOfBinary2;

									if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) 2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) 2-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) 2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}

								}else if(binary2['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary2 == 'Binary'){
									var binary3 = parentOfParentOfBinary2;
									var binary4 = parentOfParentOfParentOfParentOfBinary2;
									if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && (binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +2+(3/4)/*
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) -2+(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary4['operator'].key == '+' || binary4['operator'].key == '-') && binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +-2-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2+(3+-4)/*
										wrongDropMessages.push(binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary3['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '+' && binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) +2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary4['operator'].key == '-' && binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-') ){
										//ex) -2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary3['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}

					//Rule_W3-6-4
					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Right']['Binary'] === binary1 && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && findBinaryHavingNumberInRightChild(binary2['Left']) == 'Binary')
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary2['Left']['Binary'] === binary1 && parentOfParentOfBinary2 == 'Binary' && (parentOfParentOfBinary2['operator'].key == '+' || parentOfParentOfBinary2['operator'].key == '-') && findBinaryHavingNumberInRightChild(parentOfParentOfBinary2['Left']) == 'Binary') ){

						var binary4;
						if(binary2['Right']['Binary'] === binary1){
							binary4 = findBinaryHavingNumberInRightChild(binary2['Left']);
						}else if(binary2['Left']['Binary'] === binary1){
							binary4 = findBinaryHavingNumberInRightChild(parentOfParentOfBinary2['Left']);
						}

						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-6-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['Right']['Binary'] === binary1){
									if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary4['Right']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2-(3+-4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*2+-(3*4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary2['operator'].key == '+' || binary2['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '/'){
										//ex) /*2+-(3/4)/*
										wrongDropMessages.push(binary2['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(binary2['Left']['Binary'] === binary1){
									var binary3 = parentOfParentOfBinary2;

									if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2+(3+-4)/*
										wrongDropMessages.push(binary4['operator'].key + " before " + binary4['Left']['number'].key + " must be + AND " + binary1['operator'].key + " after " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) /*2-(3+-4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*2+-(3*4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '/'){
										//ex) /*2+-(3/4)/*
										wrongDropMessages.push(binary3['operator'].key + " between " + binary4['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}

					//Rule_W3-6-5
					var binaryHavingNumberInRightChild = findBinaryHavingNumberInRightChild(binary2['Left']);
					if((binary1['operator'].key == '+' || binary1['operator'].key == '-') && (binary2['operator'].key == '+' || binary2['operator'].key == '-') && binaryHavingNumberInRightChild == 'Binary'){
						var binary3 = binaryHavingNumberInRightChild;
						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-6-5");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary2['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2+(3+-4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + for association.");

								}else if(binary2['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '+' || parenthesis1['Binary']['operator'].key == '-')){
									//ex)/*2-(3+-4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + AND " + binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(parenthesis1['Binary']['operator'].key == '*'){
									//ex)/*2+-(3*4)+-
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary2['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2+(3/4)+-
									wrongDropMessages.push(binary3['operator'].key + " before " + binary3['Right']['number'].key + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + or - for association.");
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary2['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '/'){
									//ex)/*2-(3/4)+-
									wrongDropMessages.push(binary2['operator'].key + " between " + binary3['Right']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								};
							}
						}
					}
				}

				//Rule_W3-6-6
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right']['Parenthesis'] === parenthesis1 && parentOfParentOfParentOfParentOfParenthesis1 == 'Binary'){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = parentOfParentOfParentOfParentOfParenthesis1;
					var parentOfBinary2 = findParentNode(syntax, binary2);
					var parentOfParentOfBinary2 = findParentNode(syntax, parentOfBinary2);

					if((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/')){
						if(number1 === parenthesis1['Binary']['Left']['number']){
							myDropTarget.rules.push("R_W3-6-6");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) /*2/(3*4) or /*2/(3*4)+-
									wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * for association.");

								}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) /*2/(3/+-4) or /*2/(3/+-4)+-
									wrongDropMessages.push(binary1['operator'].key + " between " + binary1['Left']['number'].key + " and " + parseSubtreeToString(parenthesis1) + " must be * AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must * for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) /*2*(3/+-4) or /*2*(3/+-4)+-
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}
				}

				//Rule3-7
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);

					//Rule3-7
					if( (parenthesis1['Binary']['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key == '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*') ){

						//Rule_R3-7
						if(number1 === binary1['Right']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-7");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;

							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" + parseSubtreeToString(parenthesis1) + binary1['operator'].key + binary1['Right']['number'].key + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex;  // )
								var openParenthesisIndex = dragSourceBoxIndex - 4; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(openParenthesisIndex,1);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(closeParenthesisIndex,1);


								for(var i=openParenthesisIndex+1; i<=openParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex].x + 2*(BOX_WIDTH+GAP);
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex+2].x;
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex+2].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);

								for(var i=closeParenthesisIndex+1; i<=closeParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-7-1
						else{
							myDropTarget.rules.push("R_W3-7-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + closeParenthesis1.key + " over " + binary1['Right']['number'].key + " in " + parseSubtreeToString(parenthesis1) + binary1['operator'].key + binary1['Right']['number'].key + " for association.");
							}
						}
					}

					//Rule_W3-7-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){
						if(number1 === binary1['Right']['number']){
							myDropTarget.rules.push("R_W3-7-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){

								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') && parenthesis1['Binary']['operator'].key == '*'){
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') && parenthesis1['Binary']['operator'].key != '*'){
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + parenthesis1['Binary']['Right']['number'].key + " must be * for association.");
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
									var binary2 = parentOfParentOfBinary1;
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
								}
							}
						}
					}

					//Rule_W3-7-4
					var parentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfBinary1);
					var parentOfParentOfParentOfParentOfBinary1 = findParentNode(syntax, parentOfParentOfParentOfBinary1);
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1 && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary' && (parentOfParentOfParentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfParentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression'))	){

						if(number1 === binary1['Right']['number']){
							myDropTarget.rules.push("R_W3-7-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression') || (parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)/5 or (3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)/5 or (3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) (3/-4)/5 or (3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)*5 or (3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) (3/-4)*5 or (3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Right']['Binary'] === binary1){
									var binary2 = parentOfParentOfBinary1;

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)/5 or +-(3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '+'){
										//ex) +(3+4)/5 or +(3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '-'){
										//ex) -(3+4)/5 or -(3+4)/5+-
										wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '+'){
										//ex) +(3/-4)/5 or +(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary2['operator'].key == '-'){
										//ex) -(3/-4)/5 or -(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '+'){
										//ex) +(3+4)*5 or +(3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key == '-'){
										//ex) -(3+4)*5 or -(3+4)*5+-
										wrongDropMessages.push(binary2['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +-(3/-4)*5 or +-(3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && parentOfParentOfParentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfParentOfParentOfBinary1;

									if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)/5 or +-(3*4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '+'){
										//ex) +(3+4)/5 or +(3+4)/5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '-'){
										//ex) -(3+4)/5 or -(3+4)/5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary3['operator'].key == '+'){
										//ex) +(3/-4)/5 or +(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '/' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-') && binary3['operator'].key == '-'){
										//ex) -(3/-4)/5 or -(3/-4)/5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '+'){
										//ex) +(3+4)*5 or +(3+4)*5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '+' && binary3['operator'].key == '-'){
										//ex) -(3+4)*5 or -(3+4)*5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary1['Right']['number'].key + " must be + or - for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");

									}else if(binary1['operator'].key == '*' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +-(3/-4)*5 or +-(3/-4)*5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
									}
								}
							}
						}
					}


				}

				//Rule_W3-7-2
				var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, parenthesis1);
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right'] === parentOfParenthesis1 && binaryHavingOperatorPlusOrMinus == 'Binary' && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('number')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = binaryHavingOperatorPlusOrMinus;
					if(binary1['operator'].key == '*' || binary1['operator'].key == '/'){
						if(number1 === binary2['Right']['number']){
							myDropTarget.rules.push("R_W3-7-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parenthesis1['Binary']['operator'].key == '+'){
									//ex) /*(3+4)+-5
									wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) *(3*4)+-5
									wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Right']['number'].key + " must be * for association.");

								}else{
									//ex) /*(3/-4)+-5 or /(3*4)+-5
									wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
								}
							}
						}

					}
				}

				//Rule3-8
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('Binary') && parentOfParentOfParenthesis1['Right']['Binary']['Left'].hasOwnProperty('number')){

					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
					var binary2 = binary1['Right']['Binary'];

					//Rule3-8
					if( (parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key != '*' && binary2['operator'].key != '/' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key == '+' && binary2['operator'].key != '*' && binary2['operator'].key != '/' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| (parenthesis1['Binary']['operator'].key == '*' && binary1['operator'].key == '*')	){

						//Rule_R3-8
						if(number1 === binary2['Left']['number']){
							myDropTarget.rules = [];
							myDropTarget.rules.push("R_R3-8");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = true;
								return;

							}else if(mode == "drop"){
								rightDropMessage = "Right!\n" + parseSubtreeToString(parenthesis1) + binary2['operator'].key + binary2['Left']['number'].key + " is associative.";

								var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
								var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

								var closeParenthesisIndex = dragSourceBoxIndex;  // )
								var openParenthesisIndex = dragSourceBoxIndex - 4; // (

								tempQuestion = getCloneQuestion(myQuestion);

								var tempBox = tempQuestion[openParenthesisIndex];
								tempQuestion.splice(openParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(openParenthesisIndex,1);

								tempBox = tempQuestion[closeParenthesisIndex];
								tempQuestion.splice(closeParenthesisIndex+3,0,tempBox);
								tempQuestion.splice(closeParenthesisIndex,1);


								for(var i=openParenthesisIndex+1; i<=openParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								myQuestion[openParenthesisIndex].animationType = 'linearMotion';
								myQuestion[openParenthesisIndex].destinationX = myQuestion[openParenthesisIndex].x + 2*(BOX_WIDTH+GAP);
								myQuestion[openParenthesisIndex].destinationY = myQuestion[openParenthesisIndex].y;
								myQuestion[openParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[openParenthesisIndex]);

								myQuestion[closeParenthesisIndex].animationType = 'linearMotion';
								myQuestion[closeParenthesisIndex].destinationX = myQuestion[closeParenthesisIndex+2].x;
								myQuestion[closeParenthesisIndex].destinationY = myQuestion[closeParenthesisIndex+2].y;
								myQuestion[closeParenthesisIndex].isAnimating = true;
								setAnimationAceleration(myQuestion[closeParenthesisIndex]);


								for(var i=closeParenthesisIndex+1; i<=closeParenthesisIndex+2; i++){
									myQuestion[i].animationType = 'linearMotion';
									myQuestion[i].destinationX = myQuestion[i].x - (BOX_WIDTH+GAP);
									myQuestion[i].destinationY = myQuestion[i].y;
									myQuestion[i].isAnimating = true;
									setAnimationAceleration(myQuestion[i]);
								}

								return;
							}
						}
						//Rule_W3-8-1
						else{
							myDropTarget.rules.push("R_W3-8-1");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								wrongDropMessages.push("You can drag " + closeParenthesis1.key + " over " + binary2['Left']['number'].key + " in " + parseSubtreeToString(parenthesis1) + binary2['operator'].key + binary2['Left']['number'].key + " for association.");
							}
						}
					}
				}

				//Rule_W3-8-3 or Rule_W3-8-4 or Rule_W3-8-5
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Left']['Parenthesis'] === parenthesis1 && parentOfParentOfParenthesis1['Right'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var parentOfBinary1 = findParentNode(syntax, binary1);
					var parentOfParentOfBinary1 = findParentNode(syntax, parentOfBinary1);
					var binary2 = binary1['Right']['Binary'];

					//Rule_W3-8-3
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '-')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['operator'].key == '+')
						|| (parenthesis1['Binary']['operator'].key != '+' && (binary1['operator'].key == '+' || binary1['operator'].key == '-') && binary2['Left'].hasOwnProperty('number') && binary2['operator'].key != '*' && binary2['operator'].key != '/' && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){

						if(number1 === binary2['Left']['number']){
							myDropTarget.rules.push("R_W3-8-3");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if((parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')){
									if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) (3/-4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfBinary1;
									if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) -(3+4)+-5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) -(3*4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -(3/-4)+-5+-
										wrongDropMessages.push(binary3['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(binary3['operator'].key == '+' && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +(3*4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
										wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +(3/-4)+-5+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}
							}
						}
					}

					//Rule_W3-8-4
					if( ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && ( (binary2['operator'].key == '*' || binary2['operator'].key == '/') || binary2['Left'].hasOwnProperty('Binary') ) && parentOfParentOfBinary1 == 'Binary' && (parentOfParentOfBinary1['operator'].key == '+' || parentOfParentOfBinary1['operator'].key == '-'))
						|| ((binary1['operator'].key == '+' || binary1['operator'].key == '-') && ( (binary2['operator'].key == '*' || binary2['operator'].key == '/') || binary2['Left'].hasOwnProperty('Binary') ) && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression')) ){

						if(number1 === binary2['Left']['number'] || (binary2['Left'].hasOwnProperty('Binary') && number1 === binary2['Left']['Binary']['Left']['number']) ){
							myDropTarget.rules.push("R_W3-8-4");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) (3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) (3*4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) (3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}
								}else if(parentOfParentOfBinary1 == 'Binary'){
									var binary3 = parentOfParentOfBinary1;

									if(binary3['operator'].key == '*' && parenthesis1['Binary']['operator'].key == '/'){
										//ex) +(3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if((binary3['operator'].key == '+' || binary3['operator'].key == '-') && parenthesis1['Binary']['operator'].key == '*'){
										//ex) +-(3*4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(binary3['operator'].key == '+' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) +(3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
										}
									}else if(binary3['operator'].key == '-' && parenthesis1['Binary']['operator'].key == '+'){
										//ex) -(3+4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(binary3['operator'].key + " before " +  parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['operator'].key + " after " + binary2['Left']['number'].key + " must be + or - for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(binary3['operator'].key + " before " +  parseSubtreeToString(parenthesis1) + " must be + AND " + binary2['Left']['Binary']['operator'].key + " after " + binary2['Left']['Binary']['Left']['number'].key + " must be + or - for association.");
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}else if(binary3['operator'].key == '-' && (parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-')){
										//ex) -(3/-4)+-5/*
										if(binary2['operator'].key == '*' || binary2['operator'].key == '/'){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");
										}else if(binary2['Left'].hasOwnProperty('Binary')){
											wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['Binary']['Left']['number'].key + " must be * for association.");
										}
									}
								}
							}
						}
					}

					//Rule_W3-8-5
					var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, binary1);
					var parentOfParentBinaryHavingOperatorPlusOrMinus = findParentNode(syntax, findParentNode(syntax, binaryHavingOperatorPlusOrMinus));
					if( ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Right'], parenthesis1) && (binaryHavingOperatorPlusOrMinus['operator'].key == '+' || binaryHavingOperatorPlusOrMinus['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Left'], parenthesis1) && parentOfParentBinaryHavingOperatorPlusOrMinus == 'Binary' && (parentOfParentBinaryHavingOperatorPlusOrMinus['operator'].key == '+' || parentOfParentBinaryHavingOperatorPlusOrMinus['operator'].key == '-'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && (parentOfBinary1 == 'Parenthesis' || parentOfBinary1 == 'Expression'))
						|| ((binary1['operator'].key == '/' || (parenthesis1['Binary']['operator'].key != '*' && binary1['operator'].key == '*')) && (binary2['operator'].key == '*' || binary2['operator'].key == '/') && parentOfParentOfBinary1 == 'Binary' && parentOfParentOfBinary1['Left']['Binary'] === binary1 && (parentOfParentOfParentOfBinary1 == 'Parenthesis' || parentOfParentOfParentOfBinary1 == 'Expression')) ){

						if(number1 === binary2['Left']['number']){
							myDropTarget.rules.push("R_W3-8-5");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key == '*'){
									//ex) (3*4)/5/* or +-(3*4)/5/*
									wrongDropMessages.push(binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

								}else if(binary1['operator'].key == '/' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) (3/+-4)/5/* or +-(3/+-4)/5/*
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must * AND " + binary1['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary2['Left']['number'].key + " must be * for association.");

								}else if(binary1['operator'].key == '*' && parenthesis1['Binary']['operator'].key != '*'){
									//ex) (3/+-4)*5/* or +-(3/+-4)*5/*
									wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * for association.");
								}
							}
						}
					}

				}

				//Rule_W3-8-2
				var binaryHavingOperatorPlusOrMinus = findAncestorBinaryHavingOperatorPlusOrMinus(syntax, parenthesis1);
				if(parentOfParentOfParenthesis1 == 'Binary' && parentOfParentOfParenthesis1['Right'] === parentOfParenthesis1 && binaryHavingOperatorPlusOrMinus == 'Binary' && hasNode(binaryHavingOperatorPlusOrMinus['Left'], parenthesis1) && binaryHavingOperatorPlusOrMinus['Right'].hasOwnProperty('Binary')){
					var binary1 = parentOfParentOfParenthesis1;
					var binary2 = binaryHavingOperatorPlusOrMinus;
					var binary3 = binary2['Right']['Binary']
					if( ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary3['Left'].hasOwnProperty('number'))
						|| ((binary1['operator'].key == '*' || binary1['operator'].key == '/') && binary3['Left'].hasOwnProperty('Binary') && binary3['Left']['Binary']['Left'].hasOwnProperty('number'))	){

						if(number1 === binary3['Left']['number'] || (binary3['Left'].hasOwnProperty('Binary') && number1 === binary3['Left']['Binary']['Left']['number'])){
							myDropTarget.rules.push("R_W3-8-2");
							if(mode == "drag"){
								myDropTarget.isCandidate = true;
								myDropTarget.isRightRule = false;
							}else if(mode == "drop"){
								if(binary3['Left'].hasOwnProperty('number') && (binary3['operator'].key == '+' || binary3['operator'].key == '-')){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5+-
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be + for association.");
									}
								}else if(binary3['Left'].hasOwnProperty('number') && (binary3['operator'].key == '*' || binary3['operator'].key == '/')){
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5/*6
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary3['operator'].key + " after " + binary3['Left']['number'].key + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5/*6
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5/*6
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary3['Left']['number'].key + " must be * for association.");
									}
								}else if(binary3['Left'].hasOwnProperty('Binary')){
									var binary4  = binary3['Left']['Binary'];
									if(parenthesis1['Binary']['operator'].key == '+'){
										//ex) /*(3+4)+-5/*6+-
										wrongDropMessages.push(binary1['operator'].key + " before " + parseSubtreeToString(parenthesis1) + " must be + AND " + binary4['operator'].key + " after " + binary4['Left']['number'].key + " must be + for association.");
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '*'){
										//ex) /*(3*4)+-5/*6+-
										wrongDropMessages.push(binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");

									}else if(parenthesis1['Binary']['operator'].key == '/' || parenthesis1['Binary']['operator'].key == '-'){
										//ex) /*(3/-4)+-5/*6+-
										wrongDropMessages.push(parenthesis1['Binary']['operator'].key + " in " + parseSubtreeToString(parenthesis1) + " must be * AND " + binary2['operator'].key + " between " + parseSubtreeToString(parenthesis1) + " and " + binary4['Left']['number'].key + " must be * for association.");
									}
								}
							}
						}
					}
				}
			}
		}
	}

	if(dragSourceType == 'number' && dropTargetType == 'parenthesis'){//If user drags one Number(N1) onto ‘(‘ or ‘)’

		/*
		Rule ID ("Rule_R4-3")

		Rule
		IF And( Drag(N1,OP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),
					And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				Equal(OP1, P1.open) );
		THEN Write(Right! [P1-subtree] is distributive.)

		Example
		(3*4+-4*5)
		drag '4' and drop on '('
		*/

		/*
		Rule ID ("Rule_W4-3-1")

		Rule
		IF And( Drag(N1,OP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),
					And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				!Equal(OP1, P1.open) );
		THEN Write(Right! [P1-subtree] is distributive.)

		Example
		(3*4+-4*5)
		drag '4' and drop on '(' which is not in (3*4+-4*5)
		*/

		/*
		Rule ID ("Rule_W4-3-2")

		Rule
		IF And( Drag(N1,OP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				!Or( And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				Equal(OP1, P1.open) );
		THEN
			IF Equal(Include(P1.B.L, N1))
				Write(A multiple of N1 must be in [P1.B.R-subtree] for distribution.)
			ELSE
				Write(A multiple of N1 must be in [P1.B.L-subtree] for distribution.)

		Example
		(3*4+-5*6)
		drag '4' and drop on '('
		*/

		/*
		Rule ID ("Rule_R4-4")

		Rule
		IF And( Drag(N1,CP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),
					And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				Equal(CP1, P1.close) );
		THEN Write(Right! <P1-subtree> is distributive.)

		Example
		(3*4+-4*5)
		drag '4' and drop on ')'
		*/

		/*
		Rule ID ("Rule_W4-4-1")

		Rule
		IF And( Drag(N1,CP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				Or( And(Include(P1.B.L, N1), Include(P1.B.R, N1.k)),
					And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				!Equal(CP1, P1.close) );
		THEN Write(You can drag [N1.k] over [CP1.k] in [P1-subtree] for distribution.)

		Example
		(3*4+-4*5)
		drag '4' and drop on ')'
		*/

		/*
		Rule ID ("Rule_W4-3-2")

		Rule
		IF And( Drag(N1,CP1),
				HasAncestor(N1, P1), Equal(P1.B.o.k, {+, -})
				!Or( And(Include(P1.B.L, N1), Include(P1.B.R, Multiple(N1.k))),
					And(Include(P1.B.R, N1), Include(P1.B.L, Multiple(N1.k))) )
				Equal(CP1, P1.close) );
		THEN
			IF Equal(Include(P1.B.L, N1))
				Write(A multiple of N1 must be in [P1.B.R-subtree] for distribution.)
			ELSE
				Write(A multiple of N1 must be in [P1.B.L-subtree] for distribution.)

		Example
		(3*4+-5*6)
		drag '4' and drop on '('
		*/

		var number1 = myDragSource;
		//Rule4-3
		if(myDropTarget.key == "("){
			var openParenthesis1 = myDropTarget;
			var parenthesisWithNumber1 = findAncestorNode(syntax, 'Parenthesis', number1);

			//Rule4-3
			if(parenthesisWithNumber1 == 'Parenthesis' && (parenthesisWithNumber1['Binary']['operator'].key == '+' || parenthesisWithNumber1['Binary']['operator'].key == '-') ){
				var parenthesis1 = parenthesisWithNumber1;

				if( (hasNode(parenthesis1['Binary']['Left'], number1) && hasSameKeyValue(parenthesis1['Binary']['Right'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Left'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Right'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasSameKeyValue(parenthesis1['Binary']['Left'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Left'], number1.key)) ){

					//Rule_R4-3
					if(openParenthesis1 == parenthesis1['open']){
						myDropTarget.rules = [];
						myDropTarget.rules.push("R_R4-3");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = true;
							return;

						}else if(mode == "drop"){
							rightDropMessage = "Right!\n"+ parseSubtreeToString(parenthesis1) + " is distributive.";

							var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
							var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

							var numberAvailableForDistributiveIndex = -1;
							var length = myQuestion.length;
							for(var i=0; i<length; i++){
								if(myQuestion[i].isDistributive == true){
									numberAvailableForDistributiveIndex = i;
									break;
								}
							}

							var operatorBox = new Box;	//operator box
							operatorBox.key = "*";
							var pulledBoxOutOfParenthesis = new Box; //to take it out of parenthesis
							pulledBoxOutOfParenthesis.key = myQuestion[dragSourceBoxIndex].key;

							var openParenthesisIndex = getOpenParenthesisIndex(boxes, myQuestionIndex, dragSourceBoxIndex);	//index of left parenthesis
							var closeParenthesisIndex = getCloseParenthesisIndex(boxes, myQuestionIndex, dragSourceBoxIndex); //index of right parenthesis

							var dragSourceBoxKey = myQuestion[dragSourceBoxIndex].key;
							var numberKey = myQuestion[numberAvailableForDistributiveIndex].key;

							tempQuestion = getCloneQuestion(myQuestion);

							//when a dragged source is behind of number
							if(dragSourceBoxIndex > numberAvailableForDistributiveIndex){

								//when right side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
									tempQuestion[dragSourceBoxIndex].key = 1;
								}
								//when right side number's count is more than 2
								else{
									tempQuestion.splice(dragSourceBoxIndex,1);//remove number

									if(tempQuestion[dragSourceBoxIndex-1].key == "*"){//remove a front operator
										tempQuestion.splice(dragSourceBoxIndex-1,1);
									}else{//remove a back operator (if a front operator is parenthesis or + or -)
										tempQuestion.splice(dragSourceBoxIndex,1);
									}
								}

								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when left side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
										tempQuestion[numberAvailableForDistributiveIndex].key = 1;
									}
									//when left side number's count is more than 2
									else{
										tempQuestion.splice(numberAvailableForDistributiveIndex,1);//remove number
										if(tempQuestion[numberAvailableForDistributiveIndex-1].key == "*"){//remove a front operator
											tempQuestion.splice(numberAvailableForDistributiveIndex-1,1);
										}else{//remove a back operator (if a front operator is parenthesis or + or -)
											tempQuestion.splice(numberAvailableForDistributiveIndex,1);
										}
									}
								}
								//When dropped target's key is  a multiple of a dragged source
								else{
									tempQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
								}

							}
							//when a dragged source is in front of number
							else{
								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when right side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
										tempQuestion[numberAvailableForDistributiveIndex].key = 1;
									}
									//when right side number's count is more than 2
									else{
										tempQuestion.splice(numberAvailableForDistributiveIndex,1);//remove number

										if(tempQuestion[numberAvailableForDistributiveIndex-1].key == "*"){//remove a front operator
											tempQuestion.splice(numberAvailableForDistributiveIndex-1,1);
										}else{//remove a back operator (if a front operator is parenthesis or + or -)
											tempQuestion.splice(numberAvailableForDistributiveIndex,1);
										}
									}
								}
								//When dropped target's key is  a multiple of a dragged source
								else{
									tempQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
								}

								//when left side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
									tempQuestion[dragSourceBoxIndex].key = 1;
								}
								//when left side number's count is more than 2
								else{
									tempQuestion.splice(dragSourceBoxIndex,1);//remove number

									if(tempQuestion[dragSourceBoxIndex-1].key == "*"){//remove a front operator
										tempQuestion.splice(dragSourceBoxIndex-1,1);
									}else{//remove a back operator (if a front operator is parenthesis or + or -)
										tempQuestion.splice(dragSourceBoxIndex,1);
									}
								}
							}

							tempQuestion.splice(openParenthesisIndex, 0, pulledBoxOutOfParenthesis, operatorBox);//apply distributive law (get it out of parenthesis)

							//Animation---------------------------------------------------------------------------------------------------------------------
							alignBox(myQuestionIndex);
							var questionLength = myQuestion.length;

							if(dragSourceBoxIndex > numberAvailableForDistributiveIndex){
								var addLeftSideMoving = 2;
								//left side---------------------------------------------------------------------------------------------------------
								//When a dragged source has the same key with a dropped target

								if(numberKey == dragSourceBoxKey){

									//when left side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = 1;

										var endIndex = 0;
										if(myQuestion[dragSourceBoxIndex-1].key == "*"){
											endIndex = dragSourceBoxIndex - 1;
										}else{
											endIndex = dragSourceBoxIndex;
										}

										for(var i=openParenthesisIndex; i<endIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

										addLeftSideMoving = 0;
									}
									//when right side number's count is more than 2
									else{
										if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex+1);

											for(var i=openParenthesisIndex; i<numberAvailableForDistributiveIndex; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}
										}else{
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex-2) + 'ArcBackward', numberAvailableForDistributiveIndex-1);

											for(var i=openParenthesisIndex; i<numberAvailableForDistributiveIndex-1; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}
										}
									}
								//When dropped target's key is a multiple of a dragged source
								}else{
									if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex+1]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										myQuestion.push(mainOperatorClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-2);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

									}else if(myQuestion[numberAvailableForDistributiveIndex-1].key == "*"){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex-1]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										myQuestion.push(mainOperatorClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-2);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex-2) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

									}else{

										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
									}

									var endIndex = 0;
									if(myQuestion[dragSourceBoxIndex-1].key == "*"){
										endIndex = dragSourceBoxIndex - 1;
									}else{
										endIndex = dragSourceBoxIndex;
									}

									for(var i=openParenthesisIndex; i<endIndex; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}

									addLeftSideMoving = 0;

								}

								//right side----------------------------------------------------------------------------------------------------------
								//when right side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
									var mainOperandClone = getCloneBox(myQuestion[dragSourceBoxIndex]);
									myQuestion.push(mainOperandClone);
									setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
									myQuestion[dragSourceBoxIndex].key = 1;

									for(var i=dragSourceBoxIndex; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}
								}//when right side number's count is more than 2
								else{
									if(myQuestion[dragSourceBoxIndex+1].key == "*"){
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex+1);

										for(var i=dragSourceBoxIndex+2; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}else{
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex-2) + 'ArcBackward', dragSourceBoxIndex-1);

										for(var i=dragSourceBoxIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}
								}
							}else{
								var addLeftSideMoving = 2;
								//left side----------------------------------------------------------------------------------------------------------
								//when left side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
									var mainOperandClone = getCloneBox(myQuestion[dragSourceBoxIndex]);
									myQuestion.push(mainOperandClone);
									setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
									myQuestion[dragSourceBoxIndex].key = 1;

									var endIndex = 0;
									if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
										endIndex = numberAvailableForDistributiveIndex;
									}else{
										endIndex = numberAvailableForDistributiveIndex - 1;
									}

									for(var i=openParenthesisIndex; i<endIndex; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}

									addLeftSideMoving = 0;
								}
								//when left side number's count is more than 2
								else{
									if(myQuestion[dragSourceBoxIndex+1].key == "*"){
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex+1);

										for(var i=openParenthesisIndex; i<dragSourceBoxIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

									}else{
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex) + 'ArcBackward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (dragSourceBoxIndex-openParenthesisIndex-2) + 'ArcBackward', dragSourceBoxIndex-1);

										for(var i=openParenthesisIndex; i<dragSourceBoxIndex-1; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + (2*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}
								}
								//right side----------------------------------------------------------------------------------------------------------
								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when right side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = 1;

									}
									//when right side number's count is more than 2
									else{
										if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex+1);

											for(var i=numberAvailableForDistributiveIndex+2; i<questionLength; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}

										}else{
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex-2) + 'ArcBackward', numberAvailableForDistributiveIndex-1);

											for(var i=numberAvailableForDistributiveIndex+1; i<questionLength; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}
										}
									}
								//When dropped target's key is a multiple of a dragged source
								}else{
									if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex+1]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										myQuestion.push(mainOperatorClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-2);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

									}else if(myQuestion[numberAvailableForDistributiveIndex-1].key == "*"){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex-1]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										myQuestion.push(mainOperatorClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-2);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex-2) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex-1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}else{
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (numberAvailableForDistributiveIndex-openParenthesisIndex) + 'ArcBackward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}
								}
							}

							return;
						}
					}
					//Rule_RD4-3-1
					else{
						myDropTarget.rules.push("R_W4-3-1");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;

						}else if(mode == "drop"){
							wrongDropMessages.push("You can drag " + number1.key + " over " + openParenthesis1.key + " in " + parseSubtreeToString(parenthesis1) + " for distribution.");
						}
					}
				}

				//Rule_RD4-3-2
				if( !((hasNode(parenthesis1['Binary']['Left'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Right'], number1.key))
						|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Left'], number1.key)) ) ){

					if(openParenthesis1 == parenthesis1['open']){
						myDropTarget.rules.push("R_W4-3-2");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(hasNode(parenthesis1['Binary']['Left'], number1)){
								wrongDropMessages.push("A multiple of " + number1.key + " must be in " + parseSubtreeToString(parenthesis1['Binary']['Right'])+" for distribution.");
							}else{
								wrongDropMessages.push("A multiple of " + number1.key + " must be in " + parseSubtreeToString(parenthesis1['Binary']['Left'])+" for distribution.");
							}
						}
					}
				}
			}
		}

		if(myDropTarget.key == ")"){
			var closeParenthesis1 = myDropTarget;
			var parenthesisWithNumber1 = findAncestorNode(syntax, 'Parenthesis', number1);

			//Rule4-4
			if(parenthesisWithNumber1 == 'Parenthesis' && (parenthesisWithNumber1['Binary']['operator'].key == '+' || parenthesisWithNumber1['Binary']['operator'].key == '-') ){
				var parenthesis1 = parenthesisWithNumber1;

				//Rule4-4
				if( (hasNode(parenthesis1['Binary']['Left'], number1) && hasSameKeyValue(parenthesis1['Binary']['Right'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Left'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Right'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasSameKeyValue(parenthesis1['Binary']['Left'], number1.key))
					|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Left'], number1.key))){

					//Rule_RD4-4
					if(closeParenthesis1 == parenthesis1['close']){
						myDropTarget.rules = [];
						myDropTarget.rules.push("R_R4-4");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = true;
							return;

						}else if(mode == "drop"){

							rightDropMessage = "Right!\n"+ parseSubtreeToString(parenthesis1) + " is distributive.";

							var dragSourceBoxIndex = getBoxIndexUsingBox(myQuestion, myDragSource);	//index of a dragged source box
							var dropTargetBoxIndex = getBoxIndexUsingBox(myQuestion, myDropTarget);	//index of a dropped target box

							var numberAvailableForDistributiveIndex = -1;
							var questionLength = myQuestion.length;

							for(var i=0; i<questionLength; i++){
								if(myQuestion[i].isDistributive == true){
									numberAvailableForDistributiveIndex = i;
									break;
								}
							}

							var operatorBox = new Box;	//operator box
							operatorBox.key = "*";
							var pulledBoxOutOfParenthesis = new Box; //to take it out of parenthesis
							pulledBoxOutOfParenthesis.key = myQuestion[dragSourceBoxIndex].key;

							var openParenthesisIndex = getOpenParenthesisIndex(boxes, myQuestionIndex, dragSourceBoxIndex);	//index of left parenthesis
							var closeParenthesisIndex = getCloseParenthesisIndex(boxes, myQuestionIndex, dragSourceBoxIndex);

							var dragSourceBoxKey = myQuestion[dragSourceBoxIndex].key;
							var numberKey = myQuestion[numberAvailableForDistributiveIndex].key;

							tempQuestion = getCloneQuestion(myQuestion);

							tempQuestion.splice(closeParenthesisIndex+1, 0, operatorBox, pulledBoxOutOfParenthesis); //apply distributive law (get it out of parenthesis)

							//when a dragged source is behind of number
							if(dragSourceBoxIndex > numberAvailableForDistributiveIndex){

								//when right side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
									tempQuestion[dragSourceBoxIndex].key = "1";
								}
								//when right side number's count is more than 2
								else{
									tempQuestion.splice(dragSourceBoxIndex,1);//remove number

									if(tempQuestion[dragSourceBoxIndex-1].key == "*"){//remove a front operator
										tempQuestion.splice(dragSourceBoxIndex-1,1);
									}else{//remove a back operator (if a front operator is parenthesis or + or -)
										tempQuestion.splice(dragSourceBoxIndex,1);
									}
								}

								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when left side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
										tempQuestion[numberAvailableForDistributiveIndex].key = "1";
									}
									//when left side number's count is more than 2
									else{
										tempQuestion.splice(numberAvailableForDistributiveIndex,1);//remove number

										if(tempQuestion[numberAvailableForDistributiveIndex-1].key == "*"){//remove a front operator
											tempQuestion.splice(numberAvailableForDistributiveIndex-1,1);
										}else{//remove a back operator (if a front operator is parenthesis or + or -)
											tempQuestion.splice(numberAvailableForDistributiveIndex,1);
										}
									}
								}
								//When dropped target's key is  a multiple of a dragged source
								else{
									tempQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
								}

							}
							//when a dragged source is in front of number
							else{

								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when right side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
										tempQuestion[numberAvailableForDistributiveIndex].key = "1";
									}
									//when right side number's count is more than 2
									else{
										tempQuestion.splice(numberAvailableForDistributiveIndex,1);//remove number

										if(tempQuestion[numberAvailableForDistributiveIndex-1].key == "*"){//remove a front operator
											tempQuestion.splice(numberAvailableForDistributiveIndex-1,1);
										}else{//remove a back operator (if a front operator is parenthesis or + or -)
											tempQuestion.splice(numberAvailableForDistributiveIndex,1);
										}
									}
								}
								//When dropped target's key is  a multiple of a dragged source
								else{
									tempQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
								}

								//when left side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
									tempQuestion[dragSourceBoxIndex].key = "1";
								}
								//when left side number's count is more than 2
								else{
									tempQuestion.splice(dragSourceBoxIndex,1);//remove number

									if(tempQuestion[dragSourceBoxIndex-1].key == "*"){//remove a front operator
										tempQuestion.splice(dragSourceBoxIndex-1,1);
									}else{//remove a back operator (if a front operator is parenthesis or + or -)
										tempQuestion.splice(dragSourceBoxIndex,1);
									}
								}
							}


							//Animation---------------------------------------------------------------------------------------------------------------------
							alignBox(myQuestionIndex);

							if(dragSourceBoxIndex > numberAvailableForDistributiveIndex){

								var addRightSideMoving = 2;
								var addLeftSideMoving = 2;
								//left
								if(numberKey == dragSourceBoxKey){
									if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
										addLeftSideMoving = 0;
									}
								}else{
									addLeftSideMoving = 0;
								}

								//right
								if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
									addRightSideMoving = 0;
								}

								//left side---------------------------------------------------------------------------------------------------------
								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when left side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-addRightSideMoving) + 'ArcForward', myQuestion.length-1);
										myQuestion[numberAvailableForDistributiveIndex].key = "1";
									}
									//when right side number's count is more than 2
									else{
										if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){

											setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-2-addRightSideMoving) + 'ArcForward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (closeParenthesisIndex-(numberAvailableForDistributiveIndex+1)+1-2-addRightSideMoving) + 'ArcForward', numberAvailableForDistributiveIndex+1);


											for(var i=numberAvailableForDistributiveIndex+2; i<dragSourceBoxIndex; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}


										}else{
											setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-2-addRightSideMoving) + 'ArcForward', numberAvailableForDistributiveIndex);
											setArcAnimation(myQuestion, (closeParenthesisIndex-(numberAvailableForDistributiveIndex-1)+1-2-addRightSideMoving) + 'ArcForward', numberAvailableForDistributiveIndex-1);

											for(var i=numberAvailableForDistributiveIndex+1; i<dragSourceBoxIndex; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}
										}
									}
								//When dropped target's key is a multiple of a dragged source
								}else{
									if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex+1]);
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);

										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperatorClone);
										myQuestion.push(mainOperandClone);

										setArcAnimation(myQuestion, (closeParenthesisIndex-(numberAvailableForDistributiveIndex+1)+1-addRightSideMoving) + 'ArcForward', myQuestion.length-2);
										setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-addRightSideMoving) + 'ArcForward', myQuestion.length-1);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

									}else if(myQuestion[numberAvailableForDistributiveIndex-1].key == "*"){
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex-1]);
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);

										mainOperandClone.key = dragSourceBoxKey;
										myQuestion.push(mainOperatorClone);
										myQuestion.push(mainOperandClone);

										setArcAnimation(myQuestion, (closeParenthesisIndex-(numberAvailableForDistributiveIndex-1)+1-addRightSideMoving) + 'ArcForward', myQuestion.length-2);

										setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-addRightSideMoving) + 'ArcForward', myQuestion.length-1);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

									}else{
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);

										mainOperandClone.key = dragSourceBoxKey;

										myQuestion.push(mainOperandClone);
										setArcAnimation(myQuestion, (closeParenthesisIndex-numberAvailableForDistributiveIndex+2-addRightSideMoving) + 'ArcForward', myQuestion.length-1);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();
									}
								}

								//right side----------------------------------------------------------------------------------------------------------
								//when right side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Right']) == 1){

									var mainOperandClone = getCloneBox(myQuestion[dragSourceBoxIndex]);
									myQuestion.push(mainOperandClone);
									var mainOperandMoving = closeParenthesisIndex-dragSourceBoxIndex+2-addLeftSideMoving;

									if(mainOperandMoving>0){
										setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', myQuestion.length-1);
									}else{
										setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', myQuestion.length-1);
									}

									myQuestion[dragSourceBoxIndex].key = "1";

									for(var i=dragSourceBoxIndex; i<=closeParenthesisIndex; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}

									var beforeMainOperandMoving = 2-addLeftSideMoving;

									for(var i=closeParenthesisIndex+1; i<questionLength; i++){
										myQuestion[i].animationType = 'linearMotion';
										myQuestion[i].destinationX = myQuestion[i].x + (beforeMainOperandMoving*(BOX_WIDTH+GAP));
										myQuestion[i].destinationY = myQuestion[i].y;
										myQuestion[i].isAnimating = true;
										setAnimationAceleration(myQuestion[i]);
									}

								}//when right side number's count is more than 2
								else{
									if(myQuestion[dragSourceBoxIndex+1].key == "*"){

										var mainOperandMoving = closeParenthesisIndex-dragSourceBoxIndex+2-2-addLeftSideMoving;
										var mainOperatorMoving = closeParenthesisIndex-(dragSourceBoxIndex+1)+1-2-addLeftSideMoving;

										if(mainOperandMoving>0){
											setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', dragSourceBoxIndex);
										}else{
											setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', dragSourceBoxIndex);
										}

										if(mainOperatorMoving>0){
											setArcAnimation(myQuestion, mainOperatorMoving + 'ArcForward', dragSourceBoxIndex+1);
										}else{
											setArcAnimation(myQuestion, (-mainOperatorMoving) + 'ArcBackward', dragSourceBoxIndex+1);
										}

										for(var i=dragSourceBoxIndex+2; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - ((2+addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}


										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - ((addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}


									}else{

										var mainOperandMoving = closeParenthesisIndex-dragSourceBoxIndex+2-2-addLeftSideMoving;
										var mainOperatorMoving = closeParenthesisIndex-(dragSourceBoxIndex-1)+1-2-addLeftSideMoving;

										if(mainOperandMoving>0){
											setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', dragSourceBoxIndex);
										}else{
											setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', dragSourceBoxIndex);
										}

										if(mainOperatorMoving>0){
											setArcAnimation(myQuestion, mainOperatorMoving + 'ArcForward', dragSourceBoxIndex-1);
										}else{
											setArcAnimation(myQuestion, (-mainOperatorMoving) + 'ArcBackward', dragSourceBoxIndex-1);
										}

										for(var i=dragSourceBoxIndex+1; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - ((2+addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}


										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - ((addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

									}
								}
							}else{

								var addRightSideMoving = 2;
								var addLeftSideMoving = 2;

								//left
								if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
									addLeftSideMoving = 0;
								}

								//right
								if(numberKey == dragSourceBoxKey){
									if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
										addRightSideMoving = 0;
									}
								}else{
									addRightSideMoving = 0;
								}



								//left side----------------------------------------------------------------------------------------------------------
								//when left side number's count is 1
								if(getNumberCount(parenthesis1['Binary']['Left']) == 1){
									var mainOperandClone = getCloneBox(myQuestion[dragSourceBoxIndex]);
									myQuestion.push(mainOperandClone);
									setArcAnimation(myQuestion, (closeParenthesisIndex-dragSourceBoxIndex+2-addRightSideMoving) + 'ArcForward', myQuestion.length-1);
									myQuestion[dragSourceBoxIndex].key = "1";
								}
								//when left side number's count is more than 2
								else{
									if(myQuestion[dragSourceBoxIndex+1].key == "*"){

										setArcAnimation(myQuestion, (closeParenthesisIndex-dragSourceBoxIndex+2-2-addRightSideMoving) + 'ArcForward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (closeParenthesisIndex-(dragSourceBoxIndex+1)+1-2-addRightSideMoving) + 'ArcForward', dragSourceBoxIndex+1);


										for(var i=dragSourceBoxIndex+2; i<numberAvailableForDistributiveIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}


									}else{
										setArcAnimation(myQuestion, (closeParenthesisIndex-dragSourceBoxIndex+2-2-addRightSideMoving) + 'ArcForward', dragSourceBoxIndex);
										setArcAnimation(myQuestion, (closeParenthesisIndex-(dragSourceBoxIndex-1)+1-2-addRightSideMoving) + 'ArcForward', dragSourceBoxIndex-1);

										for(var i=dragSourceBoxIndex+1; i<numberAvailableForDistributiveIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (2*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}
								}
								//right side----------------------------------------------------------------------------------------------------------
								//When a dragged source has the same key with a dropped target
								if(numberKey == dragSourceBoxKey){
									//when right side number's count is 1
									if(getNumberCount(parenthesis1['Binary']['Right']) == 1){
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										myQuestion.push(mainOperandClone);
										var mainOperandMoving = closeParenthesisIndex-numberAvailableForDistributiveIndex+2-addLeftSideMoving;

										if(mainOperandMoving>0){
											setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', myQuestion.length-1);
										}else{
											setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', myQuestion.length-1);
										}

										myQuestion[numberAvailableForDistributiveIndex].key = "1";

										for(var i=numberAvailableForDistributiveIndex; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

										var beforeMainOperandMoving = 2-addLeftSideMoving;

										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + (beforeMainOperandMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}


									}
									//when right side number's count is more than 2
									else{
										if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){

											var mainOperandMoving = closeParenthesisIndex-numberAvailableForDistributiveIndex+2-2-addLeftSideMoving;
											var mainOperatorMoving = closeParenthesisIndex-(numberAvailableForDistributiveIndex+1)+1-2-addLeftSideMoving;

											if(mainOperandMoving>0){
												setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', numberAvailableForDistributiveIndex);
											}else{
												setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', numberAvailableForDistributiveIndex);
											}

											if(mainOperatorMoving>0){
												setArcAnimation(myQuestion, mainOperatorMoving + 'ArcForward', numberAvailableForDistributiveIndex+1);
											}else{
												setArcAnimation(myQuestion, (-mainOperatorMoving) + 'ArcBackward', numberAvailableForDistributiveIndex+1);
											}

											for(var i=numberAvailableForDistributiveIndex+2; i<=closeParenthesisIndex; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - ((2+addLeftSideMoving)*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}


											for(var i=closeParenthesisIndex+1; i<questionLength; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - ((addLeftSideMoving)*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}


										}else{

											var mainOperandMoving = closeParenthesisIndex-numberAvailableForDistributiveIndex+2-2-addLeftSideMoving;
											var mainOperatorMoving = closeParenthesisIndex-(numberAvailableForDistributiveIndex-1)+1-2-addLeftSideMoving;

											if(mainOperandMoving>0){
												setArcAnimation(myQuestion, mainOperandMoving + 'ArcForward', numberAvailableForDistributiveIndex);
											}else{
												setArcAnimation(myQuestion, (-mainOperandMoving) + 'ArcBackward', numberAvailableForDistributiveIndex);
											}

											if(mainOperatorMoving>0){
												setArcAnimation(myQuestion, mainOperatorMoving + 'ArcForward', numberAvailableForDistributiveIndex-1);
											}else{
												setArcAnimation(myQuestion, (-mainOperatorMoving) + 'ArcBackward', numberAvailableForDistributiveIndex-1);
											}

											for(var i=numberAvailableForDistributiveIndex+1; i<=closeParenthesisIndex; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - ((2+addLeftSideMoving)*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}


											for(var i=closeParenthesisIndex+1; i<questionLength; i++){
												myQuestion[i].animationType = 'linearMotion';
												myQuestion[i].destinationX = myQuestion[i].x - ((addLeftSideMoving)*(BOX_WIDTH+GAP));
												myQuestion[i].destinationY = myQuestion[i].y;
												myQuestion[i].isAnimating = true;
												setAnimationAceleration(myQuestion[i]);
											}

										}

									}
								//When dropped target's key is a multiple of a dragged source
								}else{
									if(myQuestion[numberAvailableForDistributiveIndex+1].key == "*"){
										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex+1]);
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);

										mainOperandClone.key = dragSourceBoxKey;

										myQuestion.push(mainOperatorClone);
										myQuestion.push(mainOperandClone);

										setArcAnimation(myQuestion, (closeParenthesisIndex - numberAvailableForDistributiveIndex+2-addLeftSideMoving) + 'ArcForward', myQuestion.length-1);

										setArcAnimation(myQuestion, (closeParenthesisIndex - (numberAvailableForDistributiveIndex+1)+1-addLeftSideMoving) + 'ArcForward', myQuestion.length-2);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

									}else if(myQuestion[numberAvailableForDistributiveIndex-1].key == "*"){

										var mainOperatorClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex-1]);
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);

										mainOperandClone.key = dragSourceBoxKey;

										myQuestion.push(mainOperatorClone);
										myQuestion.push(mainOperandClone);

										setArcAnimation(myQuestion, (closeParenthesisIndex - numberAvailableForDistributiveIndex+2-addLeftSideMoving) + 'ArcForward', myQuestion.length-1);
										setArcAnimation(myQuestion, (closeParenthesisIndex - (numberAvailableForDistributiveIndex-1)+1-addLeftSideMoving) + 'ArcForward', myQuestion.length-2);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex-1; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

									}else{
										var mainOperandClone = getCloneBox(myQuestion[numberAvailableForDistributiveIndex]);
										myQuestion.push(mainOperandClone);

										setArcAnimation(myQuestion, (closeParenthesisIndex - numberAvailableForDistributiveIndex+2-addLeftSideMoving) + 'ArcForward', myQuestion.length-1);

										myQuestion[numberAvailableForDistributiveIndex].key = (parseFloat(numberKey) / parseFloat(dragSourceBoxKey)).toString();

										for(var i=numberAvailableForDistributiveIndex; i<=closeParenthesisIndex; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x - (addLeftSideMoving*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}

										for(var i=closeParenthesisIndex+1; i<questionLength; i++){
											myQuestion[i].animationType = 'linearMotion';
											myQuestion[i].destinationX = myQuestion[i].x + ((2-addLeftSideMoving)*(BOX_WIDTH+GAP));
											myQuestion[i].destinationY = myQuestion[i].y;
											myQuestion[i].isAnimating = true;
											setAnimationAceleration(myQuestion[i]);
										}
									}

								}
							}


							return;
						}
					}
					//Rule_WD4-4-1
					else{
						myDropTarget.rules.push("R_W4-4-1");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;

						}else if(mode == "drop"){
							wrongDropMessages.push("You can drag " + number1.key + " over " + closeParenthesis1.key + " in " + parseSubtreeToString(parenthesis1) + " for distribution.");
						}
					}
				}

				//Rule_RD4-4-2
				if( !((hasNode(parenthesis1['Binary']['Left'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Right'], number1.key))
						|| (hasNode(parenthesis1['Binary']['Right'], number1) && hasMultipleKeyValue(parenthesis1['Binary']['Left'], number1.key)))){

					if(closeParenthesis1 == parenthesis1['close']){
						myDropTarget.rules.push("R_W4-4-2");
						if(mode == "drag"){
							myDropTarget.isCandidate = true;
							myDropTarget.isRightRule = false;
						}else if(mode == "drop"){
							if(hasNode(parenthesis1['Binary']['Left'], number1)){
								wrongDropMessages.push("A multiple of " + number1.key + " must be in " + parseSubtreeToString(parenthesis1['Binary']['Right']) + " for distribution.");
							}else{
								wrongDropMessages.push("A multiple of " + number1.key + " must be in " + parseSubtreeToString(parenthesis1['Binary']['Left']) + " for distribution.");
							}
						}
					}
				}
			}
		}
	}
}

//check a type of a key
function checkKeyType(key){
	if(isOperator(key)){
		return 'operator'
	}else if(isParenthesis(key)){
		return 'parenthesis'
	}else{
		return 'number'
	}
}

//check whether tree has the same key or not
function hasSameKeyValue(syntax, keyValue){
	function findNode(syntax, key){
		var child;
		if(key == null){
			child = syntax;
		}else{
			child = syntax[key];
		}

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
					if(keyOfNode == 'number' || keyOfNode == 'operator'){
						if(child[keyOfNode].key == keyValue){
							child[keyOfNode].isDistributive = true;
							return true;
						}
	        		}else{
	        			var returnValue = findNode(child,keyOfNode);
		        		if( typeof returnValue != 'undefined'){
		        			return returnValue;
		        		}
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(syntax, null) || false;
}

//check whether tree has the multiple key or not
function hasMultipleKeyValue(syntax, keyValue){
	function findNode(syntax, key){
		var child;
		if(key == null){
			child = syntax;
		}else{
			child = syntax[key];
		}

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
					if(keyOfNode == 'number' || keyOfNode == 'operator'){
						if(parseFloat(child[keyOfNode].key) % parseFloat(keyValue) == 0){
							child[keyOfNode].isDistributive = true;
							return true;
						}
	        		}else{
	        			var returnValue = findNode(child,keyOfNode);
		        		if( typeof returnValue != 'undefined'){
		        			return returnValue;
		        		}
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(syntax, null) || false;
}

//check whether tree has the node or not
function hasNode(syntax, node){
	function findNode(syntax, key){
		var child;
		if(key == null){
			child = syntax;
		}else{
			child = syntax[key];
		}

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
	        		if(child == node){
	        			return true;
	        		}else{
	        			var returnValue = findNode(child,keyOfNode);
		        		if( typeof returnValue != 'undefined'){
		        			return returnValue;
		        		}
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(syntax, null) || false;
}

function getNumberCount(node){
	var count = 0;

	function findNode(node, key){
		var child;
		if(key == null){
			child = node;
		}else{
			child = node[key];
		}

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
	        		if(keyOfNode == 'number'){
	        			count++;
	        		}else{
	        			findNode(child,keyOfNode);
	        		}
	            }
	        }
		}
	}

	findNode(node, null);

	return count;
}

//find whether there is Parenthesis in sub tree
function findParenthesis(node){
	function findNode(node, key){
		var child;
		if(key == null){
			child = node;
		}else{
			child = node[key];
		}

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
	        		if(keyOfNode == 'Parenthesis'){
	        			return child['Parenthesis'];
	        		}else{
	        			var returnValue = findNode(child,keyOfNode);
		        		if( typeof returnValue != 'undefined'){
		        			return returnValue;
		        		}
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(node, null);
}

function findBinaryHavingNumberInRightChild(node){
	function findNode(node, key){
		var child;
		if(key == null){
			child = node;
		}else{
			child = node[key];
		}

		if(typeof child == 'object'){
			if(child == 'Binary' && child['Right'].hasOwnProperty('number')){
				return child;
			}else if(child == 'Parenthesis'){
				return;
			}
			for (keyOfNode in child) {
	        	if (child.hasOwnProperty(keyOfNode)) {
        			var returnValue = findNode(child,keyOfNode);
	        		if( typeof returnValue != 'undefined'){
	        			return returnValue;
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(node, null);
}

// find Ancestor
function findAncestorNode(syntax, ancestor, node){
	var parent = findParentNode(syntax, node);
	var i=0;
	while(true){
		parent = findParentNode(syntax, parent);
		if(parent == ancestor){
			return parent;
		}else if(parent == null){
			return false;
		}
	}
}

//find Ancestor Binary having operator + or -
function findAncestorBinaryHavingOperatorPlusOrMinus(syntax, node){
	var parent = node;

	while(true){
		parent = findParentNode(syntax, parent);
		if(parent == 'Binary' && (parent['operator'].key == '+' || parent['operator'].key == '-')){
			return parent;
		}else if(parent == null){
			return false;
		}
	}
}

//find parent node
function findParentNode(syntax, node){
	function findNode(syntax, key , node){
		var parent = syntax;
		var child = syntax[key];

		if(typeof child == 'object'){
			for (keyOfNode in child) {
	        	if (child == node){
	        		return parent;
	        	}else if (child.hasOwnProperty(keyOfNode)) {
	        		var returnValue = findNode(child, keyOfNode ,node);
	        		if( typeof returnValue != 'undefined'){
	        			return returnValue;
	        		}
	            }
	        }
		}
		return;
	}
	return findNode(syntax, 'Expression' , node);
}

//to show subtree in string.
function parseSubtreeToString(subtree){
	function stringify(subtree, key) {
		var value;
		if(key == null){
			value = subtree;
		}else{
			value = subtree[key];
		}
	    var keyOfNode;
	    var str="";
	    if(typeof value == 'object'){
	        for (keyOfNode in value) {
				if (value instanceof Box){
	        		str += value.key;
	        		break;
	        	}else if (value.hasOwnProperty(keyOfNode)) {
	        		if(keyOfNode != 'toString'){
	        			str += stringify(value, keyOfNode);
	        		}
	            }
	        }
	    }

	    return str;
	}
	return stringify(subtree, null);
}

//get string of operator
function getOperatoString(operator){
	var operatiorString;

	if(operator == '+'){
		operatiorString = "add";
	}else if(operator == '-'){
		operatiorString = "substract";
	}else if(operator == '*'){
		operatiorString = "multipl";
	}else if(operator == '/'){
		operatiorString = "divid";
	}

	return operatiorString;
}

//clone
function getCloneBox(box){
	var newBox = new Box;
	newBox.x = box.x;
	newBox.y = box.y;
	newBox.key = box.key;
	newBox.fill = box.fill;

	return newBox;
}

//clone
function getCloneQuestion(question){
	var newQuestion=[];

	var length = question.length;
	for(var i=0; i<length; i++){
		var newBox = new Box;
		newBox.key = question[i].key;
		newQuestion.push(newBox);
	}

	return newQuestion;
}

//copy box's atrributes
function copyBoxAtrributes(sourceBox, targetBox){
	targetBox.isSelected = sourceBox.isSelected;
	targetBox.isSelectedCandidate = sourceBox.isSelectedCandidate;
	targetBox.isCandidate = sourceBox.isCandidate;
	targetBox.isRightRule = sourceBox.isRightRule;
	targetBox.isDistributive = sourceBox.isDistributive

	targetBox.rules = [];
	var length = sourceBox.rules.length;
	for(var i=0; i<length; i++){
		targetBox.rules.push(sourceBox.rules[i]);
	}
}

//get index of box using box
function getBoxIndexUsingBox(question, box){
	var index = -1;

	var length = question.length;
	for(var i=0; i<length; i++){
		if(question[i] == box){
			index = i;
			break;
		}
	}

	return index;
}

function setArcAnimation(question ,animationType, index){
	question[index].animationType = animationType;
	question[index].destinationX = question[index].x;
	question[index].destinationY = question[index].y;
	question[index].isAnimating = true;
}

//align box
function alignBox(questionNumber){
	var length = boxes[questionNumber].length
	for(var i=0; i<length; i++){
		boxes[questionNumber][i].x = MARGIN_X+i*(BOX_WIDTH+GAP);
		boxes[questionNumber][i].y = MARGIN_Y+questionNumber*(BOX_HEIGHT+GAP);
		boxes[questionNumber][i].animationAccelerationX=0.0;
		boxes[questionNumber][i].animationAccelerationY=0.0;

		if(isNumber(boxes[questionNumber][i].key)){
			var number = parseFloat(boxes[questionNumber][i].key);
			if(number < 0){//negative number

				if(i - 1 >= 0){//If is is not foremost number
					if(isOperator(boxes[questionNumber][i-1].key) && !isMulDiv(boxes[questionNumber][i-1].key) ){
						if(i + 1 == length){
							if(boxes[questionNumber][i-1].key == '+'){
								boxes[questionNumber][i-1].key = '-';
							}else{
								boxes[questionNumber][i-1].key = '+';
							}
							boxes[questionNumber][i].key = (-1*number).toString();
						}else if(i + 1 < length){
							if(isOperator(boxes[questionNumber][i-1].key) && !isMulDiv(boxes[questionNumber][i+1].key) ){
								if(boxes[questionNumber][i-1].key == '+'){
									boxes[questionNumber][i-1].key = '-';
								}else{
									boxes[questionNumber][i-1].key = '+';
								}
								boxes[questionNumber][i].key = (-1*number).toString();
							}
						}
					}
				}
			}
		}
	}

	if(boxes[questionNumber].length == 1){
		if(boxes[questionNumber][0].key == answers[questionNumber].answer){//if a answer is correct
			answers[questionNumber].state = "correct";
			//alert("Yay! You are Correct!");
		}else{//if a answer is incorrect
			answers[questionNumber].state = "incorrect";
		}
	}


}

//Sets mx,my to the mouse position relative to the canvas
function getMouse(element, e, isTouch) {
	var offsetX = 0;
	var offsetY = 0;

	//for scroll in type2 canvas
	if(element === treeCanvas){
		offsetX -= element.parentNode.scrollLeft;
		offsetY -= element.parentNode.scrollTop;
	}

	if (element.offsetParent) {
		do {
			offsetX += element.offsetLeft;
			offsetY += element.offsetTop;

		} while ((element = element.offsetParent));
	}

	var point;
	if(isTouch == true){
		point = e.touches[0];
	}else{
		point = e;
	}

	mx = point.pageX - offsetX;
	my = point.pageY - offsetY;
}



//About Time------------------------------------------------------------------------------------------------------------------------------
function startTimer(){
	timer = setInterval("tick()", 1000);
}

function stopTimer(){
	clearInterval(timer);
}

function tick()
{
	timeText++;
	setTime();
}

function setTime(){
	var hours = Math.floor(timeText / 360);
	var minutes = Math.floor(timeText / 60);
	var seconds = timeText % 60;

	document.getElementById("timeText").value = getTwoDigitTime(hours)+":"+getTwoDigitTime(minutes)+":"+getTwoDigitTime(seconds);
}

function getTwoDigitTime(time){
	var timeText="";
	if(time <10){
		timeText = "0"+time.toString();
	}else{
		timeText = time.toString();
	}
	return timeText;
}
//About Time------------------------------------------------------------------------------------------------------------------------------


//About States------------------------------------------------------------------------------------------------------------------------------
function changeFontState(){
	//fontFont.setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	var fontSelect = document.getElementById("fontSelect");

	if(fontSelect.value == "HAND"){

		mainFont = "HandWrittingFont";
		boldForStyle = "";
		boldForCanvasContext = "";
		fontFamily = "font-family: " + mainFont + ", Calibri, sans-serif;";

	}else if(fontSelect.value == "HAND-BOLD"){

		mainFont = "HandWrittingFont";
		boldForStyle = "font-weight: bold;";
		boldForCanvasContext = "bold ";
		fontFamily = "font-family: " + mainFont + ", Calibri, sans-serif;";

	}else if(fontSelect.value == "NORMAL"){

		mainFont = "Arial";
		boldForStyle = "";
		boldForCanvasContext = "";
		fontFamily = "font-family: " + mainFont + ", Calibri, sans-serif;";
	}

	if(pageState == "1"){
		document.getElementById("questionNumberFont").setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 30px;");
		document.getElementById("questionTimeFont").setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 30px;");
		document.getElementById("questionNumberSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 20px; " + boldForStyle + "");
		document.getElementById("questionTimeSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 20px; " + boldForStyle + "");
		document.getElementById("okButton").setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	}else if(pageState == "2"){
		document.getElementById("problemFont").setAttribute("style", fontFamily + " padding-left:10pt; vertical-align: middle; " + boldForStyle + " ; font-size:30pt;");
		document.getElementById("explanation1Font").setAttribute("style", fontFamily + " padding-left:50pt; vertical-align: middle; " + boldForStyle + " font-size: 15pt;");
		document.getElementById("explanation2Font").setAttribute("style", fontFamily + " padding-left:50pt; vertical-align: middle; " + boldForStyle + " font-size: 15pt;");

		for(var i=0; i<questionNumber; i++){
			document.getElementById("questionNumberFont"+i).setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
			document.getElementById("questionFont"+i).setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
		}
		document.getElementById("goButton").setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	}else if(pageState == "3"){

		document.getElementById("problemFont").setAttribute("style", fontFamily + " padding-left:10pt; vertical-align: middle; " + boldForStyle + "; font-size:30pt;");
		document.getElementById("singleQuestionNumberFont").setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
		document.getElementById("singleQuestionFont").setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
		document.getElementById("answerText").setAttribute("style", fontFamily + " text-align:center; font-size:30px; " + boldForStyle + " width:75px; height:50px;");
		document.getElementById("confirmButton").setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");
		document.getElementById("timeText").setAttribute("style", fontFamily + " text-align:center; font-size:30px; " + boldForStyle + " width:150px; height:50px; background-color:#d3d3d3; border: solid 1px #808080;");
		document.getElementById("nextButton").setAttribute("style", fontFamily + " font-size:30px; " + boldForStyle + " width:150px; height:50px;");

	}else if(pageState == "4"){

		for(var i=0; i<questionNumber; i++){
			document.getElementById("questionNumberFont"+i).setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
			document.getElementById("questionFont"+i).setAttribute("style", fontFamily + " vertical-align: middle; " + boldForStyle + " font-size: 25pt;");
			document.getElementById("answerText"+i).setAttribute("style", fontFamily + " vertical-align: middle; text-align:center; font-size:30px; " + boldForStyle + " width:75px; height:50px;");
			document.getElementById("confirmButton"+i).setAttribute("style", fontFamily + " vertical-align: middle; font-size:30px; " + boldForStyle + " width:150px; height:50px;");
		}
	}else if(pageState == "5"){
		isCanvasValid = true;
		isTreeCanvasValid = true;
	}

	document.getElementById("fontFont").setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	document.getElementById("interactionFont").setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	document.getElementById("parseFont").setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	document.getElementById("treeFont").setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");
	document.getElementById("speedFont").setAttribute("style", fontFamily + " vertical-align:middle; " + boldForStyle + " font-size: 15pt;");

	document.getElementById("fontSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	document.getElementById("interactionSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	document.getElementById("parseSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
	document.getElementById("treeSelect").setAttribute("style", fontFamily + " width: 100px; font-size: 15px; " + boldForStyle + "");
}

function changeInteractionState(){
	var interactionSelect = document.getElementById("interactionSelect");

	if(interactionSelect.value == "WINDOW"){
		interactionState = "WINDOW";
		document.getElementById("ruleBody").innerHTML = "";

	}else if(interactionSelect.value == "RULE"){
		interactionState = "RULE";

	}else if(interactionSelect.value == "OFF"){
		interactionState = "OFF";
		document.getElementById("ruleBody").innerHTML = "";
	}
}

function changeParseState(){
	var parseSelect = document.getElementById("parseSelect");

	if(parseSelect.value == "OFF"){
		parseState = "OFF";

		if(treeState == "TOP-DOWN"){
			treeCanvasInit();
		}else if(treeState == "BOTTOM-UP"){
			treeCanvasInit();
		}else if(treeState == "DETAIL"){
			document.getElementById("detailTreeBody").innerHTML = "";
		}

	}else if(parseSelect.value == "ON"){
		parseState = "ON";

	}
}

function changeTreeState(){
	var treeSelect = document.getElementById("treeSelect");

	if(treeSelect.value == "TOP-DOWN"){
		treeState = "TOP-DOWN";

		treeCanvasInit();
		if(treeQuestionIndex != null){
			treeQuestion = boxes[treeQuestionIndex];
			generateTree();
			isTreeCanvasValid = true;
		}

	}else if(treeSelect.value == "BOTTOM-UP"){
		treeState = "BOTTOM-UP";

		treeCanvasInit();
		if(treeQuestionIndex != null){
			treeQuestion = boxes[treeQuestionIndex];
			generateTree();
			isTreeCanvasValid = true;
		}

	}else if(treeSelect.value == "DETAIL"){
		treeState = "DETAIL";

		detailTreeInit();
		if(treeQuestionIndex != null){
			treeQuestion = boxes[treeQuestionIndex];
			var syntax = parser.parse(treeQuestion);	//generator tree
			showDetailTree(syntax);					    //show parse tree
		}

	}
}

function changeSpeedSlideBarValue(){
	var speedSlideBar = document.getElementById("speedSlideBar");
	animationSpeed = parseFloat(speedSlideBar.value); //ramin changed from 60 - parse...
}
//About States------------------------------------------------------------------------------------------------------------------------------


</script>

</head>
<body onload="init()" style="margin: 0px; padding: 0px;">
	<table class='table' style='margin: auto; table-layout:fixed;'>
		<tr class='canvas'>
			<td class='canvas' align='left' style='width: 1600px;' >

				<font id='fontFont' color='#000080'>&nbsp;&nbsp;Font : </font>
				<select id='fontSelect' onchange='changeFontState()'>
					<option value='HAND-BOLD' selected='selected'>Hand-Bold</option>
					<option value='HAND'>Hand</option>
					<option value='NORMAL'>Normal</option>
				</select>

				<font id='interactionFont' color='#000080'>&nbsp;&nbsp;Interaction : </font>
				<select id='interactionSelect' onchange='changeInteractionState()' disabled='true'>
					<option value='WINDOW' selected='selected'>Window</option>
					<option value='RULE'>Rule</option>
					<option value='OFF'>Off</option>
				</select>

				<font id='parseFont' color='#000080'>&nbsp;&nbsp;Parse : </font>
				<select id='parseSelect' onchange='changeParseState()' disabled='true'>
					<option value='OFF' selected='selected'>Off</option>
					<option value='ON'>On</option>
				</select>

				<font id='treeFont' color='#000080'>&nbsp;&nbsp;Tree : </font>
				<select id='treeSelect' onchange='changeTreeState()' disabled='true'>
					<option value='TOP-DOWN' selected='selected'>Top-Down</option>
					<option value='BOTTOM-UP'>Bottom-Up</option>
					<option value='DETAIL'>Detail</option>
				</select>

				<font id='speedFont' color='#000080'>&nbsp;&nbsp;Speed : </font>
				<input id='speedSlideBar' type='range' style='vertical-align:middle;' min='0' max='50' value='25' onchange='changeSpeedSlideBarValue()' disabled='true'>
			</td>
		</tr>
	</table>

	<div id='mainBody' style='position: absolute; border: solid 1px #000000;'></div>
</body>
</html>
